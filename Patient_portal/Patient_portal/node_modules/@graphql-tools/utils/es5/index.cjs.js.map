{"version":3,"file":"index.cjs.js","sources":["../../../dist-es5/utils/src/helpers.js","../../../dist-es5/utils/src/debug-log.js","../../../dist-es5/utils/src/fix-windows-path.js","../../../dist-es5/utils/src/flatten-array.js","../../../dist-es5/utils/src/inspect.js","../../../dist-es5/utils/src/getArgumentValues.js","../../../dist-es5/utils/src/get-directives.js","../../../dist-es5/utils/src/get-fields-with-directives.js","../../../dist-es5/utils/src/get-implementing-types.js","../../../dist-es5/utils/src/create-schema-definition.js","../../../dist-es5/utils/src/print-schema-with-directives.js","../../../dist-es5/utils/src/validate-documents.js","../../../dist-es5/utils/src/fix-schema-ast.js","../../../node_modules/graphql/language/blockString.mjs","../../../dist-es5/utils/src/parse-graphql-sdl.js","../../../dist-es5/utils/src/parse-graphql-json.js","../../../dist-es5/utils/src/get-user-types-from-schema.js","../../../dist-es5/utils/src/build-operation-for-field.js","../../../dist-es5/utils/src/Interfaces.js","../../../dist-es5/utils/src/stub.js","../../../dist-es5/utils/src/rewire.js","../../../dist-es5/utils/src/transformInputValue.js","../../../dist-es5/utils/src/mapSchema.js","../../../dist-es5/utils/src/filterSchema.js","../../../dist-es5/utils/src/clone.js","../../../dist-es5/utils/src/heal.js","../../../dist-es5/utils/src/SchemaVisitor.js","../../../dist-es5/utils/src/visitSchema.js","../../../dist-es5/utils/src/SchemaDirectiveVisitor.js","../../../dist-es5/utils/src/getResolversFromSchema.js","../../../dist-es5/utils/src/forEachField.js","../../../dist-es5/utils/src/forEachDefaultValue.js","../../../dist-es5/utils/src/addTypes.js","../../../dist-es5/utils/src/prune.js","../../../dist-es5/utils/src/mergeDeep.js","../../../dist-es5/utils/src/fieldNodes.js","../../../dist-es5/utils/src/fragments.js","../../../dist-es5/utils/src/selectionSets.js","../../../dist-es5/utils/src/getResponseKeyFromInfo.js","../../../dist-es5/utils/src/transforms.js","../../../dist-es5/utils/src/fields.js","../../../dist-es5/utils/src/renameType.js","../../../dist-es5/utils/src/collectFields.js","../../../dist-es5/utils/src/mapAsyncIterator.js","../../../dist-es5/utils/src/astFromType.js","../../../dist-es5/utils/src/updateArgument.js","../../../dist-es5/utils/src/implementsAbstractType.js","../../../dist-es5/utils/src/errors.js","../../../dist-es5/utils/src/toConfig.js","../../../dist-es5/utils/src/observableToAsyncIterable.js","../../../dist-es5/utils/src/visitResult.js","../../../dist-es5/utils/src/valueMatchesCriteria.js"],"sourcesContent":["import { parse } from 'graphql';\nexport var asArray = function (fns) { return (Array.isArray(fns) ? fns : fns ? [fns] : []); };\nexport function isEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (var index = 0; index < a.length; index++) {\n            if (a[index] !== b[index]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b || (!a && !b);\n}\nexport function isNotEqual(a, b) {\n    return !isEqual(a, b);\n}\nexport function isDocumentString(str) {\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (/\\.[a-z0-9]+$/i.test(str)) {\n        return false;\n    }\n    try {\n        parse(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nvar invalidPathRegex = /[‘“!$%&^<=>`]/;\nexport function isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexport function compareStrings(a, b) {\n    if (a.toString() < b.toString()) {\n        return -1;\n    }\n    if (a.toString() > b.toString()) {\n        return 1;\n    }\n    return 0;\n}\nexport function nodeToString(a) {\n    if ('alias' in a) {\n        return a.alias.value;\n    }\n    if ('name' in a) {\n        return a.name.value;\n    }\n    return a.kind;\n}\nexport function compareNodes(a, b, customFn) {\n    var aStr = nodeToString(a);\n    var bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\n//# sourceMappingURL=helpers.js.map","import { __read, __spread } from \"tslib\";\nexport function debugLog() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (process && process.env && process.env.DEBUG && !process.env.GQL_tools_NODEBUG) {\n        // tslint:disable-next-line: no-console\n        console.log.apply(console, __spread(args));\n    }\n}\n//# sourceMappingURL=debug-log.js.map","export var fixWindowsPath = function (path) { return path.replace(/\\\\/g, '/'); };\n//# sourceMappingURL=fix-windows-path.js.map","export var flattenArray = function (arr) {\n    return arr.reduce(function (acc, next) { return acc.concat(Array.isArray(next) ? flattenArray(next) : next); }, []);\n};\n//# sourceMappingURL=flatten-array.js.map","import { __read, __spread } from \"tslib\";\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\nexport function inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? \"[function \" + value.name + \"]\" : '[function]';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (previouslySeenValues.indexOf(value) !== -1) {\n        return '[Circular]';\n    }\n    var seenValues = __spread(previouslySeenValues, [value]);\n    var customInspectFn = getCustomFn(value);\n    if (customInspectFn !== undefined) {\n        var customValue = customInspectFn.call(value);\n        // check for infinite recursion\n        if (customValue !== value) {\n            return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction formatObject(object, seenValues) {\n    var keys = Object.keys(object);\n    if (keys.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    var properties = keys.map(function (key) {\n        var value = formatValue(object[key], seenValues);\n        return key + ': ' + value;\n    });\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n    var remaining = array.length - len;\n    var items = [];\n    for (var i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push('... 1 more item');\n    }\n    else if (remaining > 1) {\n        items.push(\"... \" + remaining.toString(10) + \" more items\");\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getCustomFn(obj) {\n    if (typeof obj.inspect === 'function') {\n        return obj.inspect;\n    }\n}\nfunction getObjectTag(obj) {\n    var tag = Object.prototype.toString\n        .call(obj)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof obj.constructor === 'function') {\n        var name_1 = obj.constructor.name;\n        if (typeof name_1 === 'string' && name_1 !== '') {\n            return name_1;\n        }\n    }\n    return tag;\n}\n//# sourceMappingURL=inspect.js.map","import { __assign, __read, __values } from \"tslib\";\nimport { valueFromAST, isNonNullType, GraphQLError, Kind, print, } from 'graphql';\nimport { inspect } from './inspect';\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues) {\n    var e_1, _a;\n    var _b;\n    if (variableValues === void 0) { variableValues = {}; }\n    var variableMap = Object.entries(variableValues).reduce(function (prev, _a) {\n        var _b;\n        var _c = __read(_a, 2), key = _c[0], value = _c[1];\n        return (__assign(__assign({}, prev), (_b = {}, _b[key] = value, _b)));\n    }, {});\n    var coercedValues = {};\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    var argumentNodes = (_b = node.arguments) !== null && _b !== void 0 ? _b : [];\n    var argNodeMap = argumentNodes.reduce(function (prev, arg) {\n        var _a;\n        return (__assign(__assign({}, prev), (_a = {}, _a[arg.name.value] = arg, _a)));\n    }, {});\n    try {\n        for (var _c = __values(def.args), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var argDef = _d.value;\n            var name_1 = argDef.name;\n            var argType = argDef.type;\n            var argumentNode = argNodeMap[name_1];\n            if (!argumentNode) {\n                if (argDef.defaultValue !== undefined) {\n                    coercedValues[name_1] = argDef.defaultValue;\n                }\n                else if (isNonNullType(argType)) {\n                    throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" + 'was not provided.', node);\n                }\n                continue;\n            }\n            var valueNode = argumentNode.value;\n            var isNull = valueNode.kind === Kind.NULL;\n            if (valueNode.kind === Kind.VARIABLE) {\n                var variableName = valueNode.name.value;\n                if (variableValues == null || !(variableName in variableMap)) {\n                    if (argDef.defaultValue !== undefined) {\n                        coercedValues[name_1] = argDef.defaultValue;\n                    }\n                    else if (isNonNullType(argType)) {\n                        throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" +\n                            (\"was provided the variable \\\"$\" + variableName + \"\\\" which was not provided a runtime value.\"), valueNode);\n                    }\n                    continue;\n                }\n                isNull = variableValues[variableName] == null;\n            }\n            if (isNull && isNonNullType(argType)) {\n                throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of non-null type \\\"\" + inspect(argType) + \"\\\" \" + 'must not be null.', valueNode);\n            }\n            var coercedValue = valueFromAST(valueNode, argType, variableValues);\n            if (coercedValue === undefined) {\n                // Note: ValuesOfCorrectTypeRule validation should catch this before\n                // execution. This is a runtime check to ensure execution does not\n                // continue with an invalid argument value.\n                throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" has invalid value \" + print(valueNode) + \".\", valueNode);\n            }\n            coercedValues[name_1] = coercedValue;\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return coercedValues;\n}\n//# sourceMappingURL=getArgumentValues.js.map","import { __read, __spread } from \"tslib\";\nimport { getArgumentValues } from './getArgumentValues';\nexport function getDirectives(schema, node) {\n    var schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n    var schemaDirectiveMap = schemaDirectives.reduce(function (schemaDirectiveMap, schemaDirective) {\n        schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n        return schemaDirectiveMap;\n    }, {});\n    var astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = __spread(astNodes, node.extensionASTNodes);\n    }\n    var result = {};\n    astNodes.forEach(function (astNode) {\n        if (astNode.directives) {\n            astNode.directives.forEach(function (directive) {\n                var schemaDirective = schemaDirectiveMap[directive.name.value];\n                if (schemaDirective) {\n                    var directiveValue = getDirectiveValues(schemaDirective, astNode);\n                    if (schemaDirective.isRepeatable) {\n                        if (result[schemaDirective.name]) {\n                            result[schemaDirective.name] = result[schemaDirective.name].concat([directiveValue]);\n                        }\n                        else {\n                            result[schemaDirective.name] = [directiveValue];\n                        }\n                    }\n                    else {\n                        result[schemaDirective.name] = directiveValue;\n                    }\n                }\n            });\n        }\n    });\n    return result;\n}\n// graphql-js getDirectiveValues does not handle repeatable directives\nfunction getDirectiveValues(directiveDef, node) {\n    if (node.directives) {\n        if (directiveDef.isRepeatable) {\n            var directiveNodes = node.directives.filter(function (directive) { return directive.name.value === directiveDef.name; });\n            return directiveNodes.map(function (directiveNode) { return getArgumentValues(directiveDef, directiveNode); });\n        }\n        var directiveNode = node.directives.find(function (directive) { return directive.name.value === directiveDef.name; });\n        return getArgumentValues(directiveDef, directiveNode);\n    }\n}\n//# sourceMappingURL=get-directives.js.map","import { __assign, __read, __spread, __values } from \"tslib\";\nimport { Kind, } from 'graphql';\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case Kind.INT:\n            return parseInt(value.value);\n        case Kind.FLOAT:\n            return parseFloat(value.value);\n        case Kind.BOOLEAN:\n            return Boolean(value.value);\n        case Kind.STRING:\n        case Kind.ENUM:\n            return value.value;\n        case Kind.LIST:\n            return value.values.map(function (v) { return parseDirectiveValue(v); });\n        case Kind.OBJECT:\n            return value.fields.reduce(function (prev, v) {\n                var _a;\n                return (__assign(__assign({}, prev), (_a = {}, _a[v.name.value] = parseDirectiveValue(v.value), _a)));\n            }, {});\n        case Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nexport function getFieldsWithDirectives(documentNode, options) {\n    var e_1, _a, e_2, _b;\n    if (options === void 0) { options = {}; }\n    var result = {};\n    var selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = __spread(selected, ['InputObjectTypeDefinition', 'InputObjectTypeExtension']);\n    }\n    var allTypes = documentNode.definitions.filter(function (obj) { return selected.includes(obj.kind); });\n    try {\n        for (var allTypes_1 = __values(allTypes), allTypes_1_1 = allTypes_1.next(); !allTypes_1_1.done; allTypes_1_1 = allTypes_1.next()) {\n            var type = allTypes_1_1.value;\n            var typeName = type.name.value;\n            try {\n                for (var _c = (e_2 = void 0, __values(type.fields)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                    var field = _d.value;\n                    if (field.directives && field.directives.length > 0) {\n                        var fieldName = field.name.value;\n                        var key = typeName + \".\" + fieldName;\n                        var directives = field.directives.map(function (d) { return ({\n                            name: d.name.value,\n                            args: (d.arguments || []).reduce(function (prev, arg) {\n                                var _a;\n                                return (__assign(__assign({}, prev), (_a = {}, _a[arg.name.value] = parseDirectiveValue(arg.value), _a)));\n                            }, {}),\n                        }); });\n                        result[key] = directives;\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (allTypes_1_1 && !allTypes_1_1.done && (_a = allTypes_1.return)) _a.call(allTypes_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return result;\n}\n//# sourceMappingURL=get-fields-with-directives.js.map","import { isObjectType } from 'graphql';\nexport function getImplementingTypes(interfaceName, schema) {\n    var allTypesMap = schema.getTypeMap();\n    var result = [];\n    for (var graphqlTypeName in allTypesMap) {\n        var graphqlType = allTypesMap[graphqlTypeName];\n        if (isObjectType(graphqlType)) {\n            var allInterfaces = graphqlType.getInterfaces();\n            if (allInterfaces.find(function (int) { return int.name === interfaceName; })) {\n                result.push(graphqlType.name);\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=get-implementing-types.js.map","export function createSchemaDefinition(def, config) {\n    var schemaRoot = {};\n    if (def.query) {\n        schemaRoot.query = def.query.toString();\n    }\n    if (def.mutation) {\n        schemaRoot.mutation = def.mutation.toString();\n    }\n    if (def.subscription) {\n        schemaRoot.subscription = def.subscription.toString();\n    }\n    var fields = Object.keys(schemaRoot)\n        .map(function (rootType) { return (schemaRoot[rootType] ? rootType + \": \" + schemaRoot[rootType] : null); })\n        .filter(function (a) { return a; });\n    if (fields.length) {\n        return \"schema { \" + fields.join('\\n') + \" }\";\n    }\n    if (config && config.force) {\n        return \" schema { query: Query } \";\n    }\n    return undefined;\n}\n//# sourceMappingURL=create-schema-definition.js.map","import { __assign, __values } from \"tslib\";\nimport { print, printType, Kind, isSpecifiedScalarType, isIntrospectionType, isScalarType, parse, } from 'graphql';\nimport { createSchemaDefinition } from './create-schema-definition';\nexport function printSchemaWithDirectives(schema, _options) {\n    var e_1, _a;\n    var _b;\n    if (_options === void 0) { _options = {}; }\n    var typesMap = schema.getTypeMap();\n    var result = [getSchemaDefinition(schema)];\n    for (var typeName in typesMap) {\n        var type = typesMap[typeName];\n        var isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n        var isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        // KAMIL: we might want to turn on descriptions in future\n        result.push(print((_b = correctType(typeName, typesMap)) === null || _b === void 0 ? void 0 : _b.astNode));\n    }\n    var directives = schema.getDirectives();\n    try {\n        for (var directives_1 = __values(directives), directives_1_1 = directives_1.next(); !directives_1_1.done; directives_1_1 = directives_1.next()) {\n            var directive = directives_1_1.value;\n            if (directive.astNode) {\n                result.push(print(directive.astNode));\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (directives_1_1 && !directives_1_1.done && (_a = directives_1.return)) _a.call(directives_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return result.join('\\n');\n}\nfunction extendDefinition(type) {\n    switch (type.astNode.kind) {\n        case Kind.OBJECT_TYPE_DEFINITION:\n            return __assign(__assign({}, type.astNode), { fields: type.astNode.fields.concat(type.extensionASTNodes.reduce(function (fields, node) { return fields.concat(node.fields); }, [])) });\n        case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n            return __assign(__assign({}, type.astNode), { fields: type.astNode.fields.concat(type.extensionASTNodes.reduce(function (fields, node) { return fields.concat(node.fields); }, [])) });\n        default:\n            return type.astNode;\n    }\n}\nfunction correctType(typeName, typesMap) {\n    var e_2, _a, e_3, _b;\n    var _c;\n    var type = typesMap[typeName];\n    type.name = typeName.toString();\n    if (type.astNode && type.extensionASTNodes) {\n        type.astNode = type.extensionASTNodes ? extendDefinition(type) : type.astNode;\n    }\n    var doc = parse(printType(type));\n    var fixedAstNode = doc.definitions[0];\n    var originalAstNode = type === null || type === void 0 ? void 0 : type.astNode;\n    if (originalAstNode) {\n        fixedAstNode.directives = originalAstNode === null || originalAstNode === void 0 ? void 0 : originalAstNode.directives;\n        if (fixedAstNode && 'fields' in fixedAstNode && originalAstNode && 'fields' in originalAstNode) {\n            var _loop_1 = function (fieldDefinitionNode) {\n                var e_4, _a;\n                var originalFieldDefinitionNode = originalAstNode.fields.find(function (field) { return field.name.value === fieldDefinitionNode.name.value; });\n                fieldDefinitionNode.directives = originalFieldDefinitionNode === null || originalFieldDefinitionNode === void 0 ? void 0 : originalFieldDefinitionNode.directives;\n                if (fieldDefinitionNode &&\n                    'arguments' in fieldDefinitionNode &&\n                    originalFieldDefinitionNode &&\n                    'arguments' in originalFieldDefinitionNode) {\n                    var _loop_3 = function (argument) {\n                        var originalArgumentNode = (_c = originalFieldDefinitionNode.arguments) === null || _c === void 0 ? void 0 : _c.find(function (arg) { return arg.name.value === argument.name.value; });\n                        argument.directives = originalArgumentNode.directives;\n                    };\n                    try {\n                        for (var _b = (e_4 = void 0, __values(fieldDefinitionNode.arguments)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var argument = _c.value;\n                            _loop_3(argument);\n                        }\n                    }\n                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_4) throw e_4.error; }\n                    }\n                }\n            };\n            try {\n                for (var _d = __values(fixedAstNode.fields), _e = _d.next(); !_e.done; _e = _d.next()) {\n                    var fieldDefinitionNode = _e.value;\n                    _loop_1(fieldDefinitionNode);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }\n        else if (fixedAstNode && 'values' in fixedAstNode && originalAstNode && 'values' in originalAstNode) {\n            var _loop_2 = function (valueDefinitionNode) {\n                var originalValueDefinitionNode = originalAstNode.values.find(function (valueNode) { return valueNode.name.value === valueDefinitionNode.name.value; });\n                valueDefinitionNode.directives = originalValueDefinitionNode === null || originalValueDefinitionNode === void 0 ? void 0 : originalValueDefinitionNode.directives;\n            };\n            try {\n                for (var _f = __values(fixedAstNode.values), _g = _f.next(); !_g.done; _g = _f.next()) {\n                    var valueDefinitionNode = _g.value;\n                    _loop_2(valueDefinitionNode);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        }\n    }\n    type.astNode = fixedAstNode;\n    return type;\n}\nfunction getSchemaDefinition(schema) {\n    if (!Object.getOwnPropertyDescriptor(schema, 'astNode').get && schema.astNode) {\n        return print(schema.astNode);\n    }\n    else {\n        return createSchemaDefinition({\n            query: schema.getQueryType(),\n            mutation: schema.getMutationType(),\n            subscription: schema.getSubscriptionType(),\n        });\n    }\n}\n//# sourceMappingURL=print-schema-with-directives.js.map","import { __awaiter, __generator, __read, __spread, __values } from \"tslib\";\nimport { Kind, validate, specifiedRules, } from 'graphql';\nimport AggregateError from '@ardatan/aggregate-error';\nexport function validateGraphQlDocuments(schema, documentFiles, effectiveRules) {\n    return __awaiter(this, void 0, void 0, function () {\n        var allFragments, allErrors;\n        var _this = this;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    effectiveRules = effectiveRules || createDefaultRules();\n                    allFragments = [];\n                    documentFiles.forEach(function (documentFile) {\n                        var e_1, _a;\n                        if (documentFile.document) {\n                            try {\n                                for (var _b = __values(documentFile.document.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {\n                                    var definitionNode = _c.value;\n                                    if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n                                        allFragments.push(definitionNode);\n                                    }\n                                }\n                            }\n                            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                            finally {\n                                try {\n                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                                }\n                                finally { if (e_1) throw e_1.error; }\n                            }\n                        }\n                    });\n                    allErrors = [];\n                    return [4 /*yield*/, Promise.all(documentFiles.map(function (documentFile) { return __awaiter(_this, void 0, void 0, function () {\n                            var documentToValidate, errors;\n                            return __generator(this, function (_a) {\n                                documentToValidate = {\n                                    kind: Kind.DOCUMENT,\n                                    definitions: __spread(allFragments, documentFile.document.definitions).filter(function (definition, index, list) {\n                                        if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n                                            var firstIndex = list.findIndex(function (def) { return def.kind === Kind.FRAGMENT_DEFINITION && def.name.value === definition.name.value; });\n                                            var isDuplicated = firstIndex !== index;\n                                            if (isDuplicated) {\n                                                return false;\n                                            }\n                                        }\n                                        return true;\n                                    }),\n                                };\n                                errors = validate(schema, documentToValidate, effectiveRules);\n                                if (errors.length > 0) {\n                                    allErrors.push({\n                                        filePath: documentFile.location,\n                                        errors: errors,\n                                    });\n                                }\n                                return [2 /*return*/];\n                            });\n                        }); }))];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/, allErrors];\n            }\n        });\n    });\n}\nexport function checkValidationErrors(loadDocumentErrors) {\n    var e_2, _a;\n    if (loadDocumentErrors.length > 0) {\n        var errors = [];\n        var _loop_1 = function (loadDocumentError) {\n            var e_3, _a;\n            var _loop_2 = function (graphQLError) {\n                var error = new Error();\n                error.name = 'GraphQLDocumentError';\n                error.message = error.name + \": \" + graphQLError.message;\n                error.stack = error.message;\n                graphQLError.locations.forEach(function (location) { return (error.stack += \"\\n    at \" + loadDocumentError.filePath + \":\" + location.line + \":\" + location.column); });\n                errors.push(error);\n            };\n            try {\n                for (var _b = (e_3 = void 0, __values(loadDocumentError.errors)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var graphQLError = _c.value;\n                    _loop_2(graphQLError);\n                }\n            }\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_3) throw e_3.error; }\n            }\n        };\n        try {\n            for (var loadDocumentErrors_1 = __values(loadDocumentErrors), loadDocumentErrors_1_1 = loadDocumentErrors_1.next(); !loadDocumentErrors_1_1.done; loadDocumentErrors_1_1 = loadDocumentErrors_1.next()) {\n                var loadDocumentError = loadDocumentErrors_1_1.value;\n                _loop_1(loadDocumentError);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (loadDocumentErrors_1_1 && !loadDocumentErrors_1_1.done && (_a = loadDocumentErrors_1.return)) _a.call(loadDocumentErrors_1);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        throw new AggregateError(errors);\n    }\n}\nfunction createDefaultRules() {\n    var ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n    // GraphQL v14 has no Rule suffix in function names\n    // Adding `*Rule` makes validation backwards compatible\n    ignored.forEach(function (rule) {\n        ignored.push(rule.replace(/Rule$/, ''));\n    });\n    return specifiedRules.filter(function (f) { return !ignored.includes(f.name); });\n}\n//# sourceMappingURL=validate-documents.js.map","import { __assign } from \"tslib\";\nimport { buildSchema } from 'graphql';\nimport { printSchemaWithDirectives } from './print-schema-with-directives';\nfunction buildFixedSchema(schema, options) {\n    return buildSchema(printSchemaWithDirectives(schema, options), __assign({ noLocation: true }, (options || {})));\n}\nexport function fixSchemaAst(schema, options) {\n    var schemaWithValidAst;\n    if (!schema.astNode) {\n        Object.defineProperty(schema, 'astNode', {\n            get: function () {\n                if (!schemaWithValidAst) {\n                    schemaWithValidAst = buildFixedSchema(schema, options);\n                }\n                return schemaWithValidAst.astNode;\n            },\n        });\n    }\n    if (!schema.extensionASTNodes) {\n        Object.defineProperty(schema, 'extensionASTNodes', {\n            get: function () {\n                if (!schemaWithValidAst) {\n                    schemaWithValidAst = buildFixedSchema(schema, options);\n                }\n                return schemaWithValidAst.extensionASTNodes;\n            },\n        });\n    }\n    return schema;\n}\n//# sourceMappingURL=fix-schema-ast.js.map","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var hasTrailingSlash = value[value.length - 1] === '\\\\';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","import { __assign } from \"tslib\";\nimport { Kind, TokenKind, parse, Source as GraphQLSource, visit, isTypeSystemDefinitionNode, print, } from 'graphql';\nimport { dedentBlockStringValue } from 'graphql/language/blockString';\nexport function parseGraphQLSDL(location, rawSDL, options) {\n    if (options === void 0) { options = {}; }\n    var document;\n    var sdl = rawSDL;\n    var sdlModified = false;\n    try {\n        if (options.commentDescriptions && sdl.includes('#')) {\n            sdlModified = true;\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = parse(print(document), options);\n            }\n        }\n        else {\n            document = parse(new GraphQLSource(sdl, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF')) {\n            document = {\n                kind: Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location: location,\n        document: document,\n        rawSDL: sdlModified ? print(document) : sdl,\n    };\n}\nexport function getLeadingCommentBlock(node) {\n    var loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    var comments = [];\n    var token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next &&\n        token.prev &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        var value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexport function transformCommentsToDescriptions(sourceSdl, options) {\n    if (options === void 0) { options = {}; }\n    var parsedDoc = parse(sourceSdl, __assign(__assign({}, options), { noLocation: false }));\n    var modifiedDoc = visit(parsedDoc, {\n        leave: function (node) {\n            if (isDescribable(node)) {\n                var rawValue = getLeadingCommentBlock(node);\n                if (rawValue !== undefined) {\n                    var commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n                    var isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return __assign(__assign({}, node), { description: {\n                                kind: Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            } });\n                    }\n                    else {\n                        return __assign(__assign({}, node), { description: __assign(__assign({}, node.description), { value: node.description.value + '\\n' + commentsBlock, block: true }) });\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nexport function isDescribable(node) {\n    return (isTypeSystemDefinitionNode(node) ||\n        node.kind === Kind.FIELD_DEFINITION ||\n        node.kind === Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === Kind.ENUM_VALUE_DEFINITION);\n}\n//# sourceMappingURL=parse-graphql-sdl.js.map","import { buildClientSchema } from 'graphql';\nimport { printSchemaWithDirectives } from './print-schema-with-directives';\nimport { parseGraphQLSDL } from './parse-graphql-sdl';\nfunction stripBOM(content) {\n    content = content.toString();\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xfeff) {\n        content = content.slice(1);\n    }\n    return content;\n}\nfunction parseBOM(content) {\n    return JSON.parse(stripBOM(content));\n}\nexport function parseGraphQLJSON(location, jsonContent, options) {\n    var parsedJson = parseBOM(jsonContent);\n    if (parsedJson.data) {\n        parsedJson = parsedJson.data;\n    }\n    if (parsedJson.kind === 'Document') {\n        var document_1 = parsedJson;\n        return {\n            location: location,\n            document: document_1,\n        };\n    }\n    else if (parsedJson.__schema) {\n        var schema = buildClientSchema(parsedJson, options);\n        var rawSDL = printSchemaWithDirectives(schema, options);\n        return {\n            location: location,\n            document: parseGraphQLSDL(location, rawSDL, options).document,\n            rawSDL: rawSDL,\n            schema: schema,\n        };\n    }\n    throw new Error(\"Not valid JSON content\");\n}\n//# sourceMappingURL=parse-graphql-json.js.map","import { isObjectType } from 'graphql';\n/**\n * Get all GraphQL types from schema without:\n *\n * - Query, Mutation, Subscription objects\n * - Internal scalars added by parser\n *\n * @param schema\n */\nexport function getUserTypesFromSchema(schema) {\n    var allTypesMap = schema.getTypeMap();\n    // tslint:disable-next-line: no-unnecessary-local-variable\n    var modelTypes = Object.values(allTypesMap).filter(function (graphqlType) {\n        if (isObjectType(graphqlType)) {\n            // Filter out private types\n            if (graphqlType.name.startsWith('__')) {\n                return false;\n            }\n            if (schema.getMutationType() && graphqlType.name === schema.getMutationType().name) {\n                return false;\n            }\n            if (schema.getQueryType() && graphqlType.name === schema.getQueryType().name) {\n                return false;\n            }\n            if (schema.getSubscriptionType() && graphqlType.name === schema.getSubscriptionType().name) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    });\n    return modelTypes;\n}\n//# sourceMappingURL=get-user-types-from-schema.js.map","import { __assign, __read, __spread } from \"tslib\";\nimport { isObjectType, getNamedType, isUnionType, isNonNullType, isScalarType, isListType, isInterfaceType, isEnumType, Kind, } from 'graphql';\nimport { camelCase } from 'camel-case';\nvar operationVariables = [];\nvar fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationName(name) {\n    return camelCase(name);\n}\nexport function buildOperationNodeForField(_a) {\n    var schema = _a.schema, kind = _a.kind, field = _a.field, models = _a.models, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, argNames = _a.argNames, _b = _a.selectedFields, selectedFields = _b === void 0 ? true : _b;\n    resetOperationVariables();\n    resetFieldMap();\n    var operationNode = buildOperationAndCollectVariables({\n        schema: schema,\n        fieldName: field,\n        kind: kind,\n        models: models || [],\n        ignore: ignore || [],\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames: argNames,\n        selectedFields: selectedFields,\n    });\n    // attach variables\n    operationNode.variableDefinitions = __spread(operationVariables);\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nfunction buildOperationAndCollectVariables(_a) {\n    var schema = _a.schema, fieldName = _a.fieldName, kind = _a.kind, models = _a.models, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, argNames = _a.argNames, selectedFields = _a.selectedFields;\n    var typeMap = {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n    };\n    var type = typeMap[kind];\n    var field = type.getFields()[fieldName];\n    var operationName = buildOperationName(fieldName + \"_\" + kind);\n    if (field.args) {\n        field.args.forEach(function (arg) {\n            var argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        });\n    }\n    return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: 'Name',\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type: type,\n                    field: field,\n                    models: models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore: ignore,\n                    depthLimit: depthLimit,\n                    circularReferenceDepth: circularReferenceDepth,\n                    schema: schema,\n                    depth: 0,\n                    argNames: argNames,\n                    selectedFields: selectedFields,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet(_a) {\n    var parent = _a.parent, type = _a.type, models = _a.models, firstCall = _a.firstCall, path = _a.path, ancestors = _a.ancestors, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, schema = _a.schema, depth = _a.depth, argNames = _a.argNames, selectedFields = _a.selectedFields;\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if (isUnionType(type)) {\n        var types = type.getTypes();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(function (t) {\n                return !hasCircularRef(__spread(ancestors, [t]), {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(function (t) {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models: models,\n                        path: path,\n                        ancestors: ancestors,\n                        ignore: ignore,\n                        depthLimit: depthLimit,\n                        circularReferenceDepth: circularReferenceDepth,\n                        schema: schema,\n                        depth: depth,\n                        argNames: argNames,\n                        selectedFields: selectedFields,\n                    }),\n                };\n            })\n                .filter(function (fragmentNode) { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isInterfaceType(type)) {\n        var types = Object.values(schema.getTypeMap()).filter(function (t) { return isObjectType(t) && t.getInterfaces().includes(type); });\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(function (t) {\n                return !hasCircularRef(__spread(ancestors, [t]), {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(function (t) {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models: models,\n                        path: path,\n                        ancestors: ancestors,\n                        ignore: ignore,\n                        depthLimit: depthLimit,\n                        circularReferenceDepth: circularReferenceDepth,\n                        schema: schema,\n                        depth: depth,\n                        argNames: argNames,\n                        selectedFields: selectedFields,\n                    }),\n                };\n            })\n                .filter(function (fragmentNode) { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isObjectType(type)) {\n        var isIgnored = ignore.includes(type.name) || ignore.includes(parent.name + \".\" + path[path.length - 1]);\n        var isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: Kind.FIELD,\n                        name: {\n                            kind: Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        var fields_1 = type.getFields();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: Object.keys(fields_1)\n                .filter(function (fieldName) {\n                return !hasCircularRef(__spread(ancestors, [getNamedType(fields_1[fieldName].type)]), {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(function (fieldName) {\n                var selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type: type,\n                        field: fields_1[fieldName],\n                        models: models,\n                        path: __spread(path, [fieldName]),\n                        ancestors: ancestors,\n                        ignore: ignore,\n                        depthLimit: depthLimit,\n                        circularReferenceDepth: circularReferenceDepth,\n                        schema: schema,\n                        depth: depth,\n                        argNames: argNames,\n                        selectedFields: selectedSubFields,\n                    });\n                }\n            })\n                .filter(function (f) {\n                var _a, _b;\n                if (f) {\n                    if ('selectionSet' in f) {\n                        return (_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                return false;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if (isListType(type)) {\n            return {\n                kind: Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if (isNonNullType(type)) {\n            return {\n                kind: Kind.NON_NULL_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: Kind.NAMED_TYPE,\n            name: {\n                kind: Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return camelCase(__spread(path, [name]).join('_'));\n}\nfunction resolveField(_a) {\n    var type = _a.type, field = _a.field, models = _a.models, firstCall = _a.firstCall, path = _a.path, ancestors = _a.ancestors, ignore = _a.ignore, depthLimit = _a.depthLimit, circularReferenceDepth = _a.circularReferenceDepth, schema = _a.schema, depth = _a.depth, argNames = _a.argNames, selectedFields = _a.selectedFields;\n    var namedType = getNamedType(field.type);\n    var args = [];\n    var removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(function (arg) {\n            var argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if (isNonNullType(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: Kind.VARIABLE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    var fieldPath = __spread(path, [field.name]);\n    var fieldPathStr = fieldPath.join('.');\n    var fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!isScalarType(namedType) && !isEnumType(namedType)) {\n        return __assign(__assign({ kind: Kind.FIELD, name: {\n                kind: Kind.NAME,\n                value: field.name,\n            } }, (fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } })), { selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models: models,\n                firstCall: firstCall,\n                path: fieldPath,\n                ancestors: __spread(ancestors, [type]),\n                ignore: ignore,\n                depthLimit: depthLimit,\n                circularReferenceDepth: circularReferenceDepth,\n                schema: schema,\n                depth: depth + 1,\n                argNames: argNames,\n                selectedFields: selectedFields,\n            }) || undefined, arguments: args });\n    }\n    return __assign(__assign({ kind: Kind.FIELD, name: {\n            kind: Kind.NAME,\n            value: field.name,\n        } }, (fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } })), { arguments: args });\n}\nfunction hasCircularRef(types, config) {\n    if (config === void 0) { config = {\n        depth: 1,\n    }; }\n    var type = types[types.length - 1];\n    if (isScalarType(type)) {\n        return false;\n    }\n    var size = types.filter(function (t) { return t.name === type.name; }).length;\n    return size > config.depth;\n}\n//# sourceMappingURL=build-operation-for-field.js.map","export var VisitSchemaKind;\n(function (VisitSchemaKind) {\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind || (VisitSchemaKind = {}));\nexport var MapperKind;\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n//# sourceMappingURL=Interfaces.js.map","import { GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID, isObjectType, isInterfaceType, isInputObjectType, Kind, GraphQLList, GraphQLNonNull, } from 'graphql';\nexport function createNamedStub(name, type) {\n    var constructor;\n    if (type === 'object') {\n        constructor = GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = GraphQLInterfaceType;\n    }\n    else {\n        constructor = GraphQLInputObjectType;\n    }\n    return new constructor({\n        name: name,\n        fields: {\n            __fake: {\n                type: GraphQLString,\n            },\n        },\n    });\n}\nexport function createStub(node, type) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            return new GraphQLList(createStub(node.type, type));\n        case Kind.NON_NULL_TYPE:\n            return new GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nexport function isNamedStub(type) {\n    if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n        var fields = type.getFields();\n        var fieldNames = Object.keys(fields);\n        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n    }\n    return false;\n}\nexport function getBuiltInForStub(type) {\n    switch (type.name) {\n        case GraphQLInt.name:\n            return GraphQLInt;\n        case GraphQLFloat.name:\n            return GraphQLFloat;\n        case GraphQLString.name:\n            return GraphQLString;\n        case GraphQLBoolean.name:\n            return GraphQLBoolean;\n        case GraphQLID.name:\n            return GraphQLID;\n        default:\n            return type;\n    }\n}\n//# sourceMappingURL=stub.js.map","import { __assign } from \"tslib\";\nimport { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLObjectType, GraphQLNonNull, GraphQLScalarType, GraphQLUnionType, isInterfaceType, isEnumType, isInputObjectType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isUnionType, isSpecifiedScalarType, isSpecifiedDirective, } from 'graphql';\nimport { getBuiltInForStub, isNamedStub } from './stub';\nexport function rewireTypes(originalTypeMap, directives, options) {\n    if (options === void 0) { options = {\n        skipPruning: false,\n    }; }\n    var referenceTypeMap = Object.create(null);\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    });\n    var newTypeMap = Object.create(null);\n    Object.keys(referenceTypeMap).forEach(function (typeName) {\n        var namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            return;\n        }\n        var newName = namedType.name;\n        if (newName.startsWith('__')) {\n            return;\n        }\n        if (newTypeMap[newName] != null) {\n            throw new Error(\"Duplicate schema type name \" + newName);\n        }\n        newTypeMap[newName] = namedType;\n    });\n    Object.keys(newTypeMap).forEach(function (typeName) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    });\n    var newDirectives = directives.map(function (directive) { return rewireDirective(directive); });\n    // TODO:\n    // consider removing the default level of pruning in v7,\n    // see comments below on the pruneTypes function.\n    return options.skipPruning\n        ? {\n            typeMap: newTypeMap,\n            directives: newDirectives,\n        }\n        : pruneTypes(newTypeMap, newDirectives);\n    function rewireDirective(directive) {\n        if (isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        var directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        var rewiredArgs = {};\n        Object.keys(args).forEach(function (argName) {\n            var arg = args[argName];\n            var rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        });\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (isObjectType(type)) {\n            var config_1 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_1), { fields: function () { return rewireFields(config_1.fields); }, interfaces: function () { return rewireNamedTypes(config_1.interfaces); } });\n            return new GraphQLObjectType(newConfig);\n        }\n        else if (isInterfaceType(type)) {\n            var config_2 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_2), { fields: function () { return rewireFields(config_2.fields); } });\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = function () {\n                    return rewireNamedTypes(config_2.interfaces);\n                };\n            }\n            return new GraphQLInterfaceType(newConfig);\n        }\n        else if (isUnionType(type)) {\n            var config_3 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_3), { types: function () { return rewireNamedTypes(config_3.types); } });\n            return new GraphQLUnionType(newConfig);\n        }\n        else if (isInputObjectType(type)) {\n            var config_4 = type.toConfig();\n            var newConfig = __assign(__assign({}, config_4), { fields: function () { return rewireInputFields(config_4.fields); } });\n            return new GraphQLInputObjectType(newConfig);\n        }\n        else if (isEnumType(type)) {\n            var enumConfig = type.toConfig();\n            return new GraphQLEnumType(enumConfig);\n        }\n        else if (isScalarType(type)) {\n            if (isSpecifiedScalarType(type)) {\n                return type;\n            }\n            var scalarConfig = type.toConfig();\n            return new GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(\"Unexpected schema type: \" + type);\n    }\n    function rewireFields(fields) {\n        var rewiredFields = {};\n        Object.keys(fields).forEach(function (fieldName) {\n            var field = fields[fieldName];\n            var rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        });\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        var rewiredFields = {};\n        Object.keys(fields).forEach(function (fieldName) {\n            var field = fields[fieldName];\n            var rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        });\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        var rewiredTypes = [];\n        namedTypes.forEach(function (namedType) {\n            var rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        });\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (isListType(type)) {\n            var rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\n        }\n        else if (isNonNullType(type)) {\n            var rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n        }\n        else if (isNamedType(type)) {\n            var rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n// TODO:\n// consider removing the default level of pruning in v7\n//\n// Pruning during mapSchema limits the ability to create an unpruned schema, which may be of use\n// to some library users. pruning is now recommended via the dedicated pruneSchema function\n// which does not force pruning on library users and gives granular control in terms of pruning\n// types.\nfunction pruneTypes(typeMap, directives) {\n    var newTypeMap = {};\n    var implementedInterfaces = {};\n    Object.keys(typeMap).forEach(function (typeName) {\n        var namedType = typeMap[typeName];\n        if ('getInterfaces' in namedType) {\n            namedType.getInterfaces().forEach(function (iface) {\n                implementedInterfaces[iface.name] = true;\n            });\n        }\n    });\n    var prunedTypeMap = false;\n    var typeNames = Object.keys(typeMap);\n    for (var i = 0; i < typeNames.length; i++) {\n        var typeName = typeNames[i];\n        var type = typeMap[typeName];\n        if (isObjectType(type) || isInputObjectType(type)) {\n            // prune types with no fields\n            if (Object.keys(type.getFields()).length) {\n                newTypeMap[typeName] = type;\n            }\n            else {\n                prunedTypeMap = true;\n            }\n        }\n        else if (isUnionType(type)) {\n            // prune unions without underlying types\n            if (type.getTypes().length) {\n                newTypeMap[typeName] = type;\n            }\n            else {\n                prunedTypeMap = true;\n            }\n        }\n        else if (isInterfaceType(type)) {\n            // prune interfaces without fields or without implementations\n            if (Object.keys(type.getFields()).length && implementedInterfaces[type.name]) {\n                newTypeMap[typeName] = type;\n            }\n            else {\n                prunedTypeMap = true;\n            }\n        }\n        else {\n            newTypeMap[typeName] = type;\n        }\n    }\n    // every prune requires another round of healing\n    return prunedTypeMap ? rewireTypes(newTypeMap, directives) : { typeMap: typeMap, directives: directives };\n}\n//# sourceMappingURL=rewire.js.map","import { getNullableType, isLeafType, isListType, isInputObjectType, } from 'graphql';\nexport function transformInputValue(type, value, transformer) {\n    if (value == null) {\n        return value;\n    }\n    var nullableType = getNullableType(type);\n    if (isLeafType(nullableType)) {\n        return transformer(nullableType, value);\n    }\n    else if (isListType(nullableType)) {\n        return value.map(function (listMember) { return transformInputValue(nullableType.ofType, listMember, transformer); });\n    }\n    else if (isInputObjectType(nullableType)) {\n        var fields_1 = nullableType.getFields();\n        var newValue_1 = {};\n        Object.keys(value).forEach(function (key) {\n            newValue_1[key] = transformInputValue(fields_1[key].type, value[key], transformer);\n        });\n        return newValue_1;\n    }\n    // unreachable, no other possible return value\n}\nexport function serializeInputValue(type, value) {\n    return transformInputValue(type, value, function (t, v) { return t.serialize(v); });\n}\nexport function parseInputValue(type, value) {\n    return transformInputValue(type, value, function (t, v) { return t.parseValue(v); });\n}\nexport function parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, function (t, v) { return t.parseLiteral(v, {}); });\n}\n//# sourceMappingURL=transformInputValue.js.map","import { __assign, __read, __spread } from \"tslib\";\nimport { GraphQLObjectType, GraphQLSchema, isInterfaceType, isEnumType, isObjectType, isScalarType, isUnionType, isInputObjectType, GraphQLInputObjectType, GraphQLInterfaceType, isLeafType, isListType, isNonNullType, isNamedType, GraphQLList, GraphQLNonNull, GraphQLEnumType, Kind, } from 'graphql';\nimport { MapperKind, } from './Interfaces';\nimport { rewireTypes } from './rewire';\nimport { serializeInputValue, parseInputValue } from './transformInputValue';\nexport function mapSchema(schema, schemaMapper) {\n    if (schemaMapper === void 0) { schemaMapper = {}; }\n    var originalTypeMap = schema.getTypeMap();\n    var newTypeMap = mapDefaultValues(originalTypeMap, schema, serializeInputValue);\n    newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, function (type) { return isLeafType(type); });\n    newTypeMap = mapEnumValues(newTypeMap, schema, schemaMapper);\n    newTypeMap = mapDefaultValues(newTypeMap, schema, parseInputValue);\n    newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, function (type) { return !isLeafType(type); });\n    newTypeMap = mapFields(newTypeMap, schema, schemaMapper);\n    newTypeMap = mapArguments(newTypeMap, schema, schemaMapper);\n    var originalDirectives = schema.getDirectives();\n    var newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    var queryType = schema.getQueryType();\n    var mutationType = schema.getMutationType();\n    var subscriptionType = schema.getSubscriptionType();\n    var newQueryTypeName = queryType != null ? (newTypeMap[queryType.name] != null ? newTypeMap[queryType.name].name : undefined) : undefined;\n    var newMutationTypeName = mutationType != null\n        ? newTypeMap[mutationType.name] != null\n            ? newTypeMap[mutationType.name].name\n            : undefined\n        : undefined;\n    var newSubscriptionTypeName = subscriptionType != null\n        ? newTypeMap[subscriptionType.name] != null\n            ? newTypeMap[subscriptionType.name].name\n            : undefined\n        : undefined;\n    var _a = rewireTypes(newTypeMap, newDirectives), typeMap = _a.typeMap, directives = _a.directives;\n    return new GraphQLSchema(__assign(__assign({}, schema.toConfig()), { query: newQueryTypeName ? typeMap[newQueryTypeName] : undefined, mutation: newMutationTypeName ? typeMap[newMutationTypeName] : undefined, subscription: newSubscriptionTypeName != null ? typeMap[newSubscriptionTypeName] : undefined, types: Object.keys(typeMap).map(function (typeName) { return typeMap[typeName]; }), directives: directives }));\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn) {\n    if (testFn === void 0) { testFn = function () { return true; }; }\n    var newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        if (!typeName.startsWith('__')) {\n            var originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    });\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    var _a;\n    var enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, (_a = {},\n        _a[MapperKind.ENUM_TYPE] = function (type) {\n            var config = type.toConfig();\n            var originalEnumValueConfigMap = config.values;\n            var newEnumValueConfigMap = {};\n            Object.keys(originalEnumValueConfigMap).forEach(function (externalValue) {\n                var originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                var mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    var _a = __read(mappedEnumValue, 2), newExternalValue = _a[0], newEnumValueConfig = _a[1];\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            });\n            return correctASTNodes(new GraphQLEnumType(__assign(__assign({}, config), { values: newEnumValueConfigMap })));\n        },\n        _a), function (type) { return isEnumType(type); });\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    var _a, _b;\n    var newTypeMap = mapArguments(originalTypeMap, schema, (_a = {},\n        _a[MapperKind.ARGUMENT] = function (argumentConfig) {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            var maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return __assign(__assign({}, argumentConfig), { defaultValue: fn(maybeNewType, argumentConfig.defaultValue) });\n            }\n        },\n        _a));\n    return mapFields(newTypeMap, schema, (_b = {},\n        _b[MapperKind.INPUT_OBJECT_FIELD] = function (inputFieldConfig) {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            var maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return __assign(__assign({}, inputFieldConfig), { defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue) });\n            }\n        },\n        _b));\n}\nfunction getNewType(newTypeMap, type) {\n    if (isListType(type)) {\n        var newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLList(newType) : null;\n    }\n    else if (isNonNullType(type)) {\n        var newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLNonNull(newType) : null;\n    }\n    else if (isNamedType(type)) {\n        var newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    var newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        if (!typeName.startsWith('__')) {\n            var originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var fieldMapper_1 = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper_1 == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var config = originalType.toConfig();\n            var originalFieldConfigMap_1 = config.fields;\n            var newFieldConfigMap_1 = {};\n            Object.keys(originalFieldConfigMap_1).forEach(function (fieldName) {\n                var originalFieldConfig = originalFieldConfigMap_1[fieldName];\n                var mappedField = fieldMapper_1(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap_1[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    var _a = __read(mappedField, 2), newFieldName = _a[0], newFieldConfig = _a[1];\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = __assign(__assign({}, newFieldConfig.astNode), { name: __assign(__assign({}, newFieldConfig.astNode.name), { value: newFieldName }) });\n                    }\n                    newFieldConfigMap_1[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap_1[fieldName] = mappedField;\n                }\n            });\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_1 })));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType(__assign(__assign({}, config), { fields: newFieldConfigMap_1 })));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_1 })));\n            }\n        }\n    });\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    var newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(function (typeName) {\n        if (!typeName.startsWith('__')) {\n            var originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var argumentMapper_1 = getArgumentMapper(schemaMapper);\n            if (argumentMapper_1 == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            var config = originalType.toConfig();\n            var originalFieldConfigMap_2 = config.fields;\n            var newFieldConfigMap_2 = {};\n            Object.keys(originalFieldConfigMap_2).forEach(function (fieldName) {\n                var originalFieldConfig = originalFieldConfigMap_2[fieldName];\n                var originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap_2[fieldName] = originalFieldConfig;\n                    return;\n                }\n                var argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap_2[fieldName] = originalFieldConfig;\n                    return;\n                }\n                var newArgumentConfigMap = {};\n                argumentNames.forEach(function (argumentName) {\n                    var originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    var mappedArgument = argumentMapper_1(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        var _a = __read(mappedArgument, 2), newArgumentName = _a[0], newArgumentConfig = _a[1];\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                });\n                newFieldConfigMap_2[fieldName] = __assign(__assign({}, originalFieldConfig), { args: newArgumentConfigMap });\n            });\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = new GraphQLObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_2 }));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new GraphQLInterfaceType(__assign(__assign({}, config), { fields: newFieldConfigMap_2 }));\n            }\n            else {\n                newTypeMap[typeName] = new GraphQLInputObjectType(__assign(__assign({}, config), { fields: newFieldConfigMap_2 }));\n            }\n        }\n    });\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    var directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    var newDirectives = [];\n    originalDirectives.forEach(function (directive) {\n        var mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    });\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var type = schema.getType(typeName);\n    var specifiers = [MapperKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n        var query = schema.getQueryType();\n        var mutation = schema.getMutationType();\n        var subscription = schema.getSubscriptionType();\n        if (query != null && typeName === query.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n        }\n        else if (mutation != null && typeName === mutation.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n        }\n        else if (subscription != null && typeName === subscription.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(MapperKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    var specifiers = getTypeSpecifiers(schema, typeName);\n    var typeMapper;\n    var stack = __spread(specifiers);\n    while (!typeMapper && stack.length > 0) {\n        var next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var type = schema.getType(typeName);\n    var specifiers = [MapperKind.FIELD];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n        var query = schema.getQueryType();\n        var mutation = schema.getMutationType();\n        var subscription = schema.getSubscriptionType();\n        if (query != null && typeName === query.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (mutation != null && typeName === mutation.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (subscription != null && typeName === subscription.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    var specifiers = getFieldSpecifiers(schema, typeName);\n    var fieldMapper;\n    var stack = __spread(specifiers);\n    while (!fieldMapper && stack.length > 0) {\n        var next = stack.pop();\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper != null ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    var argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    var enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nexport function correctASTNodes(type) {\n    if (isObjectType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var fields_1 = [];\n            Object.values(config.fields).forEach(function (fieldConfig) {\n                if (fieldConfig.astNode != null) {\n                    fields_1.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { kind: Kind.OBJECT_TYPE_DEFINITION, fields: fields_1 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { kind: Kind.OBJECT_TYPE_EXTENSION, fields: undefined })); });\n        }\n        return new GraphQLObjectType(config);\n    }\n    else if (isInterfaceType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var fields_2 = [];\n            Object.values(config.fields).forEach(function (fieldConfig) {\n                if (fieldConfig.astNode != null) {\n                    fields_2.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { kind: Kind.INTERFACE_TYPE_DEFINITION, fields: fields_2 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { kind: Kind.INTERFACE_TYPE_EXTENSION, fields: undefined })); });\n        }\n        return new GraphQLInterfaceType(config);\n    }\n    else if (isInputObjectType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var fields_3 = [];\n            Object.values(config.fields).forEach(function (fieldConfig) {\n                if (fieldConfig.astNode != null) {\n                    fields_3.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = __assign(__assign({}, config.astNode), { kind: Kind.INPUT_OBJECT_TYPE_DEFINITION, fields: fields_3 });\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(function (node) { return (__assign(__assign({}, node), { kind: Kind.INPUT_OBJECT_TYPE_EXTENSION, fields: undefined })); });\n        }\n        return new GraphQLInputObjectType(config);\n    }\n    else if (isEnumType(type)) {\n        var config = type.toConfig();\n        if (config.astNode != null) {\n            var values_1 = [];\n            Object.values(config.values).forEach(function (enumValueConfig) {\n                i