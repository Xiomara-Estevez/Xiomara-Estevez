#!/usr/bin/env node
/**
 * Relay v12.0.0
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 52);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/interopRequireDefault");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _require = __webpack_require__(8),
    GraphQLError = _require.GraphQLError;

/**
 * Creates an error describing invalid application code (GraphQL/Schema)
 * that must be fixed by the end developer. This should only be used
 * for local errors that don't affect processing of other user code.
 */
function createUserError(message, locations, nodes) {
  var messageWithLocations = message;

  if (locations != null) {
    var printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === 0 ? message : [message].concat(printedLocations).join('\n\n') + '\n';
  }

  return new GraphQLError(messageWithLocations, nodes !== null && nodes !== void 0 ? nodes : []);
}
/**
 * Similar to createUserError but for errors that are *not* recoverable:
 * the compiler should not continue to process other inputs because their
 * validity can't be determined.
 */


function createNonRecoverableUserError(message, locations, nodes) {
  var messageWithLocations = message;

  if (locations != null) {
    var printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === 0 ? message : [message].concat(printedLocations).join('\n\n') + '\n';
  }

  var error = new GraphQLError(messageWithLocations, nodes !== null && nodes !== void 0 ? nodes : []);
  return new Error(error.message);
}
/**
 * Creates an error describing a problem with the compiler itself - such
 * as a broken invariant - that must be fixed within the compiler.
 */


function createCompilerError(message, locations, nodes) {
  var messageWithLocations = message;

  if (locations != null) {
    var printedLocations = printLocations(locations);
    messageWithLocations = printedLocations.length === 0 ? message : [message].concat(printedLocations).join('\n\n') + '\n';
  }

  var error = new GraphQLError("Internal Error: ".concat(messageWithLocations), nodes !== null && nodes !== void 0 ? nodes : []);
  return new Error(error.message);
}
/**
 * Iterates over the elements of some iterable value, calling the
 * supplied callback for each item with a guard for user errors.
 *
 * Non-user errors abort the iteration and are instantly rethrown.
 * User errors are collected and rethrown at the end, if multiple user errors
 * occur, a combined error is thrown.
 */


function eachWithCombinedError(iterable, fn) {
  var errors = [];

  var _iterator = (0, _createForOfIteratorHelper2["default"])(iterable),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;

      try {
        fn(item);
      } catch (error) {
        if (error instanceof GraphQLError) {
          errors.push(error);
        } else {
          throw error;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (errors.length > 0) {
    if (errors.length === 1) {
      throw createUserError(String(errors[0]).split('\n').map(function (line, index) {
        return index === 0 ? "- ".concat(line) : "  ".concat(line);
      }).join('\n'));
    }

    throw createUserError("Encountered ".concat(errors.length, " errors:\n") + errors.map(function (error) {
      return String(error).split('\n').map(function (line, index) {
        return index === 0 ? "- ".concat(line) : "  ".concat(line);
      }).join('\n');
    }).join('\n'));
  }
}

function printLocations(locations) {
  var printedLocations = [];

  var _iterator2 = (0, _createForOfIteratorHelper2["default"])(locations),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var location = _step2.value;
      var sourceLocation = location;

      while (sourceLocation.kind === 'Derived') {
        sourceLocation = sourceLocation.source;
      }

      switch (sourceLocation.kind) {
        case 'Source':
          {
            // source location
            var prefix = sourceLocation === location ? 'Source: ' : 'Source (derived): ';
            printedLocations.push(prefix + highlightSourceAtLocation(sourceLocation.source, getLocation(sourceLocation.source, sourceLocation.start)));
            break;
          }

        case 'Generated':
          {
            printedLocations.push('Source: (generated)');
            break;
          }

        case 'Unknown':
          {
            printedLocations.push('Source: (unknown)');
            break;
          }

        default:
          {
            sourceLocation;
            throw createCompilerError("CompilerError: cannot print location '".concat(String(sourceLocation), "'."));
          }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return printedLocations;
}
/**
 * Render a helpful description of the location of the error in the GraphQL
 * Source document.
 */


function highlightSourceAtLocation(source, location) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = location.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = location.line + lineOffset;
  var columnOffset = location.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = location.column + columnOffset;
  var lines = body.split(/\r\n|[\n\r]/g);
  return "".concat(source.name, " (").concat(lineNum, ":").concat(columnNum, ")\n") + printPrefixedLines([// Lines specified like this: ["prefix", "string"],
  ["".concat(lineNum - 1, ": "), lines[lineIndex - 1]], ["".concat(lineNum, ": "), lines[lineIndex]], ['', whitespace(columnNum - 1) + '^'], ["".concat(lineNum + 1, ": "), lines[lineIndex + 1]]]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter(function (_ref) {
    var _ = _ref[0],
        line = _ref[1];
    return line !== undefined;
  });
  var padLen = 0;

  var _iterator3 = (0, _createForOfIteratorHelper2["default"])(existingLines),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          prefix = _step3$value[0];
      padLen = Math.max(padLen, prefix.length);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return existingLines.map(function (_ref2) {
    var prefix = _ref2[0],
        line = _ref2[1];
    return lpad(padLen, prefix) + line;
  }).join('\n');
}

function whitespace(len) {
  return Array(len + 1).join(' ');
}

function lpad(len, str) {
  return whitespace(len - str.length) + str;
}

function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;

  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }

  return {
    line: line,
    column: column
  };
}

module.exports = {
  createCompilerError: createCompilerError,
  createNonRecoverableUserError: createNonRecoverableUserError,
  createUserError: createUserError,
  eachWithCombinedError: eachWithCombinedError
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/objectSpread2");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var invariant = __webpack_require__(6);

var _require = __webpack_require__(1),
    eachWithCombinedError = _require.eachWithCombinedError;

/**
 * @public
 *
 * Helper for writing compiler transforms that apply "map" and/or "filter"-style
 * operations to compiler contexts. The `visitor` argument accepts a map of IR
 * kinds to user-defined functions that can map nodes of that kind to new values
 * (of the same kind).
 *
 * If a visitor function is defined for a kind, the visitor function is
 * responsible for traversing its children (by calling `this.traverse(node)`)
 * and returning either the input (to indicate no changes), a new node (to
 * indicate changes), or null/undefined (to indicate the removal of that node
 * from the output).
 *
 * If a visitor function is *not* defined for a kind, a default traversal is
 * used to evaluate its children.
 *
 * The `stateInitializer` argument accepts an optional function to construct the
 * state for each document (fragment or root) in the context. Any documents for
 * which the initializer returns null/undefined is deleted from the context
 * without being traversed.
 *
 * Example: Alias all scalar fields with the reverse of their name:
 *
 * ```
 * transform(context, {
 *   ScalarField: visitScalarField,
 * });
 *
 * function visitScalarField(field: ScalarField, state: State): ?ScalarField {
 *   // Traverse child nodes - for a scalar field these are the arguments &
 *   // directives.
 *   const nextField = this.traverse(field, state);
 *   // Return a new node with a different alias.
 *   return {
 *     ...nextField,
 *     alias: nextField.name.split('').reverse().join(''),
 *   };
 * }
 * ```
 */
function transform(context, visitor, stateInitializer) {
  var transformer = new Transformer(context, visitor);
  return context.withMutations(function (ctx) {
    var nextContext = ctx;
    eachWithCombinedError(context.documents(), function (prevNode) {
      var nextNode;

      if (stateInitializer === undefined) {
        nextNode = transformer.visit(prevNode, undefined);
      } else {
        var _state = stateInitializer(prevNode);

        if (_state != null) {
          nextNode = transformer.visit(prevNode, _state);
        }
      }

      if (!nextNode) {
        nextContext = nextContext.remove(prevNode.name);
      } else if (nextNode !== prevNode) {
        nextContext = nextContext.replace(nextNode);
      }
    });
    return nextContext;
  });
}
/**
 * @internal
 */


var Transformer = /*#__PURE__*/function () {
  function Transformer(context, visitor) {
    this._context = context;
    this._states = [];
    this._visitor = visitor;
  }
  /**
   * @public
   *
   * Returns the original compiler context that is being transformed. This can
   * be used to look up fragments by name, for example.
   */


  var _proto = Transformer.prototype;

  _proto.getContext = function getContext() {
    return this._context;
  }
  /**
   * @public
   *
   * Transforms the node, calling a user-defined visitor function if defined for
   * the node's kind. Uses the given state for this portion of the traversal.
   *
   * Note: This differs from `traverse` in that it calls a visitor function for
   * the node itself.
   */
  ;

  _proto.visit = function visit(node, state) {
    this._states.push(state);

    var nextNode = this._visit(node);

    this._states.pop();

    return nextNode;
  }
  /**
   * @public
   *
   * Transforms the children of the given node, skipping the user-defined
   * visitor function for the node itself. Uses the given state for this portion
   * of the traversal.
   *
   * Note: This differs from `visit` in that it does not call a visitor function
   * for the node itself.
   */
  ;

  _proto.traverse = function traverse(node, state) {
    this._states.push(state);

    var nextNode = this._traverse(node);

    this._states.pop();

    return nextNode;
  };

  _proto._visit = function _visit(node) {
    var nodeVisitor = this._visitor[node.kind];

    if (nodeVisitor) {
      // If a handler for the kind is defined, it is responsible for calling
      // `traverse` to transform children as necessary.
      var _state2 = this._getState();

      var nextNode = nodeVisitor.call(this, node, _state2);
      return nextNode;
    } // Otherwise traverse is called automatically.


    return this._traverse(node);
  };

  _proto._traverse = function _traverse(prevNode) {
    var nextNode;

    switch (prevNode.kind) {
      case 'Argument':
        nextNode = this._traverseChildren(prevNode, null, ['value']);
        break;

      case 'Literal':
      case 'LocalArgumentDefinition':
      case 'RootArgumentDefinition':
      case 'Variable':
        nextNode = prevNode;
        break;

      case 'Defer':
        nextNode = this._traverseChildren(prevNode, ['selections'], ['if']);
        break;

      case 'Stream':
        nextNode = this._traverseChildren(prevNode, ['selections'], ['if', 'initialCount']);
        break;

      case 'ClientExtension':
        nextNode = this._traverseChildren(prevNode, ['selections']);
        break;

      case 'Directive':
        nextNode = this._traverseChildren(prevNode, ['args']);
        break;

      case 'ModuleImport':
        nextNode = this._traverseChildren(prevNode, ['selections']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'FragmentSpread':
      case 'ScalarField':
        nextNode = this._traverseChildren(prevNode, ['args', 'directives']);
        break;

      case 'InlineDataFragmentSpread':
        nextNode = this._traverseChildren(prevNode, ['selections']);
        break;

      case 'LinkedField':
        nextNode = this._traverseChildren(prevNode, ['args', 'directives', 'selections']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'ListValue':
        nextNode = this._traverseChildren(prevNode, ['items']);
        break;

      case 'ObjectFieldValue':
        nextNode = this._traverseChildren(prevNode, null, ['value']);
        break;

      case 'ObjectValue':
        nextNode = this._traverseChildren(prevNode, ['fields']);
        break;

      case 'Condition':
        nextNode = this._traverseChildren(prevNode, ['directives', 'selections'], ['condition']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'InlineFragment':
        nextNode = this._traverseChildren(prevNode, ['directives', 'selections']);

        if (!nextNode.selections.length) {
          nextNode = null;
        }

        break;

      case 'Fragment':
      case 'Root':
        nextNode = this._traverseChildren(prevNode, ['argumentDefinitions', 'directives', 'selections']);
        break;

      case 'Request':
        nextNode = this._traverseChildren(prevNode, null, ['fragment', 'root']);
        break;

      case 'SplitOperation':
        nextNode = this._traverseChildren(prevNode, ['selections']);
        break;

      default:
        prevNode;
         true ?  true ? invariant(false, 'IRTransformer: Unknown kind `%s`.', prevNode.kind) : undefined : undefined;
    }

    return nextNode;
  };

  _proto._traverseChildren = function _traverseChildren(prevNode, pluralKeys, singularKeys) {
    var _this = this;

    var nextNode;
    pluralKeys && pluralKeys.forEach(function (key) {
      var prevItems = prevNode[key];

      if (!prevItems) {
        return;
      }

      !Array.isArray(prevItems) ?  true ? invariant(false, 'IRTransformer: Expected data for `%s` to be an array, got `%s`.', key, prevItems) : undefined : void 0;

      var nextItems = _this._map(prevItems);

      if (nextNode || nextItems !== prevItems) {
        nextNode = nextNode || (0, _objectSpread2["default"])({}, prevNode);
        nextNode[key] = nextItems;
      }
    });
    singularKeys && singularKeys.forEach(function (key) {
      var prevItem = prevNode[key];

      if (!prevItem) {
        return;
      }

      var nextItem = _this._visit(prevItem);

      if (nextNode || nextItem !== prevItem) {
        nextNode = nextNode || (0, _objectSpread2["default"])({}, prevNode);
        nextNode[key] = nextItem;
      }
    });
    return nextNode || prevNode;
  };

  _proto._map = function _map(prevItems) {
    var _this2 = this;

    var nextItems;
    prevItems.forEach(function (prevItem, index) {
      var nextItem = _this2._visit(prevItem);

      if (nextItems || nextItem !== prevItem) {
        nextItems = nextItems || prevItems.slice(0, index);

        if (nextItem) {
          nextItems.push(nextItem);
        }
      }
    });
    return nextItems || prevItems;
  };

  _proto._getState = function _getState() {
    !this._states.length ?  true ? invariant(false, 'IRTransformer: Expected a current state to be set but found none. ' + 'This is usually the result of mismatched number of pushState()/popState() ' + 'calls.') : undefined : void 0;
    return this._states[this._states.length - 1];
  };

  return Transformer;
}();

module.exports = {
  transform: transform
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createForOfIteratorHelper");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("invariant");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _asyncToGenerator = __webpack_require__(12);

var invariant = __webpack_require__(6);
/**
 * The compiler profiler builds a "call graph" of high level operations as a
 * means of tracking time spent over the course of running the compiler.
 */


var enabled = false;
var traces = [{
  ph: 'M',
  pid: 0,
  tid: 0,
  name: 'process_name',
  args: {
    name: 'relay-compiler'
  }
}, {
  ph: 'M',
  pid: 0,
  tid: 0,
  name: 'thread_name',
  args: {
    name: 'relay-compiler'
  }
}];
var stack = [];

function enable() {
  enabled = true;
}

function getTraces() {
  return traces;
}
/**
 * Run the provided function as part of a stack profile.
 */


function run(name, fn) {
  return instrument(fn, name)();
}
/**
 * Run the provided async function as part context in a stack profile.
 * See instrumentAsyncContext() for limitations and usage notes.
 */


function asyncContext(name, fn) {
  return instrumentAsyncContext(fn, name)();
}
/**
 * Wait for the provided async operation as an async profile.
 */


function waitFor(name, fn) {
  return instrumentWait(fn, name)();
}
/**
 * Return a new instrumented sync function to be part of a stack profile.
 *
 * This instruments synchronous functions to be displayed in a stack
 * visualization. To instrument async functions, see instrumentAsyncContext()
 * and instrumentWait().
 */


function instrument(fn, name) {
  var _ref;

  if (!enabled) {
    return fn;
  }

  var profileName = (_ref = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any
  fn.displayName) !== null && _ref !== void 0 ? _ref : fn.name;

  var instrumented = function instrumented() {
    var traceId = start(profileName);

    try {
      return fn.apply(this, arguments);
    } finally {
      end(traceId);
    }
  };

  instrumented.displayName = profileName;
  return instrumented;
}
/**
 * Return a new instrumented async function which provides context for a stack.
 *
 * Because the resulting profiling information will be incorporated into a
 * stack visualization, the instrumented function must represent a distinct
 * region of time which does not overlap with any other async context.
 *
 * In other words, functions instrumented with instrumentAsyncContext must not
 * run in parallel via Promise.all().
 *
 * To instrument functions which will run in parallel, use instrumentWait().
 */


function instrumentAsyncContext(fn, name) {
  var _ref2;

  if (!enabled) {
    return fn;
  }

  var profileName = (_ref2 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any
  fn.displayName) !== null && _ref2 !== void 0 ? _ref2 : fn.name;

  var instrumented = /*#__PURE__*/function () {
    var _instrumented = _asyncToGenerator(function* () {
      var traceId = start(profileName);

      try {
        return yield fn.apply(this, arguments);
      } finally {
        end(traceId);
      }
    });

    function instrumented() {
      return _instrumented.apply(this, arguments);
    }

    return instrumented;
  }();

  instrumented.displayName = profileName;
  return instrumented;
}
/**
 * Return a new instrumented function which performs an awaited async operation.
 *
 * The instrumented function is not included in the overall run time of the
 * compiler, instead it captures the time waiting on some asynchronous external
 * resource such as network or filesystem which are often run in parallel.
 */


function instrumentWait(fn, name) {
  var _ref3;

  if (!enabled) {
    return fn;
  }

  var profileName = (_ref3 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any
  fn.displayName) !== null && _ref3 !== void 0 ? _ref3 : fn.name;

  var instrumented = /*#__PURE__*/function () {
    var _instrumented2 = _asyncToGenerator(function* () {
      var traceId = startWait(profileName);

      try {
        return yield fn.apply(this, arguments);
      } finally {
        end(traceId);
      }
    });

    function instrumented() {
      return _instrumented2.apply(this, arguments);
    }

    return instrumented;
  }();

  instrumented.displayName = profileName;
  return instrumented;
}

var T_ZERO = process.hrtime(); // Return a Uint32 of microtime duration since program start.

function microtime() {
  var hrtime = process.hrtime(T_ZERO); // eslint-disable-next-line no-bitwise

  return 0 | hrtime[0] * 1e6 + Math.round(hrtime[1] / 1e3);
}
/**
 * Start a stack profile with a particular name, returns an ID to pass to end().
 *
 * Other profiles may start before this one ends, which will be represented as
 * nested operations, however all nested operations must end before this ends.
 *
 * In particular, be careful to end after errors.
 */


function start(name) {
  var beginTrace = {
    ph: 'B',
    name: name,
    pid: 0,
    tid: 0,
    ts: microtime()
  };
  traces.push(beginTrace);
  stack.push(beginTrace);
  return traces.length - 1;
}

var asyncID = 0;
/**
 * Start an async wait profile with a particular name, returns an ID to pass
 * to end().
 *
 * Other profiles may start before this one ends, which will be represented as
 * nested operations, however all nested operations must end before this ends.
 *
 * In particular, be careful to end after errors.
 */

function startWait(name) {
  traces.push({
    ph: 'b',
    name: name,
    cat: 'wait',
    id: asyncID++,
    pid: 0,
    tid: 0,
    ts: microtime()
  });
  return traces.length - 1;
}

function end(traceIdx) {
  var trace = traces[traceIdx];

  if (trace.ph === 'b') {
    traces.push({
      ph: 'e',
      cat: trace.cat,
      name: trace.name,
      id: trace.id,
      pid: trace.pid,
      tid: trace.tid,
      ts: microtime()
    });
    return;
  }

  !(trace.ph === 'B') ?  true ? invariant(false, 'Begin trace phase') : undefined : void 0;
  !(stack.pop() === trace) ?  true ? invariant(false, 'GraphQLCompilerProfiler: The profile trace %s ended before nested traces. ' + 'If it is async, try using Profile.waitFor or Profile.profileWait.', trace.name) : undefined : void 0;
  var prevTrace = traces[traces.length - 1];

  if (trace === prevTrace) {
    traces[traceIdx] = {
      ph: 'X',
      name: trace.name,
      pid: trace.pid,
      tid: trace.tid,
      ts: trace.ts,
      dur: microtime() - trace.ts
    };
    return;
  }

  traces.push({
    ph: 'E',
    name: trace.name,
    pid: trace.pid,
    tid: trace.tid,
    ts: microtime()
  });
}

module.exports = {
  enable: enable,
  getTraces: getTraces,
  run: run,
  asyncContext: asyncContext,
  waitFor: waitFor,
  instrument: instrument,
  instrumentAsyncContext: instrumentAsyncContext,
  instrumentWait: instrumentWait,
  start: start,
  startWait: startWait,
  end: end
};

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("graphql");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

var ID = 'id';
/**
 * @public
 *
 * Determine if an AST node contains a fragment/operation definition.
 */

function isExecutableDefinitionAST(ast) {
  return ast.kind === 'FragmentDefinition' || ast.kind === 'OperationDefinition';
}
/**
 * @public
 *
 * Determine if an AST node contains a schema definition.
 */


function isSchemaDefinitionAST(ast) {
  return ast.kind === 'SchemaDefinition' || ast.kind === 'ScalarTypeDefinition' || ast.kind === 'ObjectTypeDefinition' || ast.kind === 'InterfaceTypeDefinition' || ast.kind === 'UnionTypeDefinition' || ast.kind === 'EnumTypeDefinition' || ast.kind === 'InputObjectTypeDefinition' || ast.kind === 'DirectiveDefinition' || ast.kind === 'ScalarTypeExtension' || ast.kind === 'ObjectTypeExtension' || ast.kind === 'InterfaceTypeExtension' || ast.kind === 'UnionTypeExtension' || ast.kind === 'EnumTypeExtension' || ast.kind === 'InputObjectTypeExtension';
}
/**
 * Generates an id field on the given type.
 */


function generateIDField(schema, type) {
  var idField = schema.getFieldByName(type, 'id');

  if (idField == null) {
    throw new createCompilerError("Expected an 'id' field on type '".concat(schema.getTypeString(type), "'."));
  }

  var idType = schema.assertScalarFieldType(schema.getFieldType(idField));
  return {
    kind: 'ScalarField',
    alias: ID,
    args: [],
    directives: [],
    handles: null,
    loc: {
      kind: 'Generated'
    },
    metadata: null,
    name: ID,
    type: idType
  };
}

function getNullableBooleanInput(schema) {
  return schema.assertInputType(schema.expectBooleanType());
}

function getNonNullBooleanInput(schema) {
  return schema.assertInputType(schema.getNonNullType(schema.expectBooleanType()));
}

function getNullableStringInput(schema) {
  return schema.assertInputType(schema.expectStringType());
}

function getNonNullStringInput(schema) {
  return schema.assertInputType(schema.getNonNullType(schema.expectStringType()));
}

function getNullableIdInput(schema) {
  return schema.assertInputType(schema.expectIdType());
}

function getNonNullIdInput(schema) {
  return schema.assertInputType(schema.getNonNullType(schema.expectIdType()));
}

module.exports = {
  generateIDField: generateIDField,
  isExecutableDefinitionAST: isExecutableDefinitionAST,
  isSchemaDefinitionAST: isSchemaDefinitionAST,
  getNullableBooleanInput: getNullableBooleanInput,
  getNonNullBooleanInput: getNonNullBooleanInput,
  getNullableStringInput: getNullableStringInput,
  getNonNullStringInput: getNonNullStringInput,
  getNullableIdInput: getNullableIdInput,
  getNonNullIdInput: getNonNullIdInput
};

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("relay-runtime");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/asyncToGenerator");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("immutable");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error

/**
 * Partitions an array given a predicate. All elements satisfying the predicate
 * are part of the first returned array, and all elements that don't are in the
 * second.
 */

function partitionArray(array, predicate) {
  var first = [];
  var second = [];

  for (var i = 0; i < array.length; i++) {
    var item = array[i];

    if (predicate(item)) {
      first.push(item);
    } else {
      second.push(item);
    }
  }

  return [first, second];
}

module.exports = partitionArray;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("nullthrows");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

function generateAbstractTypeRefinementKey(schema, type) {
  if (!schema.isAbstractType(type)) {
    throw createCompilerError('Expected an abstract type');
  }

  return "__is".concat(schema.getTypeString(type));
}

module.exports = generateAbstractTypeRefinementKey;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _require = __webpack_require__(8),
    visit = _require.visit;

var NodeKeys = {
  Argument: ['value'],
  ClientExtension: ['selections'],
  Condition: ['condition', 'selections'],
  Defer: ['selections', 'if'],
  Directive: ['args'],
  Fragment: ['argumentDefinitions', 'directives', 'selections'],
  FragmentSpread: ['args', 'directives'],
  InlineDataFragmentSpread: ['selections'],
  InlineFragment: ['directives', 'selections'],
  LinkedField: ['args', 'directives', 'selections'],
  Literal: [],
  LocalArgumentDefinition: [],
  ModuleImport: ['selections'],
  Request: ['fragment', 'root'],
  Root: ['argumentDefinitions', 'directives', 'selections'],
  RootArgumentDefinition: [],
  ScalarField: ['args', 'directives'],
  SplitOperation: ['selections'],
  Stream: ['selections', 'if', 'initialCount'],
  Variable: []
};

function visitIR(root, visitor) {
  return visit(root, visitor, NodeKeys);
}

module.exports = {
  visit: visitIR
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


// Copy of Variables type from '../../../react-relay/classic/tools/RelayTypes'
// Duplicating here rather than importing it since we can't take on a dependency
// outside of relay-compiler.
function getLiteralArgumentValues(args) {
  var values = {};
  args.forEach(function (arg) {
    if (arg.value.kind === 'Literal') {
      values[arg.name] = arg.value.value;
    }
  });
  return values;
}

module.exports = getLiteralArgumentValues;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var CompilerContext = __webpack_require__(24);

var IRVisitor = __webpack_require__(19);

var SchemaUtils = __webpack_require__(10);

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

/**
 * Returns a transformed version of the input context where each document's
 * argument definitions are updated to accurately describe the root variables
 * used (or reachable) from that document:
 * - Fragment argument definitions are updated to include local argument
 *   definitions and any root variables that are referenced
 *   by the fragment (or any fragments it transitively spreads).
 * - Root argument definitions are updated to reflect the variables
 *   referenced locally and all root variables referenced by any
 *   fragments it (transitively) spreads.
 */
function inferRootArgumentDefinitions(context) {
  // This transform does two main tasks:
  // - Determine the set of root variables referenced locally in each
  //   fragment. Note that RootArgumentDefinitions in the fragment's
  //   argumentDefinitions can contain spurious entries for legacy
  //   reasons. Instead of using those the fragment is traversed
  //   to reanalyze variable usage.
  // - Determine the set of root variables that are transitively referenced
  //   by each fragment, ie the union of all root variables used in the
  //   fragment and any fragments it transitively spreads.
  // Cache fragments as they are transformed to avoid duplicate processing.
  // Because @argument values don't matter (only variable names/types),
  // each reachable fragment only has to be checked once.
  var transformed = new Map();
  var nextContext = new CompilerContext(context.getSchema());
  return nextContext.addAll(Array.from(context.documents(), function (node) {
    switch (node.kind) {
      case 'Fragment':
        {
          var argumentDefinitions = transformFragmentArguments(context, transformed, node);
          return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
            argumentDefinitions: Array.from(argumentDefinitions.values())
          });
        }

      case 'Root':
        {
          return transformRoot(context, transformed, node);
        }

      case 'SplitOperation':
        {
          return node;
        }

      default:
        {
          node;
          throw createCompilerError("inferRootArgumentDefinitions: Unsupported kind '".concat(node.kind, "'."));
        }
    }
  }));
}

function transformRoot(context, transformed, root) {
  // Ignore argument definitions, determine what root variables are
  // transitively referenced
  var argumentDefinitions = new Map();
  var localArgumentDefinitions = new Map();

  var _iterator = (0, _createForOfIteratorHelper2["default"])(root.argumentDefinitions.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _step.value,
          name = _step$value[0],
          argDef = _step$value[1];

      if (argDef.kind === 'LocalArgumentDefinition') {
        localArgumentDefinitions.set(name, argDef);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  visit(context, transformed, argumentDefinitions, root);
  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, root), {}, {
    argumentDefinitions: Array.from(argumentDefinitions.values(), function (argDef) {
      var _localDefinition$type, _localDefinition$defa;

      if (argDef.kind !== 'RootArgumentDefinition') {
        throw createCompilerError("inferRootArgumentDefinitions: Expected inferred variable '$".concat(argDef.name, "' to be a root variables."), [argDef.loc]);
      }

      var localDefinition = localArgumentDefinitions.get(argDef.name);
      var type = (_localDefinition$type = localDefinition === null || localDefinition === void 0 ? void 0 : localDefinition.type) !== null && _localDefinition$type !== void 0 ? _localDefinition$type : argDef.type;
      return {
        defaultValue: (_localDefinition$defa = localDefinition === null || localDefinition === void 0 ? void 0 : localDefinition.defaultValue) !== null && _localDefinition$defa !== void 0 ? _localDefinition$defa : null,
        kind: 'LocalArgumentDefinition',
        loc: argDef.loc,
        name: argDef.name,
        type: type
      };
    })
  });
}

function transformFragmentArguments(context, transformed, fragment) {
  var name = fragment.name;
  var transformedArguments = transformed.get(name);

  if (transformedArguments != null) {
    return transformedArguments;
  } // Start with only the explicitly defined local arguments, recover the
  // correct set of root variables excluding invalid @arguments values.


  var argumentDefinitions = new Map();
  fragment.argumentDefinitions.forEach(function (argDef) {
    if (argDef.kind === 'LocalArgumentDefinition') {
      argumentDefinitions.set(argDef.name, argDef);
    }
  }); // Break cycles by initially caching a version that only has local
  // arguments. If the current fragment is reached again, it won't have
  // any root variables to add to its parents. The traversal below will
  // find any root variables and update the cached version of the
  // fragment.

  transformed.set(name, argumentDefinitions);
  visit(context, transformed, argumentDefinitions, fragment);
  transformed.set(name, argumentDefinitions);
  return argumentDefinitions;
}

function visit(context, transformed, argumentDefinitions, node) {
  IRVisitor.visit(node, {
    FragmentSpread: function FragmentSpread(fragmentSpread) {
      var fragment = context.getFragment(fragmentSpread.name, fragmentSpread.loc);
      var referencedFragmentArguments = transformFragmentArguments(context, transformed, fragment); // Detect root variables being passed as the value of @arguments;
      // recover the expected type from the corresponding argument definitions.

      fragmentSpread.args.forEach(function (arg) {
        var argDef = referencedFragmentArguments.get(arg.name);

        if (argDef != null && arg.value.kind === 'Variable' && !argumentDefinitions.has(arg.value.variableName)) {
          argumentDefinitions.set(arg.value.variableName, {
            kind: 'RootArgumentDefinition',
            loc: {
              kind: 'Derived',
              source: arg.loc
            },
            name: arg.value.variableName,
            type: argDef.type
          });
        }
      }); // Merge any root variables referenced by the spread fragment
      // into this (parent) fragment's arguments.

      var _iterator2 = (0, _createForOfIteratorHelper2["default"])(referencedFragmentArguments.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var argDef = _step2.value;

          if (argDef.kind === 'RootArgumentDefinition') {
            argumentDefinitions.set(argDef.name, argDef);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    },
    Argument: function Argument(argument) {
      if (argument.value.kind === 'Literal') {
        return false;
      }

      var values = [argument.value];

      while (values.length > 0) {
        var currentValue = values.pop();

        if (currentValue.kind === 'Variable') {
          var _currentValue$type;

          var type = (_currentValue$type = currentValue.type) !== null && _currentValue$type !== void 0 ? _currentValue$type : argument.type;

          if (type == null) {
            continue;
          }

          if (!argumentDefinitions.has(currentValue.variableName)) {
            // root variable
            argumentDefinitions.set(currentValue.variableName, {
              kind: 'RootArgumentDefinition',
              loc: {
                kind: 'Derived',
                source: argument.loc
              },
              name: currentValue.variableName,
              type: type
            });
          }
        } else if (currentValue.kind === 'ObjectValue') {
          currentValue.fields.forEach(function (fieldValue) {
            if (fieldValue.value.kind !== 'Literal') {
              values.push(fieldValue.value);
            }
          });
        } else if (currentValue.kind === 'ListValue') {
          currentValue.items.forEach(function (listValue) {
            if (listValue.kind !== 'Literal') {
              values.push(listValue);
            }
          });
        }
      }

      return false;
    },
    Condition: function Condition(condition) {
      var _variable$type;

      var variable = condition.condition;

      if (variable.kind !== 'Variable') {
        return;
      }

      var type = (_variable$type = variable.type) !== null && _variable$type !== void 0 ? _variable$type : SchemaUtils.getNonNullBooleanInput(context.getSchema());

      if (!argumentDefinitions.has(variable.variableName)) {
        // root variable
        argumentDefinitions.set(variable.variableName, {
          kind: 'RootArgumentDefinition',
          loc: {
            kind: 'Derived',
            source: variable.loc
          },
          name: variable.variableName,
          type: type
        });
      }
    },
    Defer: function Defer(defer) {
      var _variable$type2;

      var variable = defer["if"];

      if (variable == null || variable.kind !== 'Variable') {
        return;
      }

      var type = (_variable$type2 = variable.type) !== null && _variable$type2 !== void 0 ? _variable$type2 : SchemaUtils.getNonNullBooleanInput(context.getSchema());

      if (!argumentDefinitions.has(variable.variableName)) {
        // root variable
        argumentDefinitions.set(variable.variableName, {
          kind: 'RootArgumentDefinition',
          loc: {
            kind: 'Derived',
            source: variable.loc
          },
          name: variable.variableName,
          type: type
        });
      }
    },
    Stream: function Stream(stream) {
      [stream["if"], stream.initialCount].forEach(function (variable) {
        var _variable$type3;

        if (variable == null || variable.kind !== 'Variable') {
          return;
        }

        var type = (_variable$type3 = variable.type) !== null && _variable$type3 !== void 0 ? _variable$type3 : SchemaUtils.getNonNullBooleanInput(context.getSchema());

        if (!argumentDefinitions.has(variable.variableName)) {
          // root variable
          argumentDefinitions.set(variable.variableName, {
            kind: 'RootArgumentDefinition',
            loc: {
              kind: 'Derived',
              source: variable.loc
            },
            name: variable.variableName,
            type: type
          });
        }
      });
    },
    LinkedField: function LinkedField(field) {
      if (!field.handles) {
        return;
      }

      field.handles.forEach(function (handle) {
        var _variable$type4;

        var variable = handle.dynamicKey;

        if (variable == null) {
          return;
        }

        var type = (_variable$type4 = variable.type) !== null && _variable$type4 !== void 0 ? _variable$type4 : SchemaUtils.getNullableStringInput(context.getSchema());

        if (!argumentDefinitions.has(variable.variableName)) {
          // root variable
          argumentDefinitions.set(variable.variableName, {
            kind: 'RootArgumentDefinition',
            loc: {
              kind: 'Derived',
              source: variable.loc
            },
            name: variable.variableName,
            type: type
          });
        }
      });
    }
  });
}

module.exports = inferRootArgumentDefinitions;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

function buildFragmentSpread(fragment) {
  var args = [];

  var _iterator = (0, _createForOfIteratorHelper2["default"])(fragment.argumentDefinitions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var argDef = _step.value;

      if (argDef.kind !== 'LocalArgumentDefinition') {
        continue;
      }

      args.push({
        kind: 'Argument',
        loc: {
          kind: 'Derived',
          source: argDef.loc
        },
        name: argDef.name,
        type: argDef.type,
        value: {
          kind: 'Variable',
          loc: {
            kind: 'Derived',
            source: argDef.loc
          },
          variableName: argDef.name,
          type: argDef.type
        }
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return {
    args: args,
    directives: [],
    kind: 'FragmentSpread',
    loc: {
      kind: 'Derived',
      source: fragment.loc
    },
    metadata: null,
    name: fragment.name
  };
}

function buildOperationArgumentDefinitions(argumentDefinitions) {
  var localArgumentDefinitions = argumentDefinitions.map(function (argDef) {
    if (argDef.kind === 'LocalArgumentDefinition') {
      return argDef;
    } else {
      return {
        kind: 'LocalArgumentDefinition',
        name: argDef.name,
        type: argDef.type,
        defaultValue: null,
        loc: argDef.loc
      };
    }
  });
  localArgumentDefinitions.sort(function (a, b) {
    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
  });
  return localArgumentDefinitions;
}

module.exports = {
  buildFragmentSpread: buildFragmentSpread,
  buildOperationArgumentDefinitions: buildOperationArgumentDefinitions
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @emails oncall+relay
 */
// flowlint ambiguous-object-type:error


var _asyncToGenerator = __webpack_require__(12);

var childProcess = __webpack_require__(57);

var watchman = __webpack_require__(58);

var MAX_ATTEMPT_LIMIT = 5;

function delay(delayMs) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delayMs);
  });
}

var GraphQLWatchmanClient = /*#__PURE__*/function () {
  GraphQLWatchmanClient.isAvailable = function isAvailable() {
    return new Promise(function (resolve) {
      // This command not only will verify that watchman CLI is available
      // More than that `watchman version` is a command that runs on the server.
      // And it can tell us that watchman is up and running
      // Also `watchman version` check ``relative_root`` capability
      // under the covers
      var proc = childProcess.spawn('watchman', ['version']);
      proc.on('error', function () {
        resolve(false);
      });
      proc.on('close', function (code) {
        resolve(code === 0);
      });
    });
  };

  function GraphQLWatchmanClient() {
    var attemptLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    this._client = new watchman.Client();
    this._attemptLimit = Math.max(Math.min(MAX_ATTEMPT_LIMIT, attemptLimit), 0);
  }

  var _proto = GraphQLWatchmanClient.prototype;

  _proto._command = function _command() {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise(function (resolve, reject) {
      _this._client.command(args, function (error, response) {
        if (error) {
          reject(error);
        } else {
          resolve(response);
        }
      });
    });
  };

  _proto.command = /*#__PURE__*/function () {
    var _command2 = _asyncToGenerator(function* () {
      var attempt = 0;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      while (true) {
        try {
          attempt++;
          return yield this._command.apply(this, args);
        } catch (error) {
          if (attempt > this._attemptLimit) {
            throw error;
          }

          yield delay(Math.pow(2, attempt) * 500);

          this._client.end();

          this._client = new watchman.Client();
        }
      }
    });

    function command() {
      return _command2.apply(this, arguments);
    }

    return command;
  }();

  _proto.hasCapability = /*#__PURE__*/function () {
    var _hasCapability = _asyncToGenerator(function* (capability) {
      var resp = yield this.command('list-capabilities');
      return resp.capabilities.includes(capability);
    });

    function hasCapability(_x) {
      return _hasCapability.apply(this, arguments);
    }

    return hasCapability;
  }();

  _proto.watchProject = /*#__PURE__*/function () {
    var _watchProject = _asyncToGenerator(function* (baseDir) {
      var resp = yield this.command('watch-project', baseDir);

      if ('warning' in resp) {
        console.error('Warning:', resp.warning);
      }

      return {
        root: resp.watch,
        relativePath: resp.relative_path
      };
    });

    function watchProject(_x2) {
      return _watchProject.apply(this, arguments);
    }

    return watchProject;
  }();

  _proto.on = function on(event, callback) {
    this._client.on(event, callback);
  };

  _proto.end = function end() {
    this._client.end();
  };

  return GraphQLWatchmanClient;
}();

module.exports = GraphQLWatchmanClient;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var Profiler = __webpack_require__(7);

var invariant = __webpack_require__(6);

var _require = __webpack_require__(1),
    createUserError = _require.createUserError; // $FlowFixMe[untyped-import] - immutable.js is not flow-typed


var _require2 = __webpack_require__(15),
    ImmutableOrderedMap = _require2.OrderedMap;

/**
 * An immutable representation of a corpus of documents being compiled together.
 * For each document, the context stores the IR and any validation errors.
 */
var CompilerContext = /*#__PURE__*/function () {
  // $FlowFixMe[value-as-type]
  function CompilerContext(schema) {
    this._isMutable = false;
    this._documents = new ImmutableOrderedMap();
    this._withTransform = new WeakMap();
    this._schema = schema;
  }
  /**
   * Returns the documents for the context in the order they were added.
   */


  var _proto = CompilerContext.prototype;

  _proto.documents = function documents() {
    return this._documents.toArray();
  };

  _proto.forEachDocument = function forEachDocument(fn) {
    this._documents.forEach(fn);
  };

  _proto.replace = function replace(node) {
    return this._update(this._documents.update(node.name, function (existing) {
      !existing ?  true ? invariant(false, 'CompilerContext: Expected to replace existing node %s, but ' + 'one was not found in the context.', node.name) : undefined : void 0;
      return node;
    }));
  };

  _proto.add = function add(node) {
    return this._update(this._documents.update(node.name, function (existing) {
      !!existing ?  true ? invariant(false, 'CompilerContext: Duplicate document named `%s`. GraphQL ' + 'fragments and roots must have unique names.', node.name) : undefined : void 0;
      return node;
    }));
  };

  _proto.addAll = function addAll(nodes) {
    return this.withMutations(function (mutable) {
      return nodes.reduce(function (ctx, definition) {
        return ctx.add(definition);
      }, mutable);
    });
  }
  /**
   * Apply a list of compiler transforms and return a new compiler context.
   */
  ;

  _proto.applyTransforms = function applyTransforms(transforms, reporter) {
    var _this = this;

    return Profiler.run('applyTransforms', function () {
      return transforms.reduce(function (ctx, transform) {
        return ctx.applyTransform(transform, reporter);
      }, _this);
    });
  }
  /**
   * Applies a transform to this context, returning a new context.
   *
   * This is memoized such that applying the same sequence of transforms will
   * not result in duplicated work.
   */
  ;

  _proto.applyTransform = function applyTransform(transform, reporter) {
    var transformed = this._withTransform.get(transform);

    if (!transformed) {
      var start = process.hrtime();
      transformed = Profiler.instrument(transform)(this);
      var delta = process.hrtime(start);
      var deltaMs = Math.round((delta[0] * 1e9 + delta[1]) / 1e6);
      reporter && reporter.reportTime(transform.name, deltaMs);

      this._withTransform.set(transform, transformed);
    }

    return transformed;
  };

  _proto.get = function get(name) {
    return this._documents.get(name);
  };

  _proto.getFragment = function getFragment(name, referencedFrom) {
    var node = this._documents.get(name);

    if (node == null) {
      throw createUserError("Cannot find fragment '".concat(name, "'."), referencedFrom != null ? [referencedFrom] : null);
    } else if (node.kind !== 'Fragment') {
      throw createUserError("Cannot find fragment '".concat(name, "', a document with this name exists ") + 'but is not a fragment.', [node.loc, referencedFrom].filter(Boolean));
    }

    return node;
  };

  _proto.getRoot = function getRoot(name) {
    var node = this._documents.get(name);

    if (node == null) {
      throw createUserError("Cannot find root '".concat(name, "'."));
    } else if (node.kind !== 'Root') {
      throw createUserError("Cannot find root '".concat(name, "', a document with this name exists but ") + 'is not a root.', [node.loc]);
    }

    return node;
  };

  _proto.remove = function remove(name) {
    return this._update(this._documents["delete"](name));
  };

  _proto.withMutations = function withMutations(fn) {
    var mutableCopy = this._update(this._documents.asMutable());

    mutableCopy._isMutable = true;
    var result = fn(mutableCopy);
    result._isMutable = false;
    result._documents = result._documents.asImmutable();
    return this._documents === result._documents ? this : result;
  };

  _proto._update = function _update(documents) {
    var context = this._isMutable ? this : new CompilerContext(this.getSchema());
    context._documents = documents;
    return context;
  };

  _proto.getSchema = function getSchema() {
    return this._schema;
  };

  return CompilerContext;
}();

module.exports = CompilerContext;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


function md5(str) {
  return __webpack_require__(14).createHash('md5').update(str, 'utf8').digest('hex');
}

module.exports = md5;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = require("@babel/types");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _asyncToGenerator = __webpack_require__(12);

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var Profiler = __webpack_require__(7);

var crypto = __webpack_require__(14);

var invariant = __webpack_require__(6);

var path = __webpack_require__(9); // flowlint nonstrict-import:warn


var CodegenDirectory = /*#__PURE__*/function () {
  function CodegenDirectory(dir, options) {
    var _this = this;

    var _options$filesystem, _options$shards;

    this._filesystem = (_options$filesystem = options.filesystem) !== null && _options$filesystem !== void 0 ? _options$filesystem : __webpack_require__(13);
    this.onlyValidate = options.onlyValidate;
    this._shards = (_options$shards = options.shards) !== null && _options$shards !== void 0 ? _options$shards : 1;

    if (this._filesystem.existsSync(dir)) {
      !this._filesystem.statSync(dir).isDirectory() ?  true ? invariant(false, 'Expected `%s` to be a directory.', dir) : undefined : void 0;
    }

    if (!this.onlyValidate) {
      var dirs = [];
      var parent = dir;

      while (!this._filesystem.existsSync(parent)) {
        dirs.unshift(parent);
        parent = path.dirname(parent);
      }

      dirs.forEach(function (d) {
        return _this._filesystem.mkdirSync(d);
      });

      if (this._shards > 1) {
        for (var shard = 0; shard < this._shards; shard++) {
          var shardDir = path.join(dir, this._getShardName(shard));

          if (this._filesystem.existsSync(shardDir)) {
            !this._filesystem.statSync(dir).isDirectory() ?  true ? invariant(false, 'Expected `%s` to be a directory.', dir) : undefined : void 0;
          } else {
            this._filesystem.mkdirSync(shardDir);
          }
        }
      }
    }

    this._files = new Set();
    this.changes = {
      deleted: [],
      updated: [],
      created: [],
      unchanged: []
    };
    this._dir = dir;
  }

  CodegenDirectory.combineChanges = function combineChanges(dirs) {
    var changes = {
      deleted: [],
      updated: [],
      created: [],
      unchanged: []
    };
    dirs.forEach(function (dir) {
      var _changes$deleted, _changes$updated, _changes$created, _changes$unchanged;

      (_changes$deleted = changes.deleted).push.apply(_changes$deleted, (0, _toConsumableArray2["default"])(dir.changes.deleted));

      (_changes$updated = changes.updated).push.apply(_changes$updated, (0, _toConsumableArray2["default"])(dir.changes.updated));

      (_changes$created = changes.created).push.apply(_changes$created, (0, _toConsumableArray2["default"])(dir.changes.created));

      (_changes$unchanged = changes.unchanged).push.apply(_changes$unchanged, (0, _toConsumableArray2["default"])(dir.changes.unchanged));
    });
    return changes;
  };

  CodegenDirectory.hasChanges = function hasChanges(changes) {
    return changes.created.length > 0 || changes.updated.length > 0 || changes.deleted.length > 0;
  };

  CodegenDirectory.formatChanges = function formatChanges(changes, options) {
    var output = [];

    function formatFiles(label, files) {
      if (files.length > 0) {
        output.push(label + ':');
        files.forEach(function (file) {
          output.push(' - ' + file);
        });
      }
    }

    if (options.onlyValidate) {
      formatFiles('Missing', changes.created);
      formatFiles('Out of date', changes.updated);
      formatFiles('Extra', changes.deleted);
    } else {
      formatFiles('Created', changes.created);
      formatFiles('Updated', changes.updated);
      formatFiles('Deleted', changes.deleted);
      output.push("Unchanged: ".concat(changes.unchanged.length, " files"));
    }

    return output.join('\n');
  };

  CodegenDirectory.printChanges = function printChanges(changes, options) {
    Profiler.run('CodegenDirectory.printChanges', function () {
      var output = CodegenDirectory.formatChanges(changes, options); // eslint-disable-next-line no-console

      console.log(output);
    });
  };

  CodegenDirectory.getAddedRemovedFiles = function getAddedRemovedFiles(dirs) {
    var added = [];
    var removed = [];
    dirs.forEach(function (dir) {
      dir.changes.created.forEach(function (name) {
        added.push(dir.getPath(name));
      });
      dir.changes.deleted.forEach(function (name) {
        removed.push(dir.getPath(name));
      });
    });
    return {
      added: added,
      removed: removed
    };
  };

  CodegenDirectory.sourceControlAddRemove = /*#__PURE__*/function () {
    var _sourceControlAddRemove = _asyncToGenerator(function* (sourceControl, dirs) {
      var _CodegenDirectory$get = CodegenDirectory.getAddedRemovedFiles(dirs),
          added = _CodegenDirectory$get.added,
          removed = _CodegenDirectory$get.removed;

      sourceControl.addRemove(added, removed);
    });

    function sourceControlAddRemove(_x, _x2) {
      return _sourceControlAddRemove.apply(this, arguments);
    }

    return sourceControlAddRemove;
  }();

  var _proto = CodegenDirectory.prototype;

  _proto.printChanges = function printChanges() {
    CodegenDirectory.printChanges(this.changes, {
      onlyValidate: this.onlyValidate
    });
  };

  _proto.read = function read(filename) {
    var filePath = path.join(this._dir, filename);

    if (this._filesystem.existsSync(filePath)) {
      return this._filesystem.readFileSync(filePath, 'utf8');
    }

    return null;
  };

  _proto.markUnchanged = function markUnchanged(filename) {
    this._addGenerated(filename);

    this.changes.unchanged.push(filename);
  }
  /**
   * Marks a files as updated or out of date without actually writing the file.
   * This is probably only be useful when doing validation without intention to
   * actually write to disk.
   */
  ;

  _proto.markUpdated = function markUpdated(filename) {
    this._addGenerated(filename);

    this.changes.updated.push(filename);
  };

  _proto.writeFile = function writeFile(filename, content) {
    var _this2 = this;

    var shouldRepersist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    Profiler.run('CodegenDirectory.writeFile', function () {
      _this2._addGenerated(filename);

      var filePath = _this2.getPath(filename);

      if (_this2._filesystem.existsSync(filePath)) {
        var existingContent = _this2._filesystem.readFileSync(filePath, 'utf8');

        if (existingContent === content && !shouldRepersist) {
          _this2.changes.unchanged.push(filename);
        } else {
          _this2._writeFile(filePath, content);

          _this2.changes.updated.push(filename);
        }
      } else {
        _this2._writeFile(filePath, content);

        _this2.changes.created.push(filename);
      }
    });
  };

  _proto._writeFile = function _writeFile(filePath, content) {
    if (!this.onlyValidate) {
      this._filesystem.writeFileSync(filePath, content, 'utf8');
    }
  }
  /**
   * Deletes all non-generated files, except for invisible "dot" files (ie.
   * files with names starting with ".").
   */
  ;

  _proto.deleteExtraFiles = function deleteExtraFiles(keepExtraFile) {
    var _this3 = this;

    Profiler.run('CodegenDirectory.deleteExtraFiles', function () {
      if (_this3._shards > 1) {
        _this3._filesystem.readdirSync(_this3._dir).forEach(function (firstLevel) {
          if (firstLevel.startsWith('.')) {
            // allow hidden files on the first level of the codegen directory
            return;
          }

          var firstLevelPath = path.join(_this3._dir, firstLevel);

          if (!_this3._filesystem.statSync(firstLevelPath).isDirectory()) {
            // Delete all files on the top level, all files need to be in a
            // shard directory.
            _this3._filesystem.unlinkSync(firstLevelPath);

            return;
          }

          _this3._filesystem.readdirSync(firstLevelPath).forEach(function (actualFile) {
            if (keepExtraFile && keepExtraFile(actualFile)) {
              return;
            }

            if (_this3._files.has(actualFile)) {
              return;
            }

            if (!_this3.onlyValidate) {
              try {
                _this3._filesystem.unlinkSync(path.join(firstLevelPath, actualFile));
              } catch (_unused) {
                throw new Error('CodegenDirectory: Failed to delete `' + actualFile + '` in `' + _this3._dir + '`.');
              }
            }

            _this3.changes.deleted.push(actualFile);
          });
        });
      } else {
        _this3._filesystem.readdirSync(_this3._dir).forEach(function (actualFile) {
          if (keepExtraFile && keepExtraFile(actualFile)) {
            return;
          }

          if (actualFile.startsWith('.') || _this3._files.has(actualFile)) {
            return;
          }

          if (!_this3.onlyValidate) {
            try {
              _this3._filesystem.unlinkSync(path.join(_this3._dir, actualFile));
            } catch (_unused2) {
              throw new Error('CodegenDirectory: Failed to delete `' + actualFile + '` in `' + _this3._dir + '`.');
            }
          }

          _this3.changes.deleted.push(actualFile);
        });
      }
    });
  };

  _proto.getPath = function getPath(filename) {
    if (this._shards > 1) {
      var hasher = crypto.createHash('md5');
      hasher.update(filename, 'utf8');

      var shard = hasher.digest().readUInt32BE(0) % this._shards;

      return path.join(this._dir, this._getShardName(shard), filename);
    }

    return path.join(this._dir, filename);
  };

  _proto._getShardName = function _getShardName(shardNumber) {
    var base16length = Math.ceil(Math.log2(256) / 4);
    return shardNumber.toString(16).padStart(base16length, '0');
  };

  _proto._addGenerated = function _addGenerated(filename) {
    !!this._files.has(filename) ?  true ? invariant(false, 'CodegenDirectory: Tried to generate `%s` twice in `%s`.', filename, this._dir) : undefined : void 0;

    this._files.add(filename);
  };

  return CodegenDirectory;
}();

module.exports = CodegenDirectory;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var Profiler = __webpack_require__(7); // $FlowFixMe[untyped-import] : Immutable is not typed


var _require = __webpack_require__(15),
    ImmutableMap = _require.Map;

var ASTCache = /*#__PURE__*/function () {
  function ASTCache(config) {
    this._documents = new Map();
    this._baseDir = config.baseDir;
    this._parse = Profiler.instrument(config.parse, 'ASTCache.parseFn');
  } // Short-term: we don't do subscriptions/delta updates, instead always use all definitions
  // $FlowFixMe[value-as-type]


  var _proto = ASTCache.prototype;

  _proto.documents = function documents() {
    return ImmutableMap(this._documents);
  } // parse should return the set of changes
  ;

  _proto.parseFiles = function parseFiles(files) {
    var _this = this;

    var documents = ImmutableMap();
    files.forEach(function (file) {
      if (!file.exists) {
        _this._documents["delete"](file.relPath);

        return;
      }

      var doc = function () {
        try {
          return _this._parse(_this._baseDir, file);
        } catch (error) {
          throw new Error("Parse error: ".concat(error, " in \"").concat(file.relPath, "\""));
        }
      }();

      if (!doc) {
        _this._documents["delete"](file.relPath);

        return;
      }

      documents = documents.set(file.relPath, doc);

      _this._documents.set(file.relPath, doc);
    });
    return documents;
  };

  return ASTCache;
}();

module.exports = ASTCache;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var Profiler = __webpack_require__(7);

var orList = __webpack_require__(66);

var partitionArray = __webpack_require__(16);

var _require = __webpack_require__(31),
    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

var _require2 = __webpack_require__(1),
    createCompilerError = _require2.createCompilerError,
    createUserError = _require2.createUserError,
    eachWithCombinedError = _require2.eachWithCombinedError;

var _require3 = __webpack_require__(10),
    isExecutableDefinitionAST = _require3.isExecutableDefinitionAST;

var _require4 = __webpack_require__(32),
    getFieldDefinitionLegacy = _require4.getFieldDefinitionLegacy;

var _require5 = __webpack_require__(8),
    parseGraphQL = _require5.parse,
    parseType = _require5.parseType,
    print = _require5.print,
    Source = _require5.Source;

var ARGUMENT_DEFINITIONS = 'argumentDefinitions';
var ARGUMENTS = 'arguments';
var DEPRECATED_UNCHECKED_ARGUMENTS = 'uncheckedArguments_DEPRECATED';
var DIRECTIVE_WHITELIST = new Set([ARGUMENT_DEFINITIONS, DEPRECATED_UNCHECKED_ARGUMENTS, ARGUMENTS]);
/**
 * @internal
 *
 * This directive is not intended for use by developers directly. To set a field
 * handle in product code use a compiler plugin.
 */

var CLIENT_FIELD = '__clientField';
var CLIENT_FIELD_HANDLE = 'handle';
var CLIENT_FIELD_KEY = 'key';
var CLIENT_FIELD_FILTERS = 'filters';
var INCLUDE = 'include';
var SKIP = 'skip';
var IF = 'if';
/**
 * Transforms GraphQL text into Relay Compiler's internal, strongly-typed
 * intermediate representation (IR).
 */

function parse(schema, text, filename) {
  var ast = parseGraphQL(new Source(text, filename));
  var parser = new RelayParser(schema.extend(ast), ast.definitions);
  return parser.transform();
}
/**
 * Transforms untyped GraphQL parse trees (ASTs) into Relay Compiler's
 * internal, strongly-typed intermediate representation (IR).
 */


function transform(schema, definitions) {
  return Profiler.run('RelayParser.transform', function () {
    var parser = new RelayParser(schema, definitions);
    return parser.transform();
  });
}
/**
 * @private
 */


var RelayParser = /*#__PURE__*/function () {
  function RelayParser(schema, definitions) {
    var _this = this;

    this._definitions = new Map(); // leaving this configurable to make it easy to experiment w changing later

    this._getFieldDefinition = getFieldDefinitionLegacy;
    this._schema = schema;
    var duplicated = new Set();
    definitions.forEach(function (def) {
      if (isExecutableDefinitionAST(def)) {
        var name = getName(def);

        if (_this._definitions.has(name)) {
          duplicated.add(name);
          return;
        }

        _this._definitions.set(name, def);
      }
    });

    if (duplicated.size) {
      throw createUserError('RelayParser: Encountered duplicate definitions for one or more ' + 'documents: each document must have a unique name. Duplicated documents:\n' + Array.from(duplicated, function (name) {
        return "- ".concat(name);
      }).join('\n'));
    }
  }

  var _proto = RelayParser.prototype;

  _proto.transform = function transform() {
    var _this2 = this;

    var nodes = [];
    var entries = new Map(); // Construct a mapping of name to definition ast + variable definitions.
    // This allows the subsequent AST -> IR tranformation to reference the
    // defined arguments of referenced fragments.

    eachWithCombinedError(this._definitions, function (_ref) {
      var name = _ref[0],
          definition = _ref[1];

      var variableDefinitions = _this2._buildArgumentDefinitions(definition);

      entries.set(name, {
        definition: definition,
        variableDefinitions: variableDefinitions
      });
    }); // Convert the ASTs to IR.

    eachWithCombinedError(entries.values(), function (_ref2) {
      var definition = _ref2.definition,
          variableDefinitions = _ref2.variableDefinitions;
      var node = parseDefinition(_this2._schema, _this2._getFieldDefinition, entries, definition, variableDefinitions);
      nodes.push(node);
    });
    return nodes;
  }
  /**
   * Constructs a mapping of variable names to definitions for the given
   * operation/fragment definition.
   */
  ;

  _proto._buildArgumentDefinitions = function _buildArgumentDefinitions(definition) {
    switch (definition.kind) {
      case 'OperationDefinition':
        return this._buildOperationArgumentDefinitions(definition);

      case 'FragmentDefinition':
        return this._buildFragmentArgumentDefinitions(definition);

      default:
        definition;
        throw createCompilerError("Unexpected ast kind '".concat(definition.kind, "'."), [definition]);
    }
  }
  /**
   * Constructs a mapping of variable names to definitions using the
   * variables defined in `@argumentDefinitions`.
   */
  ;

  _proto._buildFragmentArgumentDefinitions = function _buildFragmentArgumentDefinitions(fragment) {
    var _this3 = this;

    var variableDirectives = (fragment.directives || []).filter(function (directive) {
      return getName(directive) === ARGUMENT_DEFINITIONS;
    });

    if (!variableDirectives.length) {
      return new Map();
    }

    if (variableDirectives.length !== 1) {
      throw createUserError("Directive @".concat(ARGUMENT_DEFINITIONS, " may be defined at most once per ") + 'fragment.', null, variableDirectives);
    }

    var variableDirective = variableDirectives[0]; // work, below accesses all report arguments could still be null/undefined.

    var args = variableDirective.arguments;

    if (variableDirective == null || !Array.isArray(args)) {
      return new Map();
    }

    if (!args.length) {
      throw createUserError("Directive @".concat(ARGUMENT_DEFINITIONS, " requires arguments: remove the ") + 'directive to skip defining local variables for this fragment.', null, [variableDirective]);
    }

    var variables = new Map();
    args.forEach(function (arg) {
      var _defaultValue$value;

      var argName = getName(arg);
      var previousVariable = variables.get(argName);

      if (previousVariable != null) {
        throw createUserError("Duplicate definition for variable '$".concat(argName, "'."), null, [previousVariable.ast, arg]);
      }

      if (arg.value.kind !== 'ObjectValue') {
        throw createUserError("Expected definition for variable '$".concat(argName, "' to be an object ") + "with the shape: '{type: string, defaultValue?: mixed}.", null, [arg.value]);
      }

      var defaultValueNode;
      var typeString;
      arg.value.fields.forEach(function (field) {
        var name = getName(field);

        if (name === 'type') {
          typeString = transformLiteralValue(field.value, field);
        } else if (name === 'defaultValue') {
          defaultValueNode = field.value;
        } else {
          throw createUserError("Expected definition for variable '$".concat(argName, "' to be an object ") + "with the shape: '{type: string, defaultValue?: mixed}.", null, [arg.value]);
        }
      });

      if (typeof typeString !== 'string') {
        throw createUserError("Expected definition for variable '$".concat(argName, "' to be an object ") + "with the shape: '{type: string, defaultValue?: mixed}.", null, [arg.value]);
      }

      var typeFromAST = _this3._schema.getTypeFromAST(parseType(typeString));

      if (typeFromAST == null) {
        throw createUserError( // $FlowFixMe[incompatible-type]
        "Unknown type \"".concat(typeString, "\" referenced in the argument definitions."), null, [arg]);
      }

      var type = _this3._schema.asInputType(typeFromAST);

      if (type == null) {
        throw createUserError( // $FlowFixMe[incompatible-type]
        "Expected type \"".concat(typeString, "\" to be an input type in the \"").concat(arg.name.value, "\" argument definitions."), null, [arg.value]);
      }

      var defaultValue = defaultValueNode != null ? transformValue(_this3._schema, defaultValueNode, type, function (variableAst) {
        throw createUserError("Expected 'defaultValue' to be a literal, got a variable.", null, [variableAst]);
      }) : null;

      if (defaultValue != null && defaultValue.kind !== 'Literal') {
        throw createUserError("Expected 'defaultValue' to be a literal, got a variable.", [defaultValue.loc]);
      }

      variables.set(argName, {
        ast: arg,
        defaultValue: (_defaultValue$value = defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) !== null && _defaultValue$value !== void 0 ? _defaultValue$value : null,
        defined: true,
        name: argName,
        type: type
      });
    });
    return variables;
  }
  /**
   * Constructs a mapping of variable names to definitions using the
   * standard GraphQL syntax for variable definitions.
   */
  ;

  _proto._buildOperationArgumentDefinitions = function _buildOperationArgumentDefinitions(operation) {
    var schema = this._schema;
    var variableDefinitions = new Map();
    (operation.variableDefinitions || []).forEach(function (def) {
      var name = getName(def.variable);
      var typeFromAST = schema.getTypeFromAST(def.type);

      if (typeFromAST == null) {
        throw createUserError("Unknown type: '".concat(getTypeName(def.type), "'."), null, [def.type]);
      }

      var type = schema.asInputType(typeFromAST);

      if (type == null) {
        throw createUserError("Expected type \"".concat(getTypeName(def.type), "\" to be an input type."), null, [def.type]);
      }

      var defaultValue = def.defaultValue ? transformLiteralValue(def.defaultValue, def) : null;
      var previousDefinition = variableDefinitions.get(name);

      if (previousDefinition != null) {
        throw createUserError("Duplicate definition for variable '$".concat(name, "'."), null, [previousDefinition.ast, def]);
      }

      variableDefinitions.set(name, {
        ast: def,
        defaultValue: defaultValue,
        defined: true,
        name: name,
        type: type
      });
    });
    return variableDefinitions;
  };

  return RelayParser;
}();
/**
 * @private
 */


function parseDefinition(schema, getFieldDefinition, entries, definition, variableDefinitions) {
  var parser = new GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions);
  return parser.transform();
}
/**
 * @private
 */


var GraphQLDefinitionParser = /*#__PURE__*/function () {
  function GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions) {
    this._definition = definition;
    this._entries = entries;
    this._getFieldDefinition = getFieldDefinition;
    this._schema = schema;
    this._variableDefinitions = variableDefinitions;
    this._unknownVariables = new Map();
  }

  var _proto2 = GraphQLDefinitionParser.prototype;

  _proto2.transform = function transform() {
    var definition = this._definition;

    switch (definition.kind) {
      case 'OperationDefinition':
        return this._transformOperation(definition);

      case 'FragmentDefinition':
        return this._transformFragment(definition);

      default:
        definition;
        throw createCompilerError("Unsupported definition type ".concat(definition.kind), [definition]);
    }
  };

  _proto2._recordAndVerifyVariableReference = function _recordAndVerifyVariableReference(variable, name, usedAsType) {
    // Special case for variables used in @arguments where we currently
    // aren't guaranteed to be able to resolve the type.
    if (usedAsType == null) {
      if (!this._variableDefinitions.has(name) && !this._unknownVariables.has(name)) {
        this._unknownVariables.set(name, {
          ast: variable,
          type: null
        });
      }

      return;
    }

    var variableDefinition = this._variableDefinitions.get(name);

    if (variableDefinition != null) {
      // If the variable is defined, all usages must be compatible
      var effectiveType = variableDefinition.type;

      if (variableDefinition.defaultValue != null) {
        // If a default value is defined then it is guaranteed to be used
        // at runtime such that the effective type of the variable is non-null
        effectiveType = this._schema.getNonNullType(this._schema.getNullableType(effectiveType));
      }

      if (!this._schema.isTypeSubTypeOf(effectiveType, usedAsType)) {
        throw createUserError("Variable '$".concat(name, "' was defined as type '").concat(String(variableDefinition.type), "' but used in a location expecting the type '").concat(String(usedAsType), "'"), null, [variableDefinition.ast, variable]);
      }
    } else {
      var previous = this._unknownVariables.get(name);

      if (!previous || !previous.type) {
        // No previous usage, current type is strongest
        this._unknownVariables.set(name, {
          ast: variable,
          type: usedAsType
        });
      } else {
        var previousVariable = previous.ast,
            previousType = previous.type;

        if (!(this._schema.isTypeSubTypeOf(usedAsType, previousType) || this._schema.isTypeSubTypeOf(previousType, usedAsType))) {
          throw createUserError("Variable '$".concat(name, "' was used in locations expecting the conflicting types '").concat(String(previousType), "' and '").concat(String(usedAsType), "'."), null, [previousVariable, variable]);
        } // If the new used type has stronger requirements, use that type as reference,
        // otherwise keep referencing the previous type


        if (this._schema.isTypeSubTypeOf(usedAsType, previousType)) {
          this._unknownVariables.set(name, {
            ast: variable,
            type: usedAsType
          });
        }
      }
    }
  };

  _proto2._getDirectiveLocations = function _getDirectiveLocations() {
    if (!this._directiveLocations) {
      var directiveDefs = this._schema.getDirectives();

      this._directiveLocations = new Map();

      var _iterator = (0, _createForOfIteratorHelper2["default"])(directiveDefs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var def = _step.value;

          this._directiveLocations.set(def.name, def.locations);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return this._directiveLocations;
  };

  _proto2._validateDirectivesLocation = function _validateDirectivesLocation(directives, allowedLocaction) {
    if (!directives || !directives.length) {
      return;
    }

    var directiveLocs = this._getDirectiveLocations();

    var mismatches = directives.filter(function (directive) {
      var name = getName(directive);

      if (DIRECTIVE_WHITELIST.has(name)) {
        return false;
      }

      var locs = directiveLocs.get(name);

      if (locs == null) {
        throw createUserError("Unknown directive '".concat(name, "'."), null, [directive]);
      }

      return !locs.some(function (loc) {
        return loc === allowedLocaction;
      });
    });

    if (mismatches.length) {
      var invalidDirectives = mismatches.map(function (directive) {
        return '@' + getName(directive);
      }).join(', ');
      throw createUserError("Invalid directives ".concat(invalidDirectives, " found on ").concat(allowedLocaction, "."), null, mismatches);
    }
  };

  _proto2._transformFragment = function _transformFragment(fragment) {
    var directives = this._transformDirectives((fragment.directives || []).filter(function (directive) {
      return getName(directive) !== ARGUMENT_DEFINITIONS;
    }), 'FRAGMENT_DEFINITION');

    var typeFromAST = this._schema.getTypeFromAST(fragment.typeCondition);

    if (typeFromAST == null) {
      throw createUserError("Fragment \"".concat(fragment.name.value, "\" cannot condition on unknown ") + "type \"".concat(String(fragment.typeCondition.name.value), "\"."), null, [fragment.typeCondition]);
    }

    var type = this._schema.asCompositeType(typeFromAST);

    if (type == null) {
      throw createUserError("Fragment \"".concat(fragment.name.value, "\" cannot condition on non composite ") + "type \"".concat(String(type), "\"."), null, [fragment.typeCondition]);
    }

    var selections = this._transformSelections(fragment.selectionSet, type, fragment.typeCondition);

    var argumentDefinitions = (0, _toConsumableArray2["default"])(buildArgumentDefinitions(this._variableDefinitions));

    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._unknownVariables),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _step2.value,
            name = _step2$value[0],
            variableReference = _step2$value[1];
        argumentDefinitions.push({
          kind: 'RootArgumentDefinition',
          loc: buildLocation(variableReference.ast.loc),
          name: name,
          type: variableReference.type
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return {
      kind: 'Fragment',
      directives: directives,
      loc: buildLocation(fragment.loc),
      metadata: null,
      name: getName(fragment),
      selections: selections,
      type: type,
      // $FlowFixMe[incompatible-return] - could be null
      argumentDefinitions: argumentDefinitions
    };
  };

  _proto2._getLocationFromOperation = function _getLocationFromOperation(definition) {
    switch (definition.operation) {
      case 'query':
        return 'QUERY';

      case 'mutation':
        return 'MUTATION';

      case 'subscription':
        return 'SUBSCRIPTION';

      default:
        definition.operation;
        throw createCompilerError("Unknown operation type '".concat(definition.operation, "'."), null, [definition]);
    }
  };

  _proto2._transformOperation = function _transformOperation(definition) {
    var name = getName(definition);

    var directives = this._transformDirectives(definition.directives || [], this._getLocationFromOperation(definition));

    var type;
    var operation;
    var schema = this._schema;

    switch (definition.operation) {
      case 'query':
        operation = 'query';
        type = schema.expectQueryType();
        break;

      case 'mutation':
        operation = 'mutation';
        type = schema.expectMutationType();
        break;

      case 'subscription':
        operation = 'subscription';
        type = schema.expectSubscriptionType();
        break;

      default:
        definition.operation;
        throw createCompilerError("Unknown operation type '".concat(definition.operation, "'."), null, [definition]);
    }

    if (!definition.selectionSet) {
      throw createUserError('Expected operation to have selections.', null, [definition]);
    }

    var selections = this._transformSelections(definition.selectionSet, type);

    var argumentDefinitions = buildArgumentDefinitions(this._variableDefinitions);

    if (this._unknownVariables.size !== 0) {
      throw createUserError("Query '".concat(name, "' references undefined variables."), null, Array.from(this._unknownVariables.values(), function (variableReference) {
        return variableReference.ast;
      }));
    }

    return {
      kind: 'Root',
      operation: operation,
      loc: buildLocation(definition.loc),
      metadata: null,
      name: name,
      argumentDefinitions: argumentDefinitions,
      directives: directives,
      selections: selections,
      // $FlowFixMe[incompatible-return]
      type: type
    };
  };

  _proto2._transformSelections = function _transformSelections(selectionSet, parentType, parentTypeAST) {
    var _this4 = this;

    return selectionSet.selections.map(function (selection) {
      var node;

      if (selection.kind === 'Field') {
        node = _this4._transformField(selection, parentType);
      } else if (selection.kind === 'FragmentSpread') {
        node = _this4._transformFragmentSpread(selection, parentType, parentTypeAST);
      } else if (selection.kind === 'InlineFragment') {
        node = _this4._transformInlineFragment(selection, parentType, parentTypeAST);
      } else {
        selection.kind;
        throw createCompilerError("Unknown ast kind '".concat(selection.kind, "'."), [selection]);
      }

      var _this4$_splitConditio = _this4._splitConditions(node.directives),
          conditions = _this4$_splitConditio[0],
          directives = _this4$_splitConditio[1];

      var conditionalNodes = applyConditions(conditions, // $FlowFixMe[incompatible-call]
      [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
        directives: directives
      })]);

      if (conditionalNodes.length !== 1) {
        throw createCompilerError('Expected exactly one condition node.', null, selection.directives);
      }

      return conditionalNodes[0];
    });
  };

  _proto2._transformInlineFragment = function _transformInlineFragment(fragment, parentType, parentTypeAST) {
    var schema = this._schema;
    var typeCondition = fragment.typeCondition != null ? schema.getTypeFromAST(fragment.typeCondition) : parentType;

    if (typeCondition == null) {
      var _fragment$typeConditi;

      throw createUserError('Inline fragments can only be on object, interface or union types' + ", got unknown type '".concat(getTypeName(fragment.typeCondition), "'."), null, [(_fragment$typeConditi = fragment.typeCondition) !== null && _fragment$typeConditi !== void 0 ? _fragment$typeConditi : fragment]);
    }

    var typeConditionName = schema.getTypeString(typeCondition);
    typeCondition = schema.asCompositeType(typeCondition);

    if (typeCondition == null) {
      var _fragment$typeConditi2;

      throw createUserError('Inline fragments can only be on object, interface or union types' + ", got '".concat(typeConditionName, "'."), null, [(_fragment$typeConditi2 = fragment.typeCondition) !== null && _fragment$typeConditi2 !== void 0 ? _fragment$typeConditi2 : fragment]);
    }

    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));

    checkFragmentSpreadTypeCompatibility(this._schema, typeCondition, rawParentType, null, fragment.typeCondition, parentTypeAST);

    var directives = this._transformDirectives(fragment.directives || [], 'INLINE_FRAGMENT');

    var selections = this._transformSelections(fragment.selectionSet, typeCondition, fragment.typeCondition);

    return {
      kind: 'InlineFragment',
      directives: directives,
      loc: buildLocation(fragment.loc),
      metadata: null,
      selections: selections,
      typeCondition: typeCondition
    };
  };

  _proto2._transformFragmentSpread = function _transformFragmentSpread(fragmentSpread, parentType, parentTypeAST) {
    var _this5 = this;

    var fragmentName = getName(fragmentSpread);

    var _partitionArray = partitionArray(fragmentSpread.directives || [], function (directive) {
      var name = getName(directive);
      return name === ARGUMENTS || name === DEPRECATED_UNCHECKED_ARGUMENTS;
    }),
        argumentDirectives = _partitionArray[0],
        otherDirectives = _partitionArray[1];

    if (argumentDirectives.length > 1) {
      throw createUserError("Directive @".concat(ARGUMENTS, " may be used at most once per a fragment spread."), null, argumentDirectives);
    }

    var fragmentDefinition = this._entries.get(fragmentName);

    if (fragmentDefinition == null) {
      throw createUserError("Unknown fragment '".concat(fragmentName, "'."), null, [fragmentSpread.name]);
    }

    var fragmentTypeNode = getFragmentType(fragmentDefinition.definition);

    var fragmentType = this._schema.assertCompositeType(this._schema.expectTypeFromAST(fragmentTypeNode));

    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));

    checkFragmentSpreadTypeCompatibility(this._schema, fragmentType, rawParentType, fragmentSpread.name.value, fragmentSpread, parentTypeAST);
    var fragmentArgumentDefinitions = fragmentDefinition.variableDefinitions;
    var argumentsDirective = argumentDirectives[0];
    var args;

    if (argumentsDirective != null) {
      var isDeprecatedUncheckedArguments = getName(argumentsDirective) === DEPRECATED_UNCHECKED_ARGUMENTS;
      var hasInvalidArgument = false;
      args = (argumentsDirective.arguments || []).map(function (arg) {
        var _argumentDefinition$t;

        var argName = getName(arg);
        var argValue = arg.value;
        var argumentDefinition = fragmentArgumentDefinitions.get(argName);
        var argumentType = (_argumentDefinition$t = argumentDefinition === null || argumentDefinition === void 0 ? void 0 : argumentDefinition.type) !== null && _argumentDefinition$t !== void 0 ? _argumentDefinition$t : null;

        if (argValue.kind === 'Variable') {
          if (argumentDefinition == null && !isDeprecatedUncheckedArguments) {
            throw createUserError("Variable @".concat(ARGUMENTS, " values are only supported when the ") + "argument is defined with @".concat(ARGUMENT_DEFINITIONS, ". Check ") + "the definition of fragment '".concat(fragmentName, "'."), null, [arg.value, fragmentDefinition.definition]);
          }

          hasInvalidArgument = hasInvalidArgument || argumentDefinition == null; // TODO: check the type of the variable and use the type

          return {
            kind: 'Argument',
            loc: buildLocation(arg.loc),
            name: argName,
            value: _this5._transformVariable(argValue, null),
            type: null
          };
        } else {
          if (argumentType == null) {
            throw createUserError("Literal @".concat(ARGUMENTS, " values are only supported when the ") + "argument is defined with @".concat(ARGUMENT_DEFINITIONS, ". Check ") + "the definition of fragment '".concat(fragmentName, "'."), null, [arg.value, fragmentDefinition.definition]);
          }

          var value = _this5._transformValue(argValue, argumentType);

          return {
            kind: 'Argument',
            loc: buildLocation(arg.loc),
            name: argName,
            value: value,
            type: argumentType
          };
        }
      });

      if (isDeprecatedUncheckedArguments && !hasInvalidArgument) {
        throw createUserError("Invalid use of @".concat(DEPRECATED_UNCHECKED_ARGUMENTS, ": all arguments ") + "are defined, use @".concat(ARGUMENTS, " instead."), null, [argumentsDirective]);
      }
    }

    var directives = this._transformDirectives(otherDirectives, 'FRAGMENT_SPREAD');

    return {
      kind: 'FragmentSpread',
      args: args || [],
      metadata: null,
      loc: buildLocation(fragmentSpread.loc),
      name: fragmentName,
      directives: directives
    };
  };

  _proto2._transformField = function _transformField(field, parentType) {
    var _field$alias$value, _field$alias;

    var schema = this._schema;
    var name = getName(field);

    var fieldDef = this._getFieldDefinition(schema, parentType, name, field);

    if (fieldDef == null) {
      throw createUserError("Unknown field '".concat(name, "' on type '").concat(schema.getTypeString(parentType), "'."), null, [field]);
    }

    var alias = (_field$alias$value = (_field$alias = field.alias) === null || _field$alias === void 0 ? void 0 : _field$alias.value) !== null && _field$alias$value !== void 0 ? _field$alias$value : name;

    var args = this._transformArguments(field.arguments || [], schema.getFieldArgs(fieldDef), fieldDef);

    var _partitionArray2 = partitionArray(field.directives || [], function (directive) {
      return getName(directive) !== CLIENT_FIELD;
    }),
        otherDirectives = _partitionArray2[0],
        clientFieldDirectives = _partitionArray2[1];

    var directives = this._transformDirectives(otherDirectives, 'FIELD');

    var type = schema.getFieldType(fieldDef);

    var handles = this._transformHandle(name, args, clientFieldDirectives);

    if (schema.isLeafType(schema.getRawType(type))) {
      if (field.selectionSet && field.selectionSet.selections && field.selectionSet.selections.length) {
        throw createUserError("Expected no selections for scalar field '".concat(name, "'."), null, [field]);
      }

      return {
        kind: 'ScalarField',
        alias: alias,
        args: args,
        directives: directives,
        handles: handles,
        loc: buildLocation(field.loc),
        metadata: null,
        name: name,
        type: schema.assertScalarFieldType(type)
      };
    } else {
      var selections = field.selectionSet ? this._transformSelections(field.selectionSet, type) : null;

      if (selections == null || selections.length === 0) {
        throw createUserError("Expected at least one selection for non-scalar field '".concat(name, "' on type '").concat(schema.getTypeString(type), "'."), null, [field]);
      }

      return {
        kind: 'LinkedField',
        alias: alias,
        args: args,
        connection: false,
        directives: directives,
        handles: handles,
        loc: buildLocation(field.loc),
        metadata: null,
        name: name,
        selections: selections,
        type: schema.assertLinkedFieldType(type)
      };
    }
  };

  _proto2._transformHandle = function _transformHandle(fieldName, fieldArgs, clientFieldDirectives) {
    var handles = null;
    clientFieldDirectives.forEach(function (clientFieldDirective) {
      var handleArgument = (clientFieldDirective.arguments || []).find(function (arg) {
        return getName(arg) === CLIENT_FIELD_HANDLE;
      });

      if (handleArgument) {
        var name = null;
        var key = DEFAULT_HANDLE_KEY;
        var filters = null;
        var maybeHandle = transformLiteralValue(handleArgument.value, handleArgument);

        if (typeof maybeHandle !== 'string') {
          throw createUserError("Expected a string literal argument for the @".concat(CLIENT_FIELD, " directive."), null, [handleArgument.value]);
        }

        name = maybeHandle;
        var keyArgument = (clientFieldDirective.arguments || []).find(function (arg) {
          return getName(arg) === CLIENT_FIELD_KEY;
        });

        if (keyArgument) {
          var maybeKey = transformLiteralValue(keyArgument.value, keyArgument);

          if (typeof maybeKey !== 'string') {
            throw createUserError("Expected a string literal argument for the @".concat(CLIENT_FIELD, " directive."), null, [keyArgument.value]);
          }

          key = maybeKey;
        }

        var filtersArgument = (clientFieldDirective.arguments || []).find(function (arg) {
          return getName(arg) === CLIENT_FIELD_FILTERS;
        });

        if (filtersArgument) {
          var maybeFilters = transformLiteralValue(filtersArgument.value, filtersArgument);

          if (!(Array.isArray(maybeFilters) && maybeFilters.every(function (filter) {
            return typeof filter === 'string' && fieldArgs.some(function (fieldArg) {
              return fieldArg.name === filter;
            });
          }))) {
            throw createUserError("Expected an array of argument names on field '".concat(fieldName, "'."), null, [filtersArgument.value]);
          } // $FlowFixMe[incompatible-cast]


          filters = maybeFilters;
        }

        var dynamicKeyArgument = (clientFieldDirective.arguments || []).find(function (arg) {
          return getName(arg) === 'dynamicKey_UNSTABLE';
        });

        if (dynamicKeyArgument != null) {
          throw createUserError('Dynamic keys are only supported with @connection.', null, [dynamicKeyArgument.value]);
        }

        handles = handles || [];
        handles.push({
          name: name,
          key: key,
          filters: filters,
          dynamicKey: null
        });
      }
    });
    return handles;
  };

  _proto2._transformDirectives = function _transformDirectives(directives, location) {
    var _this6 = this;

    this._validateDirectivesLocation(directives, location);

    return directives.map(function (directive) {
      var name = getName(directive);

      var directiveDef = _this6._schema.getDirective(name);

      if (directiveDef == null) {
        throw createUserError("Unknown directive '".concat(name, "'."), null, [directive]);
      }

      var args = _this6._transformArguments(directive.arguments || [], directiveDef.args.map(function (item) {
        return {
          name: item.name,
          type: item.type,
          defaultValue: item.defaultValue
        };
      }), null, name);

      return {
        kind: 'Directive',
        loc: buildLocation(directive.loc),
        name: name,
        args: args
      };
    });
  };

  _proto2._transformArguments = function _transformArguments(args, argumentDefinitions, field, directiveName) {
    var _this7 = this;

    return args.map(function (arg) {
      var argName = getName(arg);
      var argDef = argumentDefinitions.find(function (def) {
        return def.name === argName;
      });

      if (argDef == null) {
        var message = "Unknown argument '".concat(argName, "'") + (field ? " on field '".concat(_this7._schema.getFieldName(field), "'") + " of type '".concat(_this7._schema.getTypeString(_this7._schema.getFieldParentType(field)), "'.") : directiveName != null ? " on directive '@".concat(directiveName, "'.") : '.');
        throw createUserError(message, null, [arg]);
      }

      var value = _this7._transformValue(arg.value, argDef.type);

      return {
        kind: 'Argument',
        loc: buildLocation(arg.loc),
        name: argName,
        value: value,
        type: argDef.type
      };
    });
  };

  _proto2._splitConditions = function _splitConditions(mixedDirectives) {
    var _partitionArray3 = partitionArray(mixedDirectives, function (directive) {
      return directive.name === INCLUDE || directive.name === SKIP;
    }),
        conditionDirectives = _partitionArray3[0],
        otherDirectives = _partitionArray3[1];

    var conditions = conditionDirectives.map(function (directive) {
      var passingValue = directive.name === INCLUDE;
      var arg = directive.args[0];

      if (arg == null || arg.name !== IF) {
        throw createUserError("Expected an 'if' argument to @".concat(directive.name, "."), [directive.loc]);
      }

      if (!(arg.value.kind === 'Variable' || arg.value.kind === 'Literal')) {
        throw createUserError("Expected the 'if' argument to @".concat(directive.name, " to be a variable or literal."), [directive.loc]);
      }

      return {
        kind: 'Condition',
        condition: arg.value,
        loc: directive.loc,
        passingValue: passingValue,
        selections: []
      };
    });
    var sortedConditions = conditions.sort(function (a, b) {
      if (a.condition.kind === 'Variable' && b.condition.kind === 'Variable') {
        return a.condition.variableName < b.condition.variableName ? -1 : a.condition.variableName > b.condition.variableName ? 1 : 0;
      } else {
        // sort literals earlier, variables later
        return a.condition.kind === 'Variable' ? 1 : b.condition.kind === 'Variable' ? -1 : 0;
      }
    });
    return [sortedConditions, otherDirectives];
  };

  _proto2._transformVariable = function _transformVariable(ast, usedAsType) {
    var variableName = getName(ast);

    this._recordAndVerifyVariableReference(ast, variableName, usedAsType);

    return {
      kind: 'Variable',
      loc: buildLocation(ast.loc),
      variableName: variableName,
      type: usedAsType
    };
  };

  _proto2._transformValue = function _transformValue(ast, type) {
    var _this8 = this;

    return transformValue(this._schema, ast, type, function (variableAst, variableType) {
      return _this8._transformVariable(variableAst, variableType);
    });
  };

  return GraphQLDefinitionParser;
}();
/**
 * Transforms and validates argument values according to the expected
 * type.
 */


function transformValue(schema, ast, type, transformVariable) {
  if (ast.kind === 'Variable') {
    // Special case variables since there is no value to parse
    return transformVariable(ast, type);
  } else if (ast.kind === 'NullValue') {
    // Special case null literals since there is no value to parse
    if (schema.isNonNull(type)) {
      throw createUserError("Expected a value matching type '".concat(String(type), "'."), null, [ast]);
    }

    return {
      kind: 'Literal',
      loc: buildLocation(ast.loc),
      value: null
    };
  } else {
    return transformNonNullLiteral(schema, ast, type, transformVariable);
  }
}
/**
 * Transforms and validates non-null literal (non-variable) values
 * according to the expected type.
 */


function transformNonNullLiteral(schema, ast, type, transformVariable) {
  // Transform the value based on the type without a non-null wrapper.
  // Note that error messages should still use the original `type`
  // since that accurately describes to the user what the expected
  // type is (using nullableType would suggest that `null` is legal
  // even when it may not be, for example).
  var nullableType = schema.getNullableType(type);

  if (schema.isList(nullableType)) {
    if (ast.kind !== 'ListValue') {
      // Parse singular (non-list) values flowing into a list type
      // as scalars, ie without wrapping them in an array.
      if (!schema.isInputType(schema.getListItemType(nullableType))) {
        throw createUserError("Expected type ".concat(schema.getTypeString(nullableType), " to be an input type."), null, [ast]);
      }

      return transformValue(schema, ast, schema.assertInputType(schema.getListItemType(nullableType)), transformVariable);
    }

    var itemType = schema.assertInputType(schema.getListItemType(nullableType));
    var literalList = [];
    var items = [];
    var areAllItemsScalar = true;
    ast.values.forEach(function (item) {
      var itemValue = transformValue(schema, item, itemType, transformVariable);

      if (itemValue.kind === 'Literal') {
        literalList.push(itemValue.value);
      }

      items.push(itemValue);
      areAllItemsScalar = areAllItemsScalar && itemValue.kind === 'Literal';
    });

    if (areAllItemsScalar) {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: literalList
      };
    } else {
      return {
        kind: 'ListValue',
        loc: buildLocation(ast.loc),
        items: items
      };
    }
  } else if (schema.isInputObject(nullableType)) {
    if (ast.kind !== 'ObjectValue') {
      throw createUserError("Expected a value matching type '".concat(schema.getTypeString(type), "'."), null, [ast]);
    }

    var literalObject = {};
    var fields = [];
    var areAllFieldsScalar = true;
    var inputType = schema.assertInputObjectType(nullableType);
    var requiredFieldNames = new Set(schema.getFields(inputType).filter(function (field) {
      return schema.isNonNull(schema.getFieldType(field));
    }).map(function (field) {
      return schema.getFieldName(field);
    }));
    var seenFields = new Map();
    ast.fields.forEach(function (field) {
      var fieldName = getName(field);
      var seenField = seenFields.get(fieldName);

      if (seenField) {
        throw createUserError("Duplicated field name '".concat(fieldName, "' in the input object."), null, [field, seenField]);
      }

      var fieldID = schema.getFieldByName(inputType, fieldName);

      if (!fieldID) {
        throw createUserError("Unknown field '".concat(fieldName, "' on type '").concat(schema.getTypeString(inputType), "'."), null, [field]);
      }

      var fieldConfig = schema.getFieldConfig(fieldID);
      var fieldType = schema.assertInputType(fieldConfig.type);
      var fieldValue = transformValue(schema, field.value, fieldType, transformVariable);

      if (fieldValue.kind === 'Literal') {
        literalObject[field.name.value] = fieldValue.value;
      }

      fields.push({
        kind: 'ObjectFieldValue',
        loc: buildLocation(field.loc),
        name: fieldName,
        value: fieldValue
      });
      seenFields.set(fieldName, field);
      requiredFieldNames["delete"](fieldName);
      areAllFieldsScalar = areAllFieldsScalar && fieldValue.kind === 'Literal';
    });

    if (requiredFieldNames.size > 0) {
      var requiredFieldStr = Array.from(requiredFieldNames).map(function (item) {
        return "'".concat(item, "'");
      }).join(', ');
      throw createUserError("Missing non-optional field".concat(requiredFieldNames.size > 1 ? 's:' : '', " ").concat(requiredFieldStr, " for input type '").concat(schema.getTypeString(inputType), "'."), null, [ast]);
    }

    if (areAllFieldsScalar) {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: literalObject
      };
    } else {
      return {
        kind: 'ObjectValue',
        loc: buildLocation(ast.loc),
        fields: fields
      };
    }
  } else if (schema.isId(nullableType)) {
    // GraphQLID's parseLiteral() always returns the string value. However
    // the int/string distinction may be important at runtime, so this
    // transform parses int/string literals into the corresponding JS types.
    if (ast.kind === 'IntValue') {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: parseInt(ast.value, 10)
      };
    } else if (ast.kind === 'StringValue') {
      return {
        kind: 'Literal',
        loc: buildLocation(ast.loc),
        value: ast.value
      };
    } else {
      throw createUserError("Invalid value, expected a value matching type '".concat(schema.getTypeString(type), "'."), null, [ast]);
    }
  } else if (schema.isEnum(nullableType)) {
    var enumType = schema.assertEnumType(nullableType);
    var value = schema.parseLiteral(enumType, ast);

    if (value == null) {
      var suggestions = schema.getEnumValues(enumType); // parseLiteral() should return a non-null JavaScript value
      // if the ast value is valid for the type.

      throw createUserError("Expected a value matching type '".concat(schema.getTypeString(type), "'. Possible values: ").concat(orList(suggestions), "?'"), null, [ast]);
    }

    return {
      kind: 'Literal',
      loc: buildLocation(ast.loc),
      value: value
    };
  } else if (schema.isScalar(nullableType)) {
    var _value = schema.parseLiteral(schema.assertScalarType(nullableType), ast);

    if (_value == null) {
      // parseLiteral() should return a non-null JavaScript value
      // if the ast value is valid for the type.
      throw createUserError("Expected a value matching type '".concat(schema.getTypeString(type), "'."), null, [ast]);
    }

    return {
      kind: 'Literal',
      loc: buildLocation(ast.loc),
      value: _value
    };
  } else {
    throw createCompilerError("Unsupported type '".concat(schema.getTypeString(type), "' for input value, expected a GraphQLList, ") + 'GraphQLInputObjectType, GraphQLEnumType, or GraphQLScalarType.', null, [ast]);
  }
}
/**
 * @private
 */


function transformLiteralValue(ast, context) {
  switch (ast.kind) {
    case 'IntValue':
      return parseInt(ast.value, 10);

    case 'FloatValue':
      return parseFloat(ast.value);

    case 'StringValue':
      return ast.value;

    case 'BooleanValue':
      // Note: duplicated because Flow does not understand fall-through cases
      return ast.value;

    case 'EnumValue':
      // Note: duplicated because Flow does not understand fall-through cases
      return ast.value;

    case 'ListValue':
      return ast.values.map(function (item) {
        return transformLiteralValue(item, context);
      });

    case 'NullValue':
      return null;

    case 'ObjectValue':
      {
        var objectValue = {};
        ast.fields.forEach(function (field) {
          var fieldName = getName(field);
          var value = transformLiteralValue(field.value, context);
          objectValue[fieldName] = value;
        });
        return objectValue;
      }

    case 'Variable':
      throw createUserError('Unexpected variable where a literal (static) value is required.', null, [ast, context]);

    default:
      ast.kind;
      throw createCompilerError("Unknown ast kind '".concat(ast.kind, "'."), [ast]);
  }
}
/**
 * @private
 */


function buildArgumentDefinitions(variables) {
  return Array.from(variables.values(), function (_ref3) {
    var ast = _ref3.ast,
        name = _ref3.name,
        defaultValue = _ref3.defaultValue,
        type = _ref3.type;
    return {
      kind: 'LocalArgumentDefinition',
      loc: buildLocation(ast.loc),
      name: name,
      type: type,
      defaultValue: defaultValue
    };
  });
}
/**
 * @private
 */


function buildLocation(loc) {
  if (loc == null) {
    return {
      kind: 'Unknown'
    };
  }

  return {
    kind: 'Source',
    start: loc.start,
    end: loc.end,
    source: loc.source
  };
}
/**
 * @private
 */


function applyConditions(conditions, selections) {
  var nextSelections = selections;
  conditions.forEach(function (condition) {
    nextSelections = [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, condition), {}, {
      selections: nextSelections
    })];
  });
  return nextSelections;
}
/**
 * @private
 */


function getName(ast) {
  var _ast$name;

  var name = (_ast$name = ast.name) === null || _ast$name === void 0 ? void 0 : _ast$name.value;

  if (typeof name !== 'string') {
    throw createCompilerError("Expected ast node to have a 'name'.", null, [ast]);
  }

  return name;
}

function getTypeName(ast) {
  return ast ? print(ast) : 'Undefined Type Name';
}
/**
 * @private
 */


function getFragmentType(ast) {
  if (ast.kind === 'FragmentDefinition') {
    return ast.typeCondition;
  }

  throw createCompilerError('Expected ast node to be a FragmentDefinition node.', null, [ast]);
}

function checkFragmentSpreadTypeCompatibility(schema, fragmentType, parentType, fragmentName, fragmentTypeAST, parentTypeAST) {
  if (!schema.doTypesOverlap(fragmentType, schema.assertCompositeType(parentType))) {
    var nodes = [];

    if (parentTypeAST) {
      nodes.push(parentTypeAST);
    }

    if (fragmentTypeAST) {
      nodes.push(fragmentTypeAST);
    }

    var possibleConcreteTypes = schema.isAbstractType(parentType) ? Array.from(schema.getPossibleTypes(schema.assertAbstractType(parentType))) : [];
    var suggestedTypesMessage = '';

    if (possibleConcreteTypes.length !== 0) {
      suggestedTypesMessage = " Possible concrete types include ".concat(possibleConcreteTypes.sort().slice(0, 3).map(function (type) {
        return "'".concat(schema.getTypeString(type), "'");
      }).join(', '), ", etc.");
    }

    throw createUserError((fragmentName != null ? "Fragment '".concat(fragmentName, "' cannot be spread here as objects of ") : 'Fragment cannot be spread here as objects of ') + "type '".concat(schema.getTypeString(parentType), "' ") + "can never be of type '".concat(schema.getTypeString(fragmentType), "'.") + suggestedTypesMessage, null, nodes);
  }
}

module.exports = {
  parse: parse,
  transform: transform
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


module.exports = {
  DEFAULT_HANDLE_KEY: ''
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

var _require2 = __webpack_require__(8),
    SchemaMetaFieldDef = _require2.SchemaMetaFieldDef,
    TypeMetaFieldDef = _require2.TypeMetaFieldDef;

/**
 * Find the definition of a field of the specified type using strict
 * resolution rules per the GraphQL spec.
 */
function getFieldDefinitionStrict(schema, parentType, fieldName) {
  var type = schema.getRawType(parentType);
  var queryType = schema.getQueryType();
  var isQueryType = queryType != null && schema.areEqualTypes(type, queryType);
  var hasTypeName = schema.isAbstractType(type) || schema.isObject(type);
  var schemaFieldDef;

  if (isQueryType && fieldName === SchemaMetaFieldDef.name) {
    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__schema') : null;
  } else if (isQueryType && fieldName === TypeMetaFieldDef.name) {
    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__type') : null;
  } else if (hasTypeName && fieldName === '__typename') {
    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__typename');
  } else if (hasTypeName && fieldName === '__id') {
    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__id');
  } else if (schema.isInterface(type) || schema.isObject(type)) {
    var compositeType = schema.assertCompositeType(type);

    if (schema.hasField(compositeType, fieldName)) {
      schemaFieldDef = schema.getFieldByName(compositeType, fieldName);
    } else {
      return null;
    }
  }

  return schemaFieldDef;
}
/**
 * Find the definition of a field of the specified type, first trying
 * the standard spec-compliant resolution process and falling back
 * to legacy mode that supports fat interfaces.
 */


function getFieldDefinitionLegacy(schema, parentType, fieldName, fieldAST) {
  var _schemaFieldDef;

  var schemaFieldDef = getFieldDefinitionStrict(schema, parentType, fieldName);

  if (!schemaFieldDef) {
    schemaFieldDef = getFieldDefinitionLegacyImpl(schema, parentType, fieldName, fieldAST);
  }

  return (_schemaFieldDef = schemaFieldDef) !== null && _schemaFieldDef !== void 0 ? _schemaFieldDef : null;
}
/**
 * @private
 */


function getFieldDefinitionLegacyImpl(schema, type, fieldName, fieldAST) {
  var rawType = schema.getRawType(type);

  if (schema.isAbstractType(rawType) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {
    return getName(directive) === 'fixme_fat_interface';
  })) {
    var possibleTypes = schema.getPossibleTypes(schema.assertAbstractType(rawType));
    var schemaFieldDef;

    var _iterator = (0, _createForOfIteratorHelper2["default"])(possibleTypes),
        _step;

    try {
      var _loop = function _loop() {
        var possibleType = _step.value;
        var possibleField = schema.getFieldByName(possibleType, fieldName);

        if (possibleField) {
          // Fat interface fields can have differing arguments. Try to return
          // a field with matching arguments, but still return a field if the
          // arguments do not match.
          schemaFieldDef = possibleField;

          if (fieldAST && fieldAST.arguments) {
            var argumentsAllExist = fieldAST.arguments.every(function (argument) {
              return schema.getFieldArgByName(possibleField, getName(argument)) != null;
            });

            if (argumentsAllExist) {
              return "break";
            }
          }
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ret = _loop();

        if (_ret === "break") break;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return schemaFieldDef;
  }
}
/**
 * @private
 */


function getName(ast) {
  var name = ast.name ? ast.name.value : null;

  if (typeof name !== 'string') {
    throw createCompilerError("Expected ast node to have a 'name'.", null, [ast]);
  }

  return name;
}

module.exports = {
  getFieldDefinitionLegacy: getFieldDefinitionLegacy,
  getFieldDefinitionStrict: getFieldDefinitionStrict
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var invariant = __webpack_require__(6);

var _require = __webpack_require__(31),
    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;

var INDENT = '  ';
/**
 * Converts an IR node into a GraphQL string. Custom Relay
 * extensions (directives) are not supported; to print fragments with
 * variables or fragment spreads with arguments, transform the node
 * prior to printing.
 */

function print(schema, node) {
  switch (node.kind) {
    case 'Fragment':
      return "fragment ".concat(node.name, " on ").concat(schema.getTypeString(node.type)) + printFragmentArgumentDefinitions(schema, node.argumentDefinitions) + printDirectives(schema, node.directives) + printSelections(schema, node, '', {}) + '\n';

    case 'Root':
      return "".concat(node.operation, " ").concat(node.name) + printArgumentDefinitions(schema, node.argumentDefinitions) + printDirectives(schema, node.directives) + printSelections(schema, node, '', {}) + '\n';

    case 'SplitOperation':
      return "SplitOperation ".concat(node.name, " on ").concat(schema.getTypeString(node.type)) + printSelections(schema, node, '', {}) + '\n';

    default:
      node;
       true ?  true ? invariant(false, 'IRPrinter: Unsupported IR node `%s`.', node.kind) : undefined : undefined;
  }
}

function printSelections(schema, node, indent, options) {
  var selections = node.selections;

  if (selections == null) {
    return '';
  }

  var printed = selections.map(function (selection) {
    return printSelection(schema, selection, indent, options);
  });
  return printed.length ? " {\n".concat(indent + INDENT).concat(printed.join('\n' + indent + INDENT), "\n").concat(indent).concat((options === null || options === void 0 ? void 0 : options.isClientExtension) === true ? '# ' : '', "}") : '';
}
/**
 * Prints a field without subselections.
 */


function printField(schema, field, options) {
  var _options$parentDirect;

  var parentDirectives = (_options$parentDirect = options === null || options === void 0 ? void 0 : options.parentDirectives) !== null && _options$parentDirect !== void 0 ? _options$parentDirect : '';
  var isClientExtension = (options === null || options === void 0 ? void 0 : options.isClientExtension) === true;
  return (isClientExtension ? '# ' : '') + (field.alias === field.name ? field.name : field.alias + ': ' + field.name) + printArguments(schema, field.args) + parentDirectives + printDirectives(schema, field.directives) + printHandles(schema, field);
}

function printSelection(schema, selection, indent, options) {
  var _options$parentDirect2;

  var str;
  var parentDirectives = (_options$parentDirect2 = options === null || options === void 0 ? void 0 : options.parentDirectives) !== null && _options$parentDirect2 !== void 0 ? _options$parentDirect2 : '';
  var isClientExtension = (options === null || options === void 0 ? void 0 : options.isClientExtension) === true;

  if (selection.kind === 'LinkedField') {
    str = printField(schema, selection, {
      parentDirectives: parentDirectives,
      isClientExtension: isClientExtension
    });
    str += printSelections(schema, selection, indent + INDENT, {
      isClientExtension: isClientExtension
    });
  } else if (selection.kind === 'ModuleImport') {
    str = selection.selections.map(function (matchSelection) {
      return printSelection(schema, matchSelection, indent, {
        parentDirectives: parentDirectives,
        isClientExtension: isClientExtension
      });
    }).join('\n' + indent + INDENT);
  } else if (selection.kind === 'ScalarField') {
    str = printField(schema, selection, {
      parentDirectives: parentDirectives,
      isClientExtension: isClientExtension
    });
  } else if (selection.kind === 'InlineFragment') {
    str = '';

    if (isClientExtension) {
      str += '# ';
    }

    str += '... on ' + schema.getTypeString(selection.typeCondition);
    str += parentDirectives;
    str += printDirectives(schema, selection.directives);
    str += printSelections(schema, selection, indent + INDENT, {
      isClientExtension: isClientExtension
    });
  } else if (selection.kind === 'FragmentSpread') {
    str = '';

    if (isClientExtension) {
      str += '# ';
    }

    str += '...' + selection.name;
    str += parentDirectives;
    str += printFragmentArguments(schema, selection.args);
    str += printDirectives(schema, selection.directives);
  } else if (selection.kind === 'InlineDataFragmentSpread') {
    str = "# ".concat(selection.name, " @inline") + "\n".concat(indent).concat(INDENT, "...") + parentDirectives + printSelections(schema, selection, indent + INDENT, {});
  } else if (selection.kind === 'Condition') {
    var value = printValue(schema, selection.condition, null); // For Flow

    !(value != null) ?  true ? invariant(false, 'IRPrinter: Expected a variable for condition, got a literal `null`.') : undefined : void 0;
    var condStr = selection.passingValue ? ' @include' : ' @skip';
    condStr += '(if: ' + value + ')';
    condStr += parentDirectives; // For multi-selection conditions, pushes the condition down to each

    var subSelections = selection.selections.map(function (sel) {
      return printSelection(schema, sel, indent, {
        parentDirectives: condStr,
        isClientExtension: isClientExtension
      });
    });
    str = subSelections.join('\n' + indent + INDENT);
  } else if (selection.kind === 'Stream') {
    var streamStr = parentDirectives;
    streamStr += " @stream(label: \"".concat(selection.label, "\"");

    if (selection["if"] !== null) {
      var _printValue;

      streamStr += ", if: ".concat((_printValue = printValue(schema, selection["if"], null)) !== null && _printValue !== void 0 ? _printValue : '');
    }

    if (selection.initialCount !== null) {
      var _printValue2;

      streamStr += ", initial_count: ".concat((_printValue2 = printValue(schema, selection.initialCount, null)) !== null && _printValue2 !== void 0 ? _printValue2 : '');
    }

    if (selection.useCustomizedBatch !== null) {
      var _printValue3;

      streamStr += ", use_customized_batch: ".concat((_printValue3 = printValue(schema, selection.useCustomizedBatch, null)) !== null && _printValue3 !== void 0 ? _printValue3 : 'false');
    }

    streamStr += ')';

    var _subSelections = selection.selections.map(function (sel) {
      return printSelection(schema, sel, indent, {
        parentDirectives: streamStr,
        isClientExtension: isClientExtension
      });
    });

    str = _subSelections.join('\n' + INDENT);
  } else if (selection.kind === 'Defer') {
    var deferStr = parentDirectives;
    deferStr += " @defer(label: \"".concat(selection.label, "\"");

    if (selection["if"] !== null) {
      var _printValue4;

      deferStr += ", if: ".concat((_printValue4 = printValue(schema, selection["if"], null)) !== null && _printValue4 !== void 0 ? _printValue4 : '');
    }

    deferStr += ')';

    if (selection.selections.every(function (subSelection) {
      return subSelection.kind === 'InlineFragment' || subSelection.kind === 'FragmentSpread';
    })) {
      var _subSelections2 = selection.selections.map(function (sel) {
        return printSelection(schema, sel, indent, {
          parentDirectives: deferStr,
          isClientExtension: isClientExtension
        });
      });

      str = _subSelections2.join('\n' + INDENT);
    } else {
      str = '...' + deferStr;
      str += printSelections(schema, selection, indent + INDENT, {
        isClientExtension: isClientExtension
      });
    }
  } else if (selection.kind === 'ClientExtension') {
    !(isClientExtension === false) ?  true ? invariant(false, 'IRPrinter: Did not expect to encounter a ClientExtension node ' + 'as a descendant of another ClientExtension node.') : undefined : void 0;
    str = '# Client-only selections:\n' + indent + INDENT + selection.selections.map(function (sel) {
      return printSelection(schema, sel, indent, {
        parentDirectives: parentDirectives,
        isClientExtension: true
      });
    }).join('\n' + indent + INDENT);
  } else {
    selection;
     true ?  true ? invariant(false, 'IRPrinter: Unknown selection kind `%s`.', selection.kind) : undefined : undefined;
  }

  return str;
}

function printArgumentDefinitions(schema, argumentDefinitions) {
  var printed = argumentDefinitions.map(function (def) {
    var str = "$".concat(def.name, ": ").concat(schema.getTypeString(def.type));

    if (def.defaultValue != null) {
      str += ' = ' + printLiteral(schema, def.defaultValue, def.type);
    }

    return str;
  });
  return printed.length ? "(\n".concat(INDENT).concat(printed.join('\n' + INDENT), "\n)") : '';
}

function printFragmentArgumentDefinitions(schema, argumentDefinitions) {
  var printed;
  argumentDefinitions.forEach(function (def) {
    if (def.kind !== 'LocalArgumentDefinition') {
      return;
    }

    printed = printed || [];
    var str = "".concat(def.name, ": {type: \"").concat(schema.getTypeString(def.type), "\"");

    if (def.defaultValue != null) {
      str += ", defaultValue: ".concat(printLiteral(schema, def.defaultValue, def.type));
    }

    str += '}'; // $FlowFixMe[incompatible-use]

    printed.push(str);
  });
  return printed && printed.length ? " @argumentDefinitions(\n".concat(INDENT).concat(printed.join('\n' + INDENT), "\n)") : '';
}

function printHandles(schema, field) {
  if (!field.handles) {
    return '';
  }

  var printed = field.handles.map(function (handle) {
    // For backward compatibility.
    var key = handle.key === DEFAULT_HANDLE_KEY ? '' : ", key: \"".concat(handle.key, "\"");
    var filters = handle.filters == null ? '' : ", filters: ".concat(JSON.stringify(Array.from(handle.filters).sort()));
    var handleArgs = handle.handleArgs == null ? '' : ", handleArgs: ".concat(printArguments(schema, handle.handleArgs));
    return "@__clientField(handle: \"".concat(handle.name, "\"").concat(key).concat(filters).concat(handleArgs, ")");
  });
  return printed.length ? ' ' + printed.join(' ') : '';
}

function printDirectives(schema, directives) {
  var printed = directives.map(function (directive) {
    return '@' + directive.name + printArguments(schema, directive.args);
  });
  return printed.length ? ' ' + printed.join(' ') : '';
}

function printFragmentArguments(schema, args) {
  var printedArgs = printArguments(schema, args);

  if (!printedArgs.length) {
    return '';
  }

  return " @arguments".concat(printedArgs);
}

function printArguments(schema, args) {
  var printed = [];
  args.forEach(function (arg) {
    var printedValue = printValue(schema, arg.value, arg.type);

    if (printedValue != null) {
      printed.push(arg.name + ': ' + printedValue);
    }
  });
  return printed.length ? '(' + printed.join(', ') + ')' : '';
}

function printValue(schema, value, type) {
  if (type != null && schema.isNonNull(type)) {
    type = schema.getNullableType(type);
  }

  if (value.kind === 'Variable') {
    return '$' + value.variableName;
  } else if (value.kind === 'ObjectValue') {
    var inputType = type != null ? schema.asInputObjectType(type) : null;
    var pairs = value.fields.map(function (field) {
      var fieldConfig = inputType != null ? schema.hasField(inputType, field.name) ? schema.getFieldConfig(schema.expectField(inputType, field.name)) : null : null;
      var innerValue = printValue(schema, field.value, fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.type);
      return innerValue == null ? null : field.name + ': ' + innerValue;
    }).filter(Boolean);
    return '{' + pairs.join(', ') + '}';
  } else if (value.kind === 'ListValue') {
    !(type && schema.isList(type)) ?  true ? invariant(false, 'GraphQLIRPrinter: Need a type in order to print arrays.') : undefined : void 0;
    var innerType = schema.getListItemType(type);
    return "[".concat(value.items.map(function (i) {
      return printValue(schema, i, innerType);
    }).join(', '), "]");
  } else if (value.value != null) {
    return printLiteral(schema, value.value, type);
  } else {
    return null;
  }
}

function printLiteral(schema, value, type) {
  if (value == null) {
    var _JSON$stringify;

    return (_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'null';
  }

  if (type != null && schema.isNonNull(type)) {
    type = schema.getNullableType(type);
  }

  if (type && schema.isEnum(type)) {
    var _JSON$stringify2;

    var result = schema.serialize(schema.assertEnumType(type), value);

    if (result == null && typeof value === 'string') {
      // For backwards compatibility, print invalid input values as-is. This
      // can occur with literals defined as an @argumentDefinitions
      // defaultValue.
      result = value;
    }

    !(typeof result === 'string') ?  true ? invariant(false, 'IRPrinter: Expected value of type %s to be a valid enum value, got `%s`.', schema.getTypeString(type), (_JSON$stringify2 = JSON.stringify(value)) !== null && _JSON$stringify2 !== void 0 ? _JSON$stringify2 : 'null') : undefined : void 0;
    return result;
  } else if (type && (schema.isId(type) || schema.isInt(type))) {
    var _JSON$stringify3;

    return (_JSON$stringify3 = JSON.stringify(value)) !== null && _JSON$stringify3 !== void 0 ? _JSON$stringify3 : '';
  } else if (type && schema.isScalar(type)) {
    var _JSON$stringify4;

    var _result = schema.serialize(schema.assertScalarType(type), value);

    return (_JSON$stringify4 = JSON.stringify(_result)) !== null && _JSON$stringify4 !== void 0 ? _JSON$stringify4 : '';
  } else if (Array.isArray(value)) {
    !(type && schema.isList(type)) ?  true ? invariant(false, 'IRPrinter: Need a type in order to print arrays.') : undefined : void 0;
    var itemType = schema.getListItemType(type);
    return '[' + value.map(function (item) {
      return printLiteral(schema, item, itemType);
    }).join(', ') + ']';
  } else if (type && schema.isList(type) && value != null) {
    // Not an array, but still a list. Treat as list-of-one as per spec 3.1.7:
    // http://facebook.github.io/graphql/October2016/#sec-Lists
    return printLiteral(schema, value, schema.getListItemType(type));
  } else if (typeof value === 'object' && value != null) {
    var fields = [];
    !(type && schema.isInputObject(type)) ?  true ? invariant(false, 'IRPrinter: Need an InputObject type to print objects.') : undefined : void 0;
    var inputType = schema.assertInputObjectType(type);

    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        var fieldConfig = schema.getFieldConfig(schema.expectField(inputType, key));
        fields.push(key + ': ' + printLiteral(schema, value[key], fieldConfig.type));
      }
    }

    return '{' + fields.join(', ') + '}';
  } else {
    var _JSON$stringify5;

    return (_JSON$stringify5 = JSON.stringify(value)) !== null && _JSON$stringify5 !== void 0 ? _JSON$stringify5 : 'null';
  }
}

module.exports = {
  print: print,
  printField: printField,
  printArguments: printArguments,
  printDirectives: printDirectives
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


function argumentContainsVariables(arg) {
  if (arg == null) {
    return false;
  }

  switch (arg.kind) {
    case 'Variable':
      return true;

    case 'Literal':
      return false;

    case 'ListValue':
      return arg.items.some(argumentContainsVariables);

    case 'ObjectValue':
      return arg.fields.some(argumentContainsVariables);

    default:
      arg.kind;
      return false;
  }
}

module.exports = argumentContainsVariables;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

function sortObjectByKey(obj) {
  if (obj == null) {
    return obj;
  }

  var result = {};

  var _iterator = (0, _createForOfIteratorHelper2["default"])(Object.keys(obj).sort()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _key = _step.value;
      result[_key] = obj[_key];
    } // $FlowFixMe[incompatible-return]

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return result;
}

module.exports = sortObjectByKey;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error

/**
 * Marks a string of code as code to be replaced later.
 */

function moduleDependency(code) {
  return "@@MODULE_START@@".concat(code, "@@MODULE_END@@");
}
/**
 * After JSON.stringify'ing some code that contained parts marked with `mark()`,
 * this post-processes the JSON to convert the marked code strings to raw code.
 *
 * Example:
 *   CodeMarker.postProcess(
 *     JSON.stringify({code: CodeMarker.mark('alert(1)')})
 *   )
 */


function postProcess(json, printModule) {
  return json.replace(/"@@MODULE_START@@(.*?)@@MODULE_END@@"/g, function (_, moduleName) {
    return printModule(moduleName);
  });
}
/**
 * Transforms a value such that any transitive CodeMarker strings are replaced
 * with the value of the named module in the given module map.
 */


function transform(node, moduleMap) {
  if (node == null) {
    return node;
  } else if (Array.isArray(node)) {
    return node.map(function (item) {
      return transform(item, moduleMap);
    });
  } else if (typeof node === 'object') {
    var next = {};
    Object.keys(node).forEach(function (key) {
      next[key] = transform(node[key], moduleMap);
    });
    return next;
  } else if (typeof node === 'string') {
    var match = /^@@MODULE_START@@(.*?)@@MODULE_END@@$/.exec(node);

    if (match != null) {
      var moduleName = match[1];

      if (moduleMap.hasOwnProperty(moduleName)) {
        return moduleMap[moduleName];
      } else {
        throw new Error("Could not find a value for CodeMarker value '".concat(moduleName, "', ") + 'make sure to supply one in the module mapping.');
      }
    } else if (node.indexOf('@@MODULE_START') >= 0) {
      throw new Error("Found unprocessed CodeMarker value '".concat(node, "'."));
    }

    return node;
  } else {
    // mixed
    return node;
  }
}

module.exports = {
  moduleDependency: moduleDependency,
  postProcess: postProcess,
  transform: transform
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var invariant = __webpack_require__(6);

/**
 * Generates an identifier for an argument value. The identifier is based on the
 * structure/order of items and keys in the value.
 */
function getIdentifierForArgumentValue(value) {
  switch (value.kind) {
    case 'Variable':
      return {
        variable: value.variableName
      };

    case 'Literal':
      return {
        value: value.value
      };

    case 'ListValue':
      return {
        list: value.items.map(function (item) {
          return getIdentifierForArgumentValue(item);
        })
      };

    case 'ObjectValue':
      return {
        object: value.fields.map(function (field) {
          return {
            name: field.name,
            value: getIdentifierForArgumentValue(field.value)
          };
        })
      };

    default:
       true ?  true ? invariant(false, 'getIdentifierForArgumentValue(): Unsupported AST kind `%s`.', value.kind) : undefined : undefined;
  }
}

module.exports = getIdentifierForArgumentValue;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error

/**
 * Based on implementations by Gary Court and Austin Appleby, 2011, MIT.
 * @preserve-header
 */


var BASE62 = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
/**
 * @param {string} key A UTF-16 or ASCII string
 * @return {string} a base62 murmur hash
 */

function murmurHash(str) {
  /* eslint-disable no-bitwise */
  var length = str.length;
  var rem = length & 3;
  var len = length ^ rem;
  var h = 0;
  var i = 0;
  var k;

  while (i !== len) {
    var ch4 = str.charCodeAt(i + 3);
    k = str.charCodeAt(i) ^ str.charCodeAt(i + 1) << 8 ^ str.charCodeAt(i + 2) << 16 ^ (ch4 & 0xff) << 24 ^ (ch4 & 0xff00) >> 8;
    i += 4;
    k = k * 0x2d51 + (k & 0xffff) * 0xcc9e0000 >>> 0;
    k = k << 15 | k >>> 17;
    k = k * 0x3593 + (k & 0xffff) * 0x1b870000 >>> 0;
    h ^= k;
    h = h << 13 | h >>> 19;
    h = h * 5 + 0xe6546b64 >>> 0;
  }

  k = 0;

  switch (rem) {
    /* eslint-disable no-fallthrough */
    case 3:
      k ^= str.charCodeAt(len + 2) << 16;

    case 2:
      k ^= str.charCodeAt(len + 1) << 8;

    case 1:
      k ^= str.charCodeAt(len);
      k = k * 0x2d51 + (k & 0xffff) * 0xcc9e0000 >>> 0;
      k = k << 15 | k >>> 17;
      k = k * 0x3593 + (k & 0xffff) * 0x1b870000 >>> 0;
      h ^= k;
  }

  h ^= length;
  h ^= h >>> 16;
  h = h * 0xca6b + (h & 0xffff) * 0x85eb0000 >>> 0;
  h ^= h >>> 13;
  h = h * 0xae35 + (h & 0xffff) * 0xc2b20000 >>> 0;
  h ^= h >>> 16;
  h >>>= 0;

  if (!h) {
    return '0';
  }

  var s = '';

  while (h) {
    var d = h % 62;
    s = BASE62[d] + s;
    h = (h - d) / 62;
  }

  return s;
}

module.exports = murmurHash;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var invariant = __webpack_require__(6);

var _require = __webpack_require__(1),
    eachWithCombinedError = _require.eachWithCombinedError;

/**
 * @public
 *
 * Helper for writing AST validators that shares the same logic with
 * the transfomer
 *
 */
function validate(context, visitor, stateInitializer) {
  var validator = new Validator(context, visitor);
  eachWithCombinedError(context.documents(), function (prevNode) {
    if (stateInitializer === undefined) {
      validator.visit(prevNode, undefined);
    } else {
      var _state = stateInitializer(prevNode);

      if (_state != null) {
        validator.visit(prevNode, _state);
      }
    }
  });
}
/**
 * @internal
 */


var Validator = /*#__PURE__*/function () {
  function Validator(context, visitor) {
    this._context = context;
    this._states = [];
    this._visitor = visitor;
  }

  var _proto = Validator.prototype;

  _proto.getContext = function getContext() {
    return this._context;
  };

  _proto.visit = function visit(node, state) {
    this._states.push(state);

    this._visit(node);

    this._states.pop();
  };

  _proto.traverse = function traverse(node, state) {
    this._states.push(state);

    this._traverse(node);

    this._states.pop();
  };

  _proto._visit = function _visit(node) {
    var nodeVisitor = this._visitor[node.kind];

    if (nodeVisitor) {
      // If a handler for the kind is defined, it is responsible for calling
      // `traverse` to transform children as necessary.
      var _state2 = this._getState();

      nodeVisitor.call(this, node, _state2);
      return;
    } // Otherwise traverse is called automatically.


    this._traverse(node);
  };

  _proto._traverse = function _traverse(prevNode) {
    switch (prevNode.kind) {
      case 'Argument':
        this._traverseChildren(prevNode, null, ['value']);

        break;

      case 'Literal':
      case 'LocalArgumentDefinition':
      case 'RootArgumentDefinition':
      case 'Variable':
        break;

      case 'Defer':
        this._traverseChildren(prevNode, ['selections'], ['if']);

        break;

      case 'Stream':
        this._traverseChildren(prevNode, ['selections'], ['if', 'initialCount']);

        break;

      case 'ClientExtension':
        this._traverseChildren(prevNode, ['selections']);

        break;

      case 'Directive':
        this._traverseChildren(prevNode, ['args']);

        break;

      case 'ModuleImport':
        this._traverseChildren(prevNode, ['selections']);

        break;

      case 'FragmentSpread':
      case 'ScalarField':
        this._traverseChildren(prevNode, ['args', 'directives']);

        break;

      case 'InlineDataFragmentSpread':
        this._traverseChildren(prevNode, ['selections']);

        break;

      case 'LinkedField':
        this._traverseChildren(prevNode, ['args', 'directives', 'selections']);

        break;

      case 'ListValue':
        this._traverseChildren(prevNode, ['items']);

        break;

      case 'ObjectFieldValue':
        this._traverseChildren(prevNode, null, ['value']);

        break;

      case 'ObjectValue':
        this._traverseChildren(prevNode, ['fields']);

        break;

      case 'Condition':
        this._traverseChildren(prevNode, ['directives', 'selections'], ['condition']);

        break;

      case 'InlineFragment':
        this._traverseChildren(prevNode, ['directives', 'selections']);

        break;

      case 'Fragment':
      case 'Root':
        this._traverseChildren(prevNode, ['argumentDefinitions', 'directives', 'selections']);

        break;

      case 'Request':
        this._traverseChildren(prevNode, null, ['fragment', 'root']);

        break;

      case 'SplitOperation':
        this._traverseChildren(prevNode, ['selections']);

        break;

      default:
        prevNode;
         true ?  true ? invariant(false, 'IRValidator: Unknown kind `%s`.', prevNode.kind) : undefined : undefined;
    }
  };

  _proto._traverseChildren = function _traverseChildren(prevNode, pluralKeys, singularKeys) {
    var _this = this;

    pluralKeys && pluralKeys.forEach(function (key) {
      var prevItems = prevNode[key];

      if (!prevItems) {
        return;
      }

      !Array.isArray(prevItems) ?  true ? invariant(false, 'IRValidator: Expected data for `%s` to be an array, got `%s`.', key, prevItems) : undefined : void 0;
      prevItems.forEach(function (prevItem) {
        return _this._visit(prevItem);
      });
    });
    singularKeys && singularKeys.forEach(function (key) {
      var prevItem = prevNode[key];

      if (!prevItem) {
        return;
      }

      _this._visit(prevItem);
    });
  };

  _proto._getState = function _getState() {
    !this._states.length ?  true ? invariant(false, 'IRValidator: Expected a current state to be set but found none. ' + 'This is usually the result of mismatched number of pushState()/popState() ' + 'calls.') : undefined : void 0;
    return this._states[this._states.length - 1];
  };

  return Validator;
}();

module.exports = {
  validate: validate
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * 
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var IRTransformer = __webpack_require__(3);

var areEqualArgValues = __webpack_require__(89);

var getIdentifierForSelection = __webpack_require__(41);

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

/**
 * Transform that flattens inline fragments, fragment spreads, and conditionals.
 *
 * Inline fragments are inlined (replaced with their selections) when:
 * - The fragment type matches the type of its parent, and its `isForCodegen`,
 *   or if it's for printing, there is no directive on the inline fragment.
 */
function flattenTransformImpl(context, options) {
  var state = {
    isForCodegen: !!(options && options.isForCodegen),
    parentType: null
  };
  var visitorFn = memoizedFlattenSelection(new Map());
  return IRTransformer.transform(context, {
    Condition: visitorFn,
    Defer: visitorFn,
    Fragment: visitorFn,
    InlineDataFragmentSpread: visitorFn,
    InlineFragment: visitorFn,
    LinkedField: visitorFn,
    ModuleImport: visitorFn,
    Root: visitorFn,
    SplitOperation: visitorFn
  }, function () {
    return state;
  });
}

function memoizedFlattenSelection(cache) {
  return function flattenSelectionsFn(node, state) {
    // $FlowFixMe[incompatible-use]
    var context = this.getContext();
    var nodeCache = cache.get(node);

    if (nodeCache == null) {
      nodeCache = new Map();
      cache.set(node, nodeCache);
    } // Determine the current type.


    var parentType = state.parentType;
    var result = nodeCache.get(parentType);

    if (result != null) {
      return result;
    }

    var type = node.kind === 'LinkedField' || node.kind === 'Fragment' || node.kind === 'Root' || node.kind === 'SplitOperation' ? node.type : node.kind === 'InlineFragment' ? node.typeCondition : parentType;

    if (type == null) {
      throw createCompilerError('FlattenTransform: Expected a parent type.', [node.loc]);
    } // Flatten the selections in this node, creating a new node with flattened
    // selections if possible, then deeply traverse the flattened node, while
    // keeping track of the parent type.


    var nextSelections = new Map();
    var hasFlattened = flattenSelectionsInto(context.getSchema(), nextSelections, node, state, type);
    var flattenedNode = hasFlattened ? (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
      selections: Array.from(nextSelections.values())
    }) : node;
    state.parentType = type; // $FlowFixMe[incompatible-use]

    var deeplyFlattenedNode = this.traverse(flattenedNode, state);
    state.parentType = parentType;
    nodeCache.set(parentType, deeplyFlattenedNode);
    return deeplyFlattenedNode;
  };
}
/**
 * @private
 */


function flattenSelectionsInto(schema, flattenedSelections, node, state, type) {
  var hasFlattened = false;
  node.selections.forEach(function (selection) {
    if (selection.kind === 'InlineFragment' && shouldFlattenInlineFragment(schema, selection, state, type)) {
      hasFlattened = true;
      flattenSelectionsInto(schema, flattenedSelections, selection, state, type);
      return;
    }

    var nodeIdentifier = getIdentifierForSelection(schema, selection);
    var flattenedSelection = flattenedSelections.get(nodeIdentifier); // If this selection hasn't been seen before, keep track of it.

    if (!flattenedSelection) {
      flattenedSelections.set(nodeIdentifier, selection);
      return;
    } // Otherwise a similar selection exists which should be merged.


    hasFlattened = true;

    if (flattenedSelection.kind === 'InlineFragment') {
      if (selection.kind !== 'InlineFragment') {
        throw createCompilerError("FlattenTransform: Expected an InlineFragment, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, flattenedSelection), {}, {
        selections: mergeSelections(schema, flattenedSelection, selection, state, selection.typeCondition)
      }));
    } else if (flattenedSelection.kind === 'Condition') {
      if (selection.kind !== 'Condition') {
        throw createCompilerError("FlattenTransform: Expected a Condition, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, flattenedSelection), {}, {
        selections: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } else if (flattenedSelection.kind === 'ClientExtension') {
      if (selection.kind !== 'ClientExtension') {
        throw createCompilerError("FlattenTransform: Expected a ClientExtension, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, flattenedSelection), {}, {
        selections: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } else if (flattenedSelection.kind === 'FragmentSpread') {// Ignore duplicate fragment spreads.
    } else if (flattenedSelection.kind === 'ModuleImport') {
      if (selection.kind !== 'ModuleImport') {
        throw createCompilerError("FlattenTransform: Expected a ModuleImport, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      if (selection.name !== flattenedSelection.name || selection.module !== flattenedSelection.module || selection.key !== flattenedSelection.key) {
        throw createUserError('Found conflicting @module selections: use a unique alias on the ' + 'parent fields.', [selection.loc, flattenedSelection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, flattenedSelection), {}, {
        selections: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } else if (flattenedSelection.kind === 'Defer') {
      if (selection.kind !== 'Defer') {
        throw createCompilerError("FlattenTransform: Expected a Defer, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({
        kind: 'Defer'
      }, flattenedSelection), {}, {
        selections: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } else if (flattenedSelection.kind === 'Stream') {
      if (selection.kind !== 'Stream') {
        throw createCompilerError("FlattenTransform: Expected a Stream, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({
        kind: 'Stream'
      }, flattenedSelection), {}, {
        selections: mergeSelections(schema, flattenedSelection, selection, state, type)
      }));
    } else if (flattenedSelection.kind === 'LinkedField') {
      if (selection.kind !== 'LinkedField') {
        throw createCompilerError("FlattenTransform: Expected a LinkedField, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      assertUniqueArgsForAlias(selection, flattenedSelection); // NOTE: not using object spread here as this code is pretty hot

      flattenedSelections.set(nodeIdentifier, {
        kind: 'LinkedField',
        alias: flattenedSelection.alias,
        args: flattenedSelection.args,
        connection: flattenedSelection.connection || selection.connection,
        directives: flattenedSelection.directives,
        handles: mergeHandles(flattenedSelection, selection),
        loc: flattenedSelection.loc,
        metadata: flattenedSelection.metadata,
        name: flattenedSelection.name,
        selections: mergeSelections(schema, flattenedSelection, selection, state, selection.type),
        type: flattenedSelection.type
      });
    } else if (flattenedSelection.kind === 'ScalarField') {
      if (selection.kind !== 'ScalarField') {
        throw createCompilerError("FlattenTransform: Expected a ScalarField, got a '".concat(selection.kind, "'"), [selection.loc]);
      }

      assertUniqueArgsForAlias(selection, flattenedSelection);

      if (selection.handles && selection.handles.length > 0) {
        flattenedSelections.set(nodeIdentifier, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({
          kind: 'ScalarField'
        }, flattenedSelection), {}, {
          handles: mergeHandles(selection, flattenedSelection)
        }));
      }
    } else if (flattenedSelection.kind === 'InlineDataFragmentSpread') {
      throw createCompilerError('FlattenTransform: did not expect an InlineDataFragmentSpread node. ' + 'Only expecting InlineDataFragmentSpread in reader ASTs and this ' + 'transform to run only on normalization ASTs.', [selection.loc]);
    } else {
      flattenedSelection.kind;
      throw createCompilerError("FlattenTransform: Unknown kind '".concat(flattenedSelection.kind, "'"));
    }
  });
  return hasFlattened;
}
/**
 * @private
 */


function mergeSelections(schema, nodeA, nodeB, state, type) {
  var flattenedSelections = new Map();
  flattenSelectionsInto(schema, flattenedSelections, nodeA, state, type);
  flattenSelectionsInto(schema, flattenedSelections, nodeB, state, type);
  return Array.from(flattenedSelections.values());
}
/**
 * @private
 * TODO(T19327202) This is redundant with OverlappingFieldsCanBeMergedRule once
 * it can be enabled.
 */


function assertUniqueArgsForAlias(field, otherField) {
  if (!areEqualFields(field, otherField)) {
    throw createUserError('Expected all fields on the same parent with the name or alias ' + "'".concat(field.alias, "' to have the same name and arguments."), [field.loc, otherField.loc]);
  }
}
/**
 * @private
 */


function shouldFlattenInlineFragment(schema, fragment, state, type) {
  return schema.areEqualTypes(fragment.typeCondition, schema.getRawType(type)) && (state.isForCodegen || fragment.directives.length === 0);
}
/**
 * @private
 *
 * Verify that two fields are equal in all properties other than their
 * selections.
 */


function areEqualFields(thisField, thatField) {
  return thisField.kind === thatField.kind && thisField.name === thatField.name && thisField.alias === thatField.alias && areEqualArgs(thisField.args, thatField.args);
}
/**
 * Verify that two sets of arguments are equivalent - same argument names
 * and values. Notably this ignores the types of arguments and values, which
 * may not always be inferred identically.
 */


function areEqualArgs(thisArgs, thatArgs) {
  return thisArgs.length === thatArgs.length && thisArgs.every(function (thisArg, index) {
    var thatArg = thatArgs[index];
    return thisArg.name === thatArg.name && thisArg.value.kind === thatArg.value.kind && thisArg.value.variableName === thatArg.value.variableName && areEqualArgValues(thisArg.value.value, thatArg.value.value);
  });
}
/**
 * @private
 */


function mergeHandles(nodeA, nodeB) {
  if (!nodeA.handles) {
    return nodeB.handles;
  }

  if (!nodeB.handles) {
    return nodeA.handles;
  }

  var uniqueItems = new Map();
  nodeA.handles // $FlowFixMe[incompatible-use]
  .concat(nodeB.handles) // $FlowFixMe[incompatible-use]
  .forEach(function (item) {
    return uniqueItems.set(item.name + item.key, item);
  }); // $FlowFixMe[incompatible-return]

  return Array.from(uniqueItems.values());
}

function transformWithOptions(options) {
  return function flattenTransform(context) {
    return flattenTransformImpl(context, options);
  };
}

module.exports = {
  transformWithOptions: transformWithOptions
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var invariant = __webpack_require__(6);

var _require = __webpack_require__(33),
    printArguments = _require.printArguments,
    printDirectives = _require.printDirectives;

/**
 * Generates an identifier that is unique to a given selection: the alias for
 * fields, the type for inline fragments, and a summary of the condition
 * variable and passing value for conditions.
 */
function getIdentifierForSelection(schema, node) {
  if (node.kind === 'LinkedField' || node.kind === 'ScalarField') {
    return 'Field: ' + node.directives.length === 0 ? node.alias : node.alias + printDirectives(schema, node.directives);
  } else if (node.kind === 'FragmentSpread') {
    return 'FragmentSpread:' + node.args.length === 0 ? node.name : node.name + printArguments(schema, node.args);
  } else if (node.kind === 'ModuleImport') {
    return 'ModuleImport:';
  } else if (node.kind === 'Defer') {
    return 'Defer:' + node.label;
  } else if (node.kind === 'Stream') {
    return 'Stream:' + node.label;
  } else if (node.kind === 'InlineFragment') {
    return 'InlineFragment:' + schema.getTypeString(node.typeCondition) + printDirectives(schema, node.directives);
  } else if (node.kind === 'ClientExtension') {
    return 'ClientExtension:';
  } else if (node.kind === 'InlineDataFragmentSpread') {
    return 'InlineDataFragment:' + node.name;
  } else if (node.kind === 'Condition') {
    return 'Condition:' + (node.condition.kind === 'Variable' ? '$' + node.condition.variableName : String(node.condition.value)) + String(node.passingValue);
  } else {
     true ?  true ? invariant(false, 'getIdentifierForSelection: Unexpected kind `%s`.', node.kind) : undefined : undefined;
  }
}

module.exports = getIdentifierForSelection;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


function hasUnaliasedSelection(field, fieldName) {
  return field.selections.some(function (selection) {
    return selection.kind === 'ScalarField' && selection.alias === fieldName && selection.name === fieldName;
  });
}

module.exports = {
  hasUnaliasedSelection: hasUnaliasedSelection
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var IRTransformer = __webpack_require__(3);

var invariant = __webpack_require__(6);

var joinArgumentDefinitions = __webpack_require__(94);

var _require = __webpack_require__(1),
    createUserError = _require.createUserError;

/**
 * A transform that inlines fragment spreads with the @relay(mask: false)
 * directive.
 */
function maskTransform(context) {
  return IRTransformer.transform(context, {
    FragmentSpread: visitFragmentSpread,
    Fragment: visitFragment
  }, function () {
    return {
      reachableArguments: []
    };
  });
}

function visitFragment(fragment, state) {
  // $FlowFixMe[incompatible-use]
  var result = this.traverse(fragment, state);

  if (state.reachableArguments.length === 0) {
    return result;
  }

  var joinedArgumentDefinitions = joinArgumentDefinitions( // $FlowFixMe[incompatible-use]
  this.getContext().getSchema(), fragment, state.reachableArguments, '@relay(unmask: true)');
  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, result), {}, {
    argumentDefinitions: joinedArgumentDefinitions
  });
}

function visitFragmentSpread(fragmentSpread, state) {
  if (!isUnmaskedSpread(fragmentSpread)) {
    return fragmentSpread;
  }

  !(fragmentSpread.args.length === 0) ?  true ? invariant(false, 'MaskTransform: Cannot unmask fragment spread `%s` with ' + 'arguments. Use the `ApplyFragmentArgumentTransform` before flattening', fragmentSpread.name) : undefined : void 0; // $FlowFixMe[incompatible-use]

  var context = this.getContext();
  var fragment = context.getFragment(fragmentSpread.name);
  var result = {
    kind: 'InlineFragment',
    directives: fragmentSpread.directives,
    loc: {
      kind: 'Derived',
      source: fragmentSpread.loc
    },
    metadata: fragmentSpread.metadata,
    selections: fragment.selections,
    typeCondition: fragment.type
  };

  if (fragment.directives.length > 0) {
    throw new createUserError('Cannot use @relay(mask: false) on fragment spreads for fragments ' + 'with directives.', [fragmentSpread.loc, fragment.directives[0].loc]);
  }

  var localArgDef = fragment.argumentDefinitions.find(function (argDef) {
    return argDef.kind === 'LocalArgumentDefinition';
  });

  if (localArgDef != null) {
    throw createUserError('MaskTransform: Cannot use @relay(mask: false) on fragment spread ' + 'because the fragment definition uses @argumentDefinitions.', [fragmentSpread.loc, localArgDef.loc]);
  } // Note: defer validating arguments to the containing fragment in order
  // to list all invalid variables/arguments instead of only one.


  var _iterator = (0, _createForOfIteratorHelper2["default"])(fragment.argumentDefinitions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var argDef = _step.value;
      state.reachableArguments.push(argDef);
    } // $FlowFixMe[incompatible-use]

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return this.traverse(result, state);
}
/**
 * @private
 */


function isUnmaskedSpread(spread) {
  return Boolean(spread.metadata && spread.metadata.mask === false);
}

module.exports = {
  transform: maskTransform
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var IRTransformer = __webpack_require__(3);

var getLiteralArgumentValues = __webpack_require__(20);

var getNormalizationOperationName = __webpack_require__(45);

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError,
    createUserError = _require.createUserError;

var _require2 = __webpack_require__(11),
    getModuleComponentKey = _require2.getModuleComponentKey,
    getModuleOperationKey = _require2.getModuleOperationKey;

var SUPPORTED_ARGUMENT_NAME = 'supported';
var JS_FIELD_TYPE = 'JSDependency';
var JS_FIELD_MODULE_ARG = 'module';
var JS_FIELD_ID_ARG = 'id';
var JS_FIELD_NAME = 'js';
var SCHEMA_EXTENSION = "\n  directive @match(key: String) on FIELD\n\n  directive @module(\n    name: String!\n  ) on FRAGMENT_SPREAD\n";

/**
 * This transform rewrites LinkedField nodes with @match and rewrites them
 * into `LinkedField` nodes with a `supported` argument.
 */
function matchTransform(context) {
  return IRTransformer.transform(context, {
    // TODO: type IRTransformer to allow changing result type
    FragmentSpread: visitFragmentSpread,
    LinkedField: visitLinkedField,
    InlineFragment: visitInlineFragment,
    ScalarField: visitScalarField
  }, function (node) {
    return {
      documentName: node.name,
      matchesForPath: new Map(),
      moduleKey: null,
      parentType: node.type,
      path: []
    };
  });
}

function visitInlineFragment(node, state) {
  // $FlowFixMe[incompatible-use]
  return this.traverse(node, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
    parentType: node.typeCondition
  }));
}

function visitScalarField(field) {
  // $FlowFixMe[incompatible-use]
  var context = this.getContext();
  var schema = context.getSchema();

  if (field.name === JS_FIELD_NAME) {
    var jsModuleType = schema.getTypeFromString(JS_FIELD_TYPE);

    if (jsModuleType == null || !schema.isServerType(jsModuleType)) {
      throw new createUserError("'".concat(JS_FIELD_NAME, "' should be defined on the server schema."), [field.loc]);
    }

    if (schema.isScalar(jsModuleType) && schema.areEqualTypes(schema.getRawType(field.type), jsModuleType)) {
      throw new createUserError("Direct use of the '".concat(JS_FIELD_NAME, "' field is not allowed, use ") + '@match/@module instead.', [field.loc]);
    }
  }

  return field;
}

function visitLinkedField(node, state) {
  // $FlowFixMe[incompatible-use]
  var context = this.getContext();
  var schema = context.getSchema();
  var matchDirective = node.directives.find(function (directive) {
    return directive.name === 'match';
  });
  var moduleKey = null;

  if (matchDirective != null) {
    var _getLiteralArgumentVa = getLiteralArgumentValues(matchDirective.args);

    moduleKey = _getLiteralArgumentVa.key;

    if (moduleKey != null && (typeof moduleKey !== 'string' || !moduleKey.startsWith(state.documentName))) {
      var _matchDirective$args$;

      throw createUserError("Expected the 'key' argument of @match to be a literal string starting " + "with the document name, e.g. '".concat(state.documentName, "_<localName>'."), [((_matchDirective$args$ = matchDirective.args.find(function (arg) {
        return arg.name === 'key';
      })) !== null && _matchDirective$args$ !== void 0 ? _matchDirective$args$ : matchDirective).loc]);
    }
  }

  state.path.push(node); // $FlowFixMe[incompatible-use]

  var transformedNode = this.traverse(node, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
    moduleKey: moduleKey,
    parentType: node.type
  }));
  state.path.pop();

  if (matchDirective == null) {
    return transformedNode;
  }

  var parentType = state.parentType;
  var rawType = schema.getRawType(parentType);

  if (!(schema.isInterface(rawType) || schema.isObject(rawType))) {
    throw createUserError("@match used on incompatible field '".concat(transformedNode.name, "'.") + '@match may only be used with fields whose parent type is an ' + "interface or object, got invalid type '".concat(schema.getTypeString(parentType), "'."), [node.loc]);
  }

  var currentField = schema.getFieldConfig(schema.expectField(schema.assertCompositeType(rawType), transformedNode.name));
  var supportedArgumentDefinition = currentField.args.find(function (_ref) {
    var name = _ref.name;
    return name === SUPPORTED_ARGUMENT_NAME;
  });

  if (supportedArgumentDefinition == null) {
    if (moduleKey == null) {
      throw createUserError('@match on a field without the `supported` argument is a no-op, please remove the `@match`.', [node.loc]);
    }

    return transformedNode;
  }

  var supportedArgType = schema.getNullableType(supportedArgumentDefinition.type);
  var supportedArgOfType = supportedArgType != null && schema.isList(supportedArgType) ? schema.getListItemType(supportedArgType) : null;

  if (supportedArgType == null || supportedArgOfType == null || !schema.isString(schema.getNullableType(supportedArgOfType))) {
    throw createUserError("@match used on incompatible field '".concat(transformedNode.name, "'. ") + '@match may only be used with fields that accept a ' + "'supported: [String!]!' argument.", [node.loc]);
  }

  var rawFieldType = schema.getRawType(transformedNode.type);

  if (!schema.isAbstractType(rawFieldType)) {
    throw createUserError("@match used on incompatible field '".concat(transformedNode.name, "'.") + '@match may only be used with fields that return a union or interface.', [node.loc]);
  }

  var seenTypes = new Map();
  var selections = [];
  transformedNode.selections.forEach(function (matchSelection) {
    if (matchSelection.kind === 'ScalarField' && matchSelection.name === '__typename') {
      selections.push(matchSelection);
      return;
    }

    var moduleImport = matchSelection.kind === 'InlineFragment' ? matchSelection.selections[0] : null;

    if (matchSelection.kind !== 'InlineFragment' || moduleImport == null || moduleImport.kind !== 'ModuleImport') {
      throw createUserError('Invalid @match selection: all selections should be ' + 'fragment spreads with @module.', [matchSelection.loc]);
    }

    var matchedType = matchSelection.typeCondition;
    seenTypes.set(matchedType, matchSelection);
    selections.push(matchSelection);
  });

  if (seenTypes.size === 0) {
    throw createUserError('Invalid @match selection: expected at least one @module selection. ' + "Remove @match or add a '...Fragment @module()' selection.", [matchDirective.loc]);
  }

  var supportedArg = transformedNode.args.find(function (arg) {
    return arg.name === SUPPORTED_ARGUMENT_NAME;
  });

  if (supportedArg != null) {
    throw createUserError("Invalid @match selection: the '".concat(SUPPORTED_ARGUMENT_NAME, "' argument ") + 'is automatically added and cannot be supplied explicitly.', [supportedArg.loc]);
  }

  return {
    kind: 'LinkedField',
    alias: transformedNode.alias,
    args: [].concat((0, _toConsumableArray2["default"])(transformedNode.args), [{
      kind: 'Argument',
      name: SUPPORTED_ARGUMENT_NAME,
      type: supportedArgumentDefinition.type,
      value: {
        kind: 'Literal',
        loc: node.loc,
        value: Array.from(seenTypes.keys()).map(function (type) {
          return schema.getTypeString(type);
        })
      },
      loc: node.loc
    }]),
    connection: false,
    directives: [],
    handles: null,
    loc: node.loc,
    metadata: null,
    name: transformedNode.name,
    type: transformedNode.type,
    selections: selections
  };
} // Transform @module


function visitFragmentSpread(spread, _ref2) {
  var _moduleDirective$args2, _moduleDirective$args3, _moduleDirective$args4, _moduleDirective$args5, _moduleDirective$args6, _moduleDirective$args7;

  var documentName = _ref2.documentName,
      path = _ref2.path,
      matchesForPath = _ref2.matchesForPath,
      moduleKeyFromParent = _ref2.moduleKey;
  var transformedNode = this.traverse(spread);
  var moduleDirective = transformedNode.directives.find(function (directive) {
    return directive.name === 'module';
  });

  if (moduleDirective == null) {
    return transformedNode;
  }

  if (spread.args.length !== 0) {
    var _spread$args$;

    throw createUserError('@module does not support @arguments.', [(_spread$args$ = spread.args[0]) === null || _spread$args$ === void 0 ? void 0 : _spread$args$.loc].filter(Boolean));
  }

  var context = this.getContext();
  var schema = context.getSchema();
  var jsModuleType = schema.asScalarFieldType(schema.getTypeFromString(JS_FIELD_TYPE));

  if (jsModuleType == null || !schema.isServerType(jsModuleType)) {
    throw new createUserError("'".concat(JS_FIELD_NAME, "' should be defined on the server schema."), [spread.loc]);
  }

  if (!schema.isScalar(jsModuleType)) {
    throw createUserError('Using @module requires the schema to define a scalar ' + "'".concat(JS_FIELD_TYPE, "' type."));
  }

  var fragment = context.getFragment(spread.name, spread.loc);

  if (!schema.isObject(fragment.type)) {
    throw createUserError("@module used on invalid fragment spread '...".concat(spread.name, "'. @module ") + 'may only be used with fragments on a concrete (object) type, ' + "but the fragment has abstract type '".concat(schema.getTypeString(fragment.type), "'."), [spread.loc, fragment.loc]);
  }

  var field = schema.getFieldByName(fragment.type, JS_FIELD_NAME);

  if (!field) {
    throw createUserError("@module used on invalid fragment spread '...".concat(spread.name, "'. @module ") + "requires the fragment type '".concat(schema.getTypeString(fragment.type), "' to have a ") + "'".concat(JS_FIELD_NAME, "(").concat(JS_FIELD_MODULE_ARG, ": String! ") + "[".concat(JS_FIELD_ID_ARG, ": String]): ").concat(JS_FIELD_TYPE, "' field (your ") + "schema may choose to omit the 'id'  argument but if present it " + "must accept a 'String').", [moduleDirective.loc]);
  }

  var jsField = schema.getFieldConfig(field);
  var jsFieldModuleArg = jsField ? jsField.args.find(function (arg) {
    return arg.name === JS_FIELD_MODULE_ARG;
  }) : null;
  var jsFieldIdArg = jsField ? jsField.args.find(function (arg) {
    return arg.name === JS_FIELD_ID_ARG;
  }) : null;

  if (jsFieldModuleArg == null || !schema.isString(schema.getNullableType(jsFieldModuleArg.type)) || jsFieldIdArg != null && !schema.isString(jsFieldIdArg.type) || jsField.type !== jsModuleType) {
    throw createUserError("@module used on invalid fragment spread '...".concat(spread.name, "'. @module ") + "requires the fragment type '".concat(schema.getTypeString(fragment.type), "' to have a ") + "'".concat(JS_FIELD_NAME, "(").concat(JS_FIELD_MODULE_ARG, ": String! ") + "[".concat(JS_FIELD_ID_ARG, ": String]): ").concat(JS_FIELD_TYPE, "' field (your ") + "schema may choose to omit the 'id'  argument but if present it " + "must accept a 'String').", [moduleDirective.loc]);
  }

  if (spread.directives.length !== 1) {
    throw createUserError("@module used on invalid fragment spread '...".concat(spread.name, "'. @module ") + 'may not have additional directives.', [spread.loc]);
  }

  var _getLiteralArgumentVa2 = getLiteralArgumentValues(moduleDirective.args),
      moduleName = _getLiteralArgumentVa2.name;

  if (typeof moduleName !== 'string') {
    var _moduleDirective$args;

    throw createUserError("Expected the 'name' argument of @module to be a literal string", [((_moduleDirective$args = moduleDirective.args.find(function (arg) {
      return arg.name === 'name';
    })) !== null && _moduleDirective$args !== void 0 ? _moduleDirective$args : spread).loc]);
  }

  var parentField = path[path.length - 1];
  var moduleKey = moduleKeyFromParent !== null && moduleKeyFromParent !== void 0 ? moduleKeyFromParent : documentName;
  var aliasPath = path.map(function (x) {
    return x.alias;
  }).join('.');
  var moduleId = aliasPath === '' ? documentName : "".concat(documentName, ".").concat(aliasPath);
  var typeName = schema.getTypeString(fragment.type);
  var matches = matchesForPath.get(aliasPath);

  if (matches == null) {
    var _parentField$loc;

    if (matchesForPath.size !== 0) {
      var existingMatchWithKey = Array.from(matchesForPath.values()).find(function (entry) {
        return entry.key === moduleKey;
      });

      if (existingMatchWithKey != null) {
        if (parentField == null) {
          throw createCompilerError('Cannot have @module selections at multiple paths unless the selections are within fields.', [spread.loc]);
        }

        throw createUserError('Invalid @module selection: documents with multiple fields ' + "containing 3D selections must specify a unique 'key' value " + "for each field: use '".concat(parentField.alias, " @match(key: \"").concat(documentName, "_<localName>\")'."), [parentField.loc]);
      }
    }

    matches = {
      key: moduleKey,
      location: (_parentField$loc = parentField === null || parentField === void 0 ? void 0 : parentField.loc) !== null && _parentField$loc !== void 0 ? _parentField$loc : spread.loc,
      types: new Map()
    };
    matchesForPath.set(aliasPath, matches);
  }

  if (moduleKey !== matches.key) {
    var _parentField$loc2;

    // The user can't override the key locally (per @module),
    // so this is just an internal sanity check
    throw createCompilerError('Invalid @module selection: expected all selections at path ' + "'".concat(aliasPath, " to have the same 'key', got '").concat(moduleKey, "' and '").concat(matches.key, "'."), [(_parentField$loc2 = parentField === null || parentField === void 0 ? void 0 : parentField.loc) !== null && _parentField$loc2 !== void 0 ? _parentField$loc2 : spread.loc]);
  }

  var previousMatchForType = matches.types.get(typeName);

  if (previousMatchForType != null && (previousMatchForType.fragment !== spread.name || previousMatchForType.module !== moduleName)) {
    throw createUserError('Invalid @module selection: concrete type ' + "'".concat(typeName, "' was matched multiple times at path ") + "'".concat(aliasPath, "' but with a different fragment or module name."), [spread.loc, previousMatchForType.location]);
  }

  matches.types.set(typeName, {
    location: spread.loc,
    fragment: spread.name,
    module: moduleName
  });
  var normalizationName = getNormalizationOperationName(spread.name) + '.graphql';
  var componentKey = getModuleComponentKey(moduleKey);
  var componentField = {
    alias: componentKey,
    args: [{
      kind: 'Argument',
      name: JS_FIELD_MODULE_ARG,
      type: jsFieldModuleArg.type,
      value: {
        kind: 'Literal',
        loc: (_moduleDirective$args2 = (_moduleDirective$args3 = moduleDirective.args[0]) === null || _moduleDirective$args3 === void 0 ? void 0 : _moduleDirective$args3.loc) !== null && _moduleDirective$args2 !== void 0 ? _moduleDirective$args2 : moduleDirective.loc,
        value: moduleName
      },
      loc: moduleDirective.loc
    }, jsFieldIdArg != null ? {
      kind: 'Argument',
      name: JS_FIELD_ID_ARG,
      type: jsFieldIdArg.type,
      value: {
        kind: 'Literal',
        loc: (_moduleDirective$args4 = (_moduleDirective$args5 = moduleDirective.args[0]) === null || _moduleDirective$args5 === void 0 ? void 0 : _moduleDirective$args5.loc) !== null && _moduleDirective$args4 !== void 0 ? _moduleDirective$args4 : moduleDirective.loc,
        value: moduleId
      },
      loc: moduleDirective.loc
    } : null].filter(Boolean),
    directives: [],
    handles: null,
    kind: 'ScalarField',
    loc: moduleDirective.loc,
    metadata: {
      skipNormalizationNode: true
    },
    name: JS_FIELD_NAME,
    type: jsModuleType
  };
  var operationKey = getModuleOperationKey(moduleKey);
  var operationField = {
    alias: operationKey,
    args: [{
      kind: 'Argument',
      name: JS_FIELD_MODULE_ARG,
      type: jsFieldModuleArg.type,
      value: {
        kind: 'Literal',
        loc: moduleDirective.loc,
        value: normalizationName
      },
      loc: moduleDirective.loc
    }, jsFieldIdArg != null ? {
      kind: 'Argument',
      name: JS_FIELD_ID_ARG,
      type: jsFieldIdArg.type,
      value: {
        kind: 'Literal',
        loc: (_moduleDirective$args6 = (_moduleDirective$args7 = moduleDirective.args[0]) === null || _moduleDirective$args7 === void 0 ? void 0 : _moduleDirective$args7.loc) !== null && _moduleDirective$args6 !== void 0 ? _moduleDirective$args6 : moduleDirective.loc,
        value: moduleId
      },
      loc: moduleDirective.loc
    } : null].filter(Boolean),
    directives: [],
    handles: null,
    kind: 'ScalarField',
    loc: moduleDirective.loc,
    metadata: {
      skipNormalizationNode: true
    },
    name: JS_FIELD_NAME,
    type: jsModuleType
  };
  return {
    kind: 'InlineFragment',
    directives: [],
    loc: moduleDirective.loc,
    metadata: null,
    selections: [{
      kind: 'ModuleImport',
      loc: moduleDirective.loc,
      key: moduleKey,
      id: moduleId,
      module: moduleName,
      sourceDocument: documentName,
      name: spread.name,
      selections: [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, spread), {}, {
        directives: spread.directives.filter(function (directive) {
          return directive !== moduleDirective;
        })
      }), operationField, componentField]
    }],
    typeCondition: fragment.type
  };
}

module.exports = {
  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
  transform: matchTransform
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


function getNormalizationOperationName(name) {
  return "".concat(name, "$normalization");
}

module.exports = getNormalizationOperationName;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var IRVisitor = __webpack_require__(19);

var getLiteralArgumentValues = __webpack_require__(20);

var inferRootArgumentDefinitions = __webpack_require__(21);

var _require = __webpack_require__(1),
    createUserError = _require.createUserError,
    eachWithCombinedError = _require.eachWithCombinedError;

var _require2 = __webpack_require__(96),
    buildRefetchOperation = _require2.buildRefetchOperation;

var SCHEMA_EXTENSION = "\n  directive @refetchable(\n    queryName: String!\n  ) on FRAGMENT_DEFINITION\n";
/**
 * This transform synthesizes "refetch" queries for fragments that
 * are trivially refetchable. This is comprised of three main stages:
 *
 * 1. Validating that fragments marked with @refetchable qualify for
 *    refetch query generation; mainly this means that the fragment
 *    type is able to be refetched in some canonical way.
 * 2. Determining the variable definitions to use for each generated
 *    query. GraphQL does not have a notion of fragment-local variables
 *    at all, and although Relay adds this concept developers are still
 *    allowed to reference global variables. This necessitates a
 *    visiting all reachable fragments for each @refetchable fragment,
 *    and finding the union of all global variables expceted to be defined.
 * 3. Building the refetch queries, a straightforward copying transform from
 *    Fragment to Root IR nodes.
 */

function refetchableFragmentTransform(context) {
  var schema = context.getSchema();
  var refetchOperations = buildRefetchMap(context);
  var nextContext = context;
  eachWithCombinedError(refetchOperations, function (_ref) {
    var refetchName = _ref[0],
        fragment = _ref[1];

    var _buildRefetchOperatio = buildRefetchOperation(schema, fragment, refetchName),
        identifierField = _buildRefetchOperatio.identifierField,
        path = _buildRefetchOperatio.path,
        node = _buildRefetchOperatio.node,
        transformedFragment = _buildRefetchOperatio.transformedFragment;

    var connectionMetadata = extractConnectionMetadata(context.getSchema(), transformedFragment);
    nextContext = nextContext.replace((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, transformedFragment), {}, {
      metadata: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, transformedFragment.metadata || {}), {}, {
        refetch: {
          connection: connectionMetadata !== null && connectionMetadata !== void 0 ? connectionMetadata : null,
          operation: refetchName,
          fragmentPathInResult: path,
          identifierField: identifierField
        }
      })
    }));
    nextContext = nextContext.add((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
      metadata: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node.metadata || {}), {}, {
        derivedFrom: transformedFragment.name,
        isRefetchableQuery: true
      })
    }));
  });
  return nextContext;
}
/**
 * Walk the documents of a compiler context and create a mapping of
 * refetch operation names to the source fragment from which the refetch
 * operation should be derived.
 */


function buildRefetchMap(context) {
  var refetchOperations = new Map();
  eachWithCombinedError(context.documents(), function (node) {
    if (node.kind !== 'Fragment') {
      return;
    }

    var refetchName = getRefetchQueryName(node);

    if (refetchName === null) {
      return;
    }

    var previousOperation = refetchOperations.get(refetchName);

    if (previousOperation != null) {
      throw createUserError("Duplicate definition for @refetchable operation '".concat(refetchName, "' from fragments '").concat(node.name, "' and '").concat(previousOperation.name, "'"), [node.loc, previousOperation.loc]);
    }

    refetchOperations.set(refetchName, node);
  });
  var transformed = inferRootArgumentDefinitions(context);
  return new Map(Array.from(refetchOperations.entries(), function (_ref2) {
    var name = _ref2[0],
        fragment = _ref2[1];
    return [name, transformed.getFragment(fragment.name)];
  }));
}
/**
 * Validate that any @connection usage is valid for refetching:
 * - Variables are used for both the "count" and "cursor" arguments
 *   (after/first or before/last)
 * - Exactly one connection
 * - Has a stable path to the connection data
 *
 * Returns connection metadata to add to the transformed fragment or undefined
 * if there is no connection.
 */


function extractConnectionMetadata(schema, fragment) {
  var fields = [];
  var connectionField = null;
  var path = null;
  IRVisitor.visit(fragment, {
    LinkedField: {
      enter: function enter(field) {
        fields.push(field);

        if (field.connection === true || field.handles && field.handles.some(function (handle) {
          return handle.name === 'connection';
        })) {
          // Disallow multiple @connections
          if (connectionField != null) {
            throw createUserError("Invalid use of @refetchable with @connection in fragment '".concat(fragment.name, "', at most once @connection can appear in a refetchable fragment."), [field.loc]);
          } // Disallow connections within plurals


          var pluralOnPath = fields.find(function (pathField) {
            return schema.isList(schema.getNullableType(pathField.type));
          });

          if (pluralOnPath) {
            throw createUserError("Invalid use of @refetchable with @connection in fragment '".concat(fragment.name, "', refetchable connections cannot appear inside plural fields."), [field.loc, pluralOnPath.loc]);
          }

          connectionField = field;
          path = fields.map(function (pathField) {
            return pathField.alias;
          });
        }
      },
      leave: function leave() {
        fields.pop();
      }
    }
  });

  if (connectionField == null || path == null) {
    return;
  } // Validate arguments: if either of before/last appear they must both appear
  // and use variables (not scalar values)


  var backward = null;
  var before = findArgument(connectionField, 'before');
  var last = findArgument(connectionField, 'last');

  if (before || last) {
    if (!before || !last || before.value.kind !== 'Variable' || last.value.kind !== 'Variable') {
      throw createUserError("Invalid use of @refetchable with @connection in fragment '".concat(fragment.name, "', refetchable connections must use variables for the before and last arguments."), [connectionField.loc, before && before.value.kind !== 'Variable' ? before.value.loc : null, last && last.value.kind !== 'Variable' ? last.value.loc : null].filter(Boolean));
    }

    backward = {
      count: last.value.variableName,
      cursor: before.value.variableName
    };
  } // Validate arguments: if either of after/first appear they must both appear
  // and use variables (not scalar values)


  var forward = null;
  var after = findArgument(connectionField, 'after');
  var first = findArgument(connectionField, 'first');

  if (after || first) {
    if (!after || !first || after.value.kind !== 'Variable' || first.value.kind !== 'Variable') {
      throw createUserError("Invalid use of @refetchable with @connection in fragment '".concat(fragment.name, "', refetchable connections must use variables for the after and first arguments."), [connectionField.loc, after && after.value.kind !== 'Variable' ? after.value.loc : null, first && first.value.kind !== 'Variable' ? first.value.loc : null].filter(Boolean));
    }

    forward = {
      count: first.value.variableName,
      cursor: after.value.variableName
    };
  }

  return {
    forward: forward,
    backward: backward,
    path: path
  };
}

function getRefetchQueryName(fragment) {
  var refetchableDirective = fragment.directives.find(function (directive) {
    return directive.name === 'refetchable';
  });

  if (refetchableDirective == null) {
    return null;
  }

  var refetchArguments = getLiteralArgumentValues(refetchableDirective.args);
  var queryName = refetchArguments.queryName;

  if (queryName == null) {
    throw createUserError("Expected the 'queryName' argument of @refetchable to be provided", [refetchableDirective.loc]);
  } else if (typeof queryName !== 'string') {
    var _queryNameArg$loc;

    var queryNameArg = refetchableDirective.args.find(function (arg) {
      return arg.name === 'queryName';
    });
    throw createUserError("Expected the 'queryName' argument of @refetchable to be a string, got '".concat(String(queryName), "'."), [(_queryNameArg$loc = queryNameArg === null || queryNameArg === void 0 ? void 0 : queryNameArg.loc) !== null && _queryNameArg$loc !== void 0 ? _queryNameArg$loc : refetchableDirective.loc]);
  }

  return queryName;
}

function findArgument(field, argumentName) {
  var _field$args$find;

  return (_field$args$find = field.args.find(function (arg) {
    return arg.name === argumentName;
  })) !== null && _field$args$find !== void 0 ? _field$args$find : null;
}

module.exports = {
  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
  transform: refetchableFragmentTransform
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var IRTransformer = __webpack_require__(3);

var getLiteralArgumentValues = __webpack_require__(20);

var invariant = __webpack_require__(6);

var RELAY = 'relay';
var SCHEMA_EXTENSION = "\ndirective @relay(\n  # Marks a fragment as being backed by a GraphQLList.\n  plural: Boolean,\n\n  # Marks a fragment spread which should be unmasked if provided false\n  mask: Boolean = true,\n) on FRAGMENT_DEFINITION | FRAGMENT_SPREAD\n";
/**
 * A transform that extracts `@relay(plural: Boolean)` directives and converts
 * them to metadata that can be accessed at runtime.
 */

function relayDirectiveTransform(context) {
  return IRTransformer.transform(context, {
    Fragment: visitRelayMetadata(fragmentMetadata),
    FragmentSpread: visitRelayMetadata(fragmentSpreadMetadata)
  });
}

function visitRelayMetadata(metadataFn) {
  return function (node) {
    var relayDirective = node.directives.find(function (_ref) {
      var name = _ref.name;
      return name === RELAY;
    });

    if (!relayDirective) {
      // $FlowFixMe[incompatible-use]
      return this.traverse(node);
    }

    var argValues = getLiteralArgumentValues(relayDirective.args);
    var metadata = metadataFn(argValues); // $FlowFixMe[incompatible-use]

    return this.traverse((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
      directives: node.directives.filter(function (directive) {
        return directive !== relayDirective;
      }),
      // $FlowFixMe[cannot-spread-indexer]
      metadata: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node.metadata || {}), metadata)
    }));
  };
}

function fragmentMetadata(_ref2) {
  var mask = _ref2.mask,
      plural = _ref2.plural;
  !(plural === undefined || typeof plural === 'boolean') ?  true ? invariant(false, 'RelayDirectiveTransform: Expected the "plural" argument to @relay ' + 'to be a boolean literal if specified.') : undefined : void 0;
  !(mask === undefined || typeof mask === 'boolean') ?  true ? invariant(false, 'RelayDirectiveTransform: Expected the "mask" argument to @relay ' + 'to be a boolean literal if specified.') : undefined : void 0;
  return {
    mask: mask,
    plural: plural
  };
}

function fragmentSpreadMetadata(_ref3) {
  var mask = _ref3.mask;
  !(mask === undefined || typeof mask === 'boolean') ?  true ? invariant(false, 'RelayDirectiveTransform: Expected the "mask" argument to @relay ' + 'to be a boolean literal if specified.') : undefined : void 0;
  return {
    mask: mask
  };
}

module.exports = {
  RELAY: RELAY,
  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
  transform: relayDirectiveTransform
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var FlattenTransform = __webpack_require__(40);

var IRVisitor = __webpack_require__(19);

var MaskTransform = __webpack_require__(43);

var MatchTransform = __webpack_require__(44);

var Profiler = __webpack_require__(7);

var RefetchableFragmentTransform = __webpack_require__(46);

var RelayDirectiveTransform = __webpack_require__(47);

var RequiredFieldTransform = __webpack_require__(49);

var generateAbstractTypeRefinementKey = __webpack_require__(18);

var partitionArray = __webpack_require__(16);

var _require = __webpack_require__(50),
    anyTypeAlias = _require.anyTypeAlias,
    declareExportOpaqueType = _require.declareExportOpaqueType,
    exactObjectTypeAnnotation = _require.exactObjectTypeAnnotation,
    exportType = _require.exportType,
    exportTypes = _require.exportTypes,
    importTypes = _require.importTypes,
    inexactObjectTypeAnnotation = _require.inexactObjectTypeAnnotation,
    intersectionTypeAnnotation = _require.intersectionTypeAnnotation,
    lineComments = _require.lineComments,
    readOnlyArrayOfType = _require.readOnlyArrayOfType,
    readOnlyObjectTypeProperty = _require.readOnlyObjectTypeProperty,
    unionTypeAnnotation = _require.unionTypeAnnotation;

var _require2 = __webpack_require__(101),
    transformInputType = _require2.transformInputType,
    transformScalarType = _require2.transformScalarType;

var babelGenerator = __webpack_require__(102)["default"];

var t = __webpack_require__(26);

var invariant = __webpack_require__(6);

var nullthrows = __webpack_require__(17);

function generate(schema, node, options) {
  var ast = IRVisitor.visit(node, createVisitor(schema, options));
  return babelGenerator(ast).code;
}

function makeProp(schema, _ref, state, unmasked, concreteType) {
  var key = _ref.key,
      schemaName = _ref.schemaName,
      value = _ref.value,
      conditional = _ref.conditional,
      nodeType = _ref.nodeType,
      nodeSelections = _ref.nodeSelections;

  if (schemaName === '__typename' && concreteType) {
    value = t.stringLiteralTypeAnnotation(concreteType);
  } else if (nodeType) {
    value = transformScalarType(schema, nodeType, state, selectionsToBabel(schema, [Array.from(nullthrows(nodeSelections).values())], state, unmasked));
  }

  var typeProperty = readOnlyObjectTypeProperty(key, value);

  if (conditional) {
    typeProperty.optional = true;
  }

  return typeProperty;
}

var isTypenameSelection = function isTypenameSelection(selection) {
  return selection.schemaName === '__typename';
};

var hasTypenameSelection = function hasTypenameSelection(selections) {
  return selections.some(isTypenameSelection);
};

var onlySelectsTypename = function onlySelectsTypename(selections) {
  return selections.every(isTypenameSelection);
};

function selectionsToBabel(schema, selections, state, unmasked, fragmentTypeName) {
  var baseFields = new Map();
  var byConcreteType = {};
  flattenArray(selections).forEach(function (selection) {
    var concreteType = selection.concreteType;

    if (concreteType) {
      var _byConcreteType$concr;

      byConcreteType[concreteType] = (_byConcreteType$concr = byConcreteType[concreteType]) !== null && _byConcreteType$concr !== void 0 ? _byConcreteType$concr : [];
      byConcreteType[concreteType].push(selection);
    } else {
      var previousSel = baseFields.get(selection.key);
      baseFields.set(selection.key, previousSel ? mergeSelection(selection, previousSel) : selection);
    }
  });
  var types = [];

  if (Object.keys(byConcreteType).length > 0 && onlySelectsTypename(Array.from(baseFields.values())) && (hasTypenameSelection(Array.from(baseFields.values())) || Object.keys(byConcreteType).every(function (type) {
    return hasTypenameSelection(byConcreteType[type]);
  }))) {
    (function () {
      var typenameAliases = new Set();

      var _loop = function _loop(concreteType) {
        types.push(groupRefs([].concat((0, _toConsumableArray2["default"])(Array.from(baseFields.values())), (0, _toConsumableArray2["default"])(byConcreteType[concreteType]))).map(function (selection) {
          if (selection.schemaName === '__typename') {
            typenameAliases.add(selection.key);
          }

          return makeProp(schema, selection, state, unmasked, concreteType);
        }));
      };

      for (var concreteType in byConcreteType) {
        _loop(concreteType);
      } // It might be some other type then the listed concrete types. Ideally, we
      // would set the type to diff(string, set of listed concrete types), but
      // this doesn't exist in Flow at the time.


      types.push(Array.from(typenameAliases).map(function (typenameAlias) {
        var otherProp = readOnlyObjectTypeProperty(typenameAlias, t.stringLiteralTypeAnnotation('%other'));
        otherProp.leadingComments = lineComments("This will never be '%other', but we need some", 'value in case none of the concrete values match.');
        return otherProp;
      }));
    })();
  } else {
    var selectionMap = selectionsToMap(Array.from(baseFields.values()));

    for (var concreteType in byConcreteType) {
      selectionMap = mergeSelections(selectionMap, selectionsToMap(byConcreteType[concreteType].map(function (sel) {
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, sel), {}, {
          conditional: true
        });
      })));
    }

    var selectionMapValues = groupRefs(Array.from(selectionMap.values())).map(function (sel) {
      return isTypenameSelection(sel) && sel.concreteType ? makeProp(schema, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, sel), {}, {
        conditional: false
      }), state, unmasked, sel.concreteType) : makeProp(schema, sel, state, unmasked);
    });
    types.push(selectionMapValues);
  }

  return unionTypeAnnotation(types.map(function (props) {
    if (fragmentTypeName) {
      props.push(readOnlyObjectTypeProperty('$refType', t.genericTypeAnnotation(t.identifier(fragmentTypeName))));
    }

    return unmasked ? inexactObjectTypeAnnotation(props) : exactObjectTypeAnnotation(props);
  }));
}

function mergeSelection(a, b) {
  var shouldSetConditional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (!a) {
    if (shouldSetConditional) {
      return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, b), {}, {
        conditional: true
      });
    }

    return b;
  }

  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, a), {}, {
    nodeSelections: a.nodeSelections ? mergeSelections(a.nodeSelections, nullthrows(b.nodeSelections), shouldSetConditional) : null,
    conditional: a.conditional && b.conditional
  });
}

function mergeSelections(a, b) {
  var shouldSetConditional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var merged = new Map();

  var _iterator = (0, _createForOfIteratorHelper2["default"])(a.entries()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _step.value,
          key = _step$value[0],
          value = _step$value[1];
      merged.set(key, value);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _iterator2 = (0, _createForOfIteratorHelper2["default"])(b.entries()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _step2.value,
          _key = _step2$value[0],
          _value = _step2$value[1];
      merged.set(_key, mergeSelection(a.get(_key), _value, shouldSetConditional));
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return merged;
}

function isPlural(node) {
  return Boolean(node.metadata && node.metadata.plural);
}

function createVisitor(schema, options) {
  var state = {
    customScalars: options.customScalars,
    enumsHasteModule: options.enumsHasteModule,
    generatedFragments: new Set(),
    generatedInputObjectTypes: {},
    optionalInputFields: options.optionalInputFields,
    usedEnums: {},
    usedFragments: new Set(),
    useHaste: options.useHaste,
    useSingleArtifactDirectory: options.useSingleArtifactDirectory,
    noFutureProofEnums: options.noFutureProofEnums,
    matchFields: new Map(),
    runtimeImports: new Set()
  };
  return {
    leave: {
      Root: function Root(node) {
        var _node$metadata;

        var inputVariablesType = generateInputVariablesType(schema, node, state);
        var inputObjectTypes = generateInputObjectTypes(state);
        var responseTypeDefinition = selectionsToBabel(schema,
        /* $FlowFixMe: selections have already been transformed */
        node.selections, state, false);

        if (((_node$metadata = node.metadata) === null || _node$metadata === void 0 ? void 0 : _node$metadata.childrenCanBubbleNull) === true) {
          responseTypeDefinition = t.nullableTypeAnnotation(responseTypeDefinition);
        }

        var responseType = exportType("".concat(node.name, "Response"), responseTypeDefinition);
        var operationTypes = [t.objectTypeProperty(t.identifier('variables'), t.genericTypeAnnotation(t.identifier("".concat(node.name, "Variables")))), t.objectTypeProperty(t.identifier('response'), t.genericTypeAnnotation(t.identifier("".concat(node.name, "Response"))))]; // Generate raw response type

        var rawResponseType;
        var normalizationIR = options.normalizationIR;

        if (normalizationIR && node.directives.some(function (d) {
          return d.name === DIRECTIVE_NAME;
        })) {
          rawResponseType = IRVisitor.visit(normalizationIR, createRawResponseTypeVisitor(schema, state));
        }

        var refetchableFragmentName = getRefetchableQueryParentFragmentName(state, node.metadata);

        if (refetchableFragmentName != null) {
          state.runtimeImports.add('FragmentReference');
        }

        var babelNodes = [];

        if (state.runtimeImports.size) {
          babelNodes.push(importTypes(Array.from(state.runtimeImports).sort(), 'relay-runtime'));
        }

        babelNodes.push.apply(babelNodes, (0, _toConsumableArray2["default"])(refetchableFragmentName ? generateFragmentRefsForRefetchable(refetchableFragmentName) : getFragmentImports(state)).concat((0, _toConsumableArray2["default"])(getEnumDefinitions(schema, state)), (0, _toConsumableArray2["default"])(inputObjectTypes), [inputVariablesType, responseType]));

        if (rawResponseType) {
          var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.matchFields),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _step3$value = _step3.value,
                  key = _step3$value[0],
                  ast = _step3$value[1];
              babelNodes.push(exportType(key, ast));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          operationTypes.push(t.objectTypeProperty(t.identifier('rawResponse'), t.genericTypeAnnotation(t.identifier("".concat(node.name, "RawResponse")))));
          babelNodes.push(rawResponseType);
        }

        babelNodes.push(exportType(node.name, exactObjectTypeAnnotation(operationTypes))); // $FlowFixMe[incompatible-call]

        return t.program(babelNodes);
      },
      Fragment: function Fragment(node) {
        var _node$metadata2;

        var selections = flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
        node.selections);
        var numConecreteSelections = selections.filter(function (s) {
          return s.concreteType;
        }).length;
        selections = selections.map(function (selection) {
          if (numConecreteSelections <= 1 && isTypenameSelection(selection) && !schema.isAbstractType(node.type)) {
            return [(0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, selection), {}, {
              concreteType: schema.getTypeString(node.type)
            })];
          }

          return [selection];
        });
        state.generatedFragments.add(node.name);
        var fragmentTypes = getFragmentTypes(node.name, getRefetchableQueryPath(state, node.directives));
        var refTypeName = getRefTypeName(node.name);
        var refTypeDataProperty = readOnlyObjectTypeProperty('$data', t.genericTypeAnnotation(t.identifier("".concat(node.name, "$data"))));
        refTypeDataProperty.optional = true;
        var refTypeFragmentRefProperty = readOnlyObjectTypeProperty('$fragmentRefs', t.genericTypeAnnotation(t.identifier(getOldFragmentTypeName(node.name))));
        var isPluralFragment = isPlural(node);
        var refType = inexactObjectTypeAnnotation([refTypeDataProperty, refTypeFragmentRefProperty]);
        var dataTypeName = getDataTypeName(node.name);
        var dataType = t.genericTypeAnnotation(t.identifier(node.name));
        var unmasked = node.metadata != null && node.metadata.mask === false;
        var baseType = selectionsToBabel(schema, selections, state, unmasked, unmasked ? undefined : getOldFragmentTypeName(node.name));
        var type = isPluralFragment ? readOnlyArrayOfType(baseType) : baseType;

        if (((_node$metadata2 = node.metadata) === null || _node$metadata2 === void 0 ? void 0 : _node$metadata2.childrenCanBubbleNull) === true) {
          type = t.nullableTypeAnnotation(type);
        }

        state.runtimeImports.add('FragmentReference');
        return t.program([].concat((0, _toConsumableArray2["default"])(getFragmentImports(state)), (0, _toConsumableArray2["default"])(getEnumDefinitions(schema, state)), [importTypes(Array.from(state.runtimeImports).sort(), 'relay-runtime')], (0, _toConsumableArray2["default"])(fragmentTypes), [exportType(node.name, type), exportType(dataTypeName, dataType), exportType(refTypeName, isPluralFragment ? readOnlyArrayOfType(refType) : refType)]));
      },
      InlineFragment: function InlineFragment(node) {
        return flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
        node.selections).map(function (typeSelection) {
          return schema.isAbstractType(node.typeCondition) ? (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, typeSelection), {}, {
            conditional: true
          }) : (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, typeSelection), {}, {
            concreteType: schema.getTypeString(node.typeCondition)
          });
        });
      },
      Condition: function Condition(node) {
        return flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
        node.selections).map(function (selection) {
          return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, selection), {}, {
            conditional: true
          });
        });
      },
      ScalarField: function ScalarField(node) {
        return visitScalarField(schema, node, state);
      },
      LinkedField: function LinkedField(node) {
        return visitLinkedField(schema, node);
      },
      ModuleImport: function ModuleImport(node) {
        return [{
          key: '__fragmentPropName',
          conditional: true,
          value: transformScalarType(schema, schema.expectStringType(), state)
        }, {
          key: '__module_component',
          conditional: true,
          value: transformScalarType(schema, schema.expectStringType(), state)
        }, {
          key: '__fragments_' + node.name,
          ref: node.name
        }];
      },
      FragmentSpread: function FragmentSpread(node) {
        state.usedFragments.add(node.name);
        return [{
          key: '__fragments_' + node.name,
          ref: node.name
        }];
      }
    }
  };
}

function visitNodeWithSelectionsOnly(node) {
  return flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
  node.selections);
}

function visitScalarField(schema, node, state) {
  var _node$metadata3;

  var requiredMetadata = (_node$metadata3 = node.metadata) === null || _node$metadata3 === void 0 ? void 0 : _node$metadata3.required;
  var nodeType = requiredMetadata != null ? schema.getNonNullType(node.type) : node.type;
  return [{
    key: node.alias,
    schemaName: node.name,
    value: transformScalarType(schema, nodeType, state)
  }];
}

function getLinkedFieldNodeType(schema, node) {
  var _node$metadata4, _node$metadata5;

  var requiredMetadata = (_node$metadata4 = node.metadata) === null || _node$metadata4 === void 0 ? void 0 : _node$metadata4.required;

  if (requiredMetadata != null) {
    return schema.getNonNullType(node.type);
  }

  if (((_node$metadata5 = node.metadata) === null || _node$metadata5 === void 0 ? void 0 : _node$metadata5.childrenCanBubbleNull) === true) {
    if (schema.isList(node.type)) {
      // In a plural field, nulls bubble up to the item, resulting in a list of nullable items.
      return schema.mapListItemType(node.type, function (inner) {
        return schema.getNullableType(inner);
      });
    } else if (schema.isNonNull(node.type)) {
      var nullable = schema.getNullableType(node.type);

      if (schema.isList(nullable)) {
        return schema.getNonNullType(schema.mapListItemType(nullable, function (inner) {
          return schema.getNullableType(inner);
        }));
      }

      return nullable;
    }

    return node.type;
  }

  return node.type;
}

function visitLinkedField(schema, node) {
  return [{
    key: node.alias,
    schemaName: node.name,
    nodeType: getLinkedFieldNodeType(schema, node),
    nodeSelections: selectionsToMap(flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
    node.selections),
    /*
     * append concreteType to key so overlapping fields with different
     * concreteTypes don't get overwritten by each other
     */
    true)
  }];
}

function makeRawResponseProp(schema, _ref2, state, concreteType) {
  var key = _ref2.key,
      schemaName = _ref2.schemaName,
      value = _ref2.value,
      conditional = _ref2.conditional,
      nodeType = _ref2.nodeType,
      nodeSelections = _ref2.nodeSelections,
      kind = _ref2.kind;

  if (kind === 'ModuleImport') {
    return t.objectTypeSpreadProperty(t.genericTypeAnnotation(t.identifier(key)));
  }

  if (schemaName === '__typename' && concreteType) {
    value = t.stringLiteralTypeAnnotation(concreteType);
  } else if (nodeType) {
    value = transformScalarType(schema, nodeType, state, selectionsToRawResponseBabel(schema, [Array.from(nullthrows(nodeSelections).values())], state, schema.isAbstractType(nodeType) || schema.isWrapper(nodeType) ? null : schema.getTypeString(nodeType)));
  }

  var typeProperty = readOnlyObjectTypeProperty(key, value);

  if (conditional) {
    typeProperty.optional = true;
  }

  return typeProperty;
} // Trasform the codegen IR selections into Babel flow types


function selectionsToRawResponseBabel(schema, selections, state, nodeTypeName) {
  var baseFields = [];
  var byConcreteType = {};
  flattenArray(selections).forEach(function (selection) {
    var concreteType = selection.concreteType;

    if (concreteType) {
      var _byConcreteType$concr2;

      byConcreteType[concreteType] = (_byConcreteType$concr2 = byConcreteType[concreteType]) !== null && _byConcreteType$concr2 !== void 0 ? _byConcreteType$concr2 : [];
      byConcreteType[concreteType].push(selection);
    } else {
      baseFields.push(selection);
    }
  });
  var types = [];

  if (Object.keys(byConcreteType).length) {
    var baseFieldsMap = selectionsToMap(baseFields);

    var _loop2 = function _loop2(concreteType) {
      var mergedSeletions = Array.from(mergeSelections(baseFieldsMap, selectionsToMap(byConcreteType[concreteType]), false).values());
      types.push(exactObjectTypeAnnotation(mergedSeletions.map(function (selection) {
        return makeRawResponseProp(schema, selection, state, concreteType);
      })));
      appendLocal3DPayload(types, mergedSeletions, schema, state, concreteType);
    };

    for (var concreteType in byConcreteType) {
      _loop2(concreteType);
    }
  }

  if (baseFields.length > 0) {
    types.push(exactObjectTypeAnnotation(baseFields.map(function (selection) {
      return makeRawResponseProp(schema, selection, state, nodeTypeName);
    })));
    appendLocal3DPayload(types, baseFields, schema, state, nodeTypeName);
  }

  return unionTypeAnnotation(types);
}

function appendLocal3DPayload(types, selections, schema, state, currentType) {
  var moduleImport = selections.find(function (sel) {
    return sel.kind === 'ModuleImport';
  });

  if (moduleImport) {
    // Generate an extra opaque type for client 3D fields
    state.runtimeImports.add('Local3DPayload');
    types.push(t.genericTypeAnnotation(t.identifier('Local3DPayload'), t.typeParameterInstantiation([t.stringLiteralTypeAnnotation(nullthrows(moduleImport.documentName)), exactObjectTypeAnnotation(selections.filter(function (sel) {
      return sel.schemaName !== 'js';
    }).map(function (selection) {
      return makeRawResponseProp(schema, selection, state, currentType);
    }))])));
  }
} // Visitor for generating raw response type


function createRawResponseTypeVisitor(schema, state) {
  return {
    leave: {
      Root: function Root(node) {
        return exportType("".concat(node.name, "RawResponse"), selectionsToRawResponseBabel(schema, // $FlowFixMe[incompatible-cast] : selections have already been transformed
        node.selections, state, null));
      },
      InlineFragment: function InlineFragment(node) {
        var typeCondition = node.typeCondition;
        return flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
        node.selections).map(function (typeSelection) {
          return schema.isAbstractType(typeCondition) ? typeSelection : (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, typeSelection), {}, {
            concreteType: schema.getTypeString(typeCondition)
          });
        });
      },
      ScalarField: function ScalarField(node) {
        return visitScalarField(schema, node, state);
      },
      ClientExtension: function ClientExtension(node) {
        return flattenArray( // $FlowFixMe[incompatible-cast] : selections have already been transformed
        node.selections).map(function (sel) {
          return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, sel), {}, {
            conditional: true
          });
        });
      },
      LinkedField: function LinkedField(node) {
        return visitLinkedField(schema, node);
      },
      Condition: visitNodeWithSelectionsOnly,
      Defer: visitNodeWithSelectionsOnly,
      Stream: visitNodeWithSelectionsOnly,
      ModuleImport: function ModuleImport(node) {
        return visitRawResposneModuleImport(schema, node, state);
      },
      FragmentSpread: function FragmentSpread(node) {
         true ?  true ? invariant(false, 'A fragment spread is found when traversing the AST, ' + 'make sure you are passing the codegen IR') : undefined : undefined;
      }
    }
  };
} // Dedupe the generated type of module selections to reduce file size


function visitRawResposneModuleImport(schema, node, state) {
  var selections = node.selections,
      key = node.name;
  var moduleSelections = selections.filter( // $FlowFixMe[prop-missing] selections have already been transformed
  function (sel) {
    return sel.length && sel[0].schemaName === 'js';
  }).map(function (arr) {
    return arr[0];
  });

  if (!state.matchFields.has(key)) {
    var ast = selectionsToRawResponseBabel(schema, // $FlowFixMe[incompatible-cast] : selections have already been transformed
    node.selections.filter(function (sel) {
      return sel.length > 1 || sel[0].schemaName !== 'js';
    }), state, null);
    state.matchFields.set(key, ast);
  }

  return [].concat((0, _toConsumableArray2["default"])(moduleSelections), [{
    key: key,
    kind: 'ModuleImport',
    documentName: node.key
  }]);
}

function selectionsToMap(selections, appendType) {
  var map = new Map();
  selections.forEach(function (selection) {
    var key = appendType && selection.concreteType ? "".concat(selection.key, "::").concat(selection.concreteType) : selection.key;
    var previousSel = map.get(key);
    map.set(key, previousSel ? mergeSelection(previousSel, selection) : selection);
  });
  return map;
}

function flattenArray(arrayOfArrays) {
  var result = [];
  arrayOfArrays.forEach(function (array) {
    result.push.apply(result, (0, _toConsumableArray2["default"])(array));
  });
  return result;
}

function generateInputObjectTypes(state) {
  return Object.keys(state.generatedInputObjectTypes).map(function (typeIdentifier) {
    var inputObjectType = state.generatedInputObjectTypes[typeIdentifier];
    !(typeof inputObjectType !== 'string') ?  true ? invariant(false, 'RelayCompilerFlowGenerator: Expected input object type to have been' + ' defined before calling `generateInputObjectTypes`') : undefined : void 0;
    return exportType(typeIdentifier, inputObjectType);
  });
}

function generateInputVariablesType(schema, node, state) {
  return exportType("".concat(node.name, "Variables"), exactObjectTypeAnnotation(node.argumentDefinitions.map(function (arg) {
    var property = t.objectTypeProperty(t.identifier(arg.name), transformInputType(schema, arg.type, state));

    if (!schema.isNonNull(arg.type)) {
      property.optional = true;
    }

    return property;
  })));
}

function groupRefs(props) {
  var result = [];
  var refs = [];
  props.forEach(function (prop) {
    if (prop.ref) {
      refs.push(prop.ref);
    } else {
      result.push(prop);
    }
  });

  if (refs.length > 0) {
    var value = intersectionTypeAnnotation(refs.map(function (ref) {
      return t.genericTypeAnnotation(t.identifier(getOldFragmentTypeName(ref)));
    }));
    result.push({
      key: '$fragmentRefs',
      conditional: false,
      value: value
    });
  }

  return result;
}

function getFragmentImports(state) {
  var imports = [];

  if (state.usedFragments.size > 0) {
    var usedFragments = Array.from(state.usedFragments).sort();

    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(usedFragments),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var usedFragment = _step4.value;
        var fragmentTypeName = getOldFragmentTypeName(usedFragment);

        if (!state.generatedFragments.has(usedFragment)) {
          if (state.useHaste) {
            // TODO(T22653277) support non-haste environments when importing
            // fragments
            imports.push(importTypes([fragmentTypeName], usedFragment + '.graphql'));
          } else if (state.useSingleArtifactDirectory) {
            imports.push(importTypes([fragmentTypeName], './' + usedFragment + '.graphql'));
          } else {
            imports.push(anyTypeAlias(fragmentTypeName));
          }
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }

  return imports;
}

function getEnumDefinitions(schema, _ref3) {
  var enumsHasteModule = _ref3.enumsHasteModule,
      usedEnums = _ref3.usedEnums,
      noFutureProofEnums = _ref3.noFutureProofEnums;
  var enumNames = Object.keys(usedEnums).sort();

  if (enumNames.length === 0) {
    return [];
  }

  if (typeof enumsHasteModule === 'string') {
    return [importTypes(enumNames, enumsHasteModule)];
  }

  if (typeof enumsHasteModule === 'function') {
    return enumNames.map(function (enumName) {
      return importTypes([enumName], enumsHasteModule(enumName));
    });
  }

  return enumNames.map(function (name) {
    var values = [].concat(schema.getEnumValues(usedEnums[name]));
    values.sort();

    if (!noFutureProofEnums) {
      values.push('%future added value');
    }

    return exportType(name, t.unionTypeAnnotation(values.map(function (value) {
      return t.stringLiteralTypeAnnotation(value);
    })));
  });
} // If it's a @refetchable fragment, we generate the $fragmentRef in generated
// query, and import it in the fragment to avoid circular dependencies


function getRefetchableQueryParentFragmentName(state, metadata) {
  if (!(metadata === null || metadata === void 0 ? void 0 : metadata.isRefetchableQuery) || !state.useHaste && !state.useSingleArtifactDirectory) {
    return null;
  }

  var derivedFrom = metadata === null || metadata === void 0 ? void 0 : metadata.derivedFrom;

  if (derivedFrom != null && typeof derivedFrom === 'string') {
    return derivedFrom;
  }

  return null;
}

function getRefetchableQueryPath(state, directives) {
  var _directives$find;

  var refetchableQuery;

  if (!state.useHaste && !state.useSingleArtifactDirectory) {
    return;
  }

  var refetchableArgs = (_directives$find = directives.find(function (d) {
    return d.name === 'refetchable';
  })) === null || _directives$find === void 0 ? void 0 : _directives$find.args;

  if (!refetchableArgs) {
    return;
  }

  var argument = refetchableArgs.find(function (arg) {
    return arg.kind === 'Argument' && arg.name === 'queryName';
  });

  if (argument && argument.value && argument.value.kind === 'Literal' && typeof argument.value.value === 'string') {
    refetchableQuery = argument.value.value;

    if (!state.useHaste) {
      refetchableQuery = './' + refetchableQuery;
    }

    refetchableQuery += '.graphql';
  }

  return refetchableQuery;
}

function generateFragmentRefsForRefetchable(name) {
  var oldFragmentTypeName = getOldFragmentTypeName(name);
  var newFragmentTypeName = getNewFragmentTypeName(name);
  return [declareExportOpaqueType(oldFragmentTypeName, 'FragmentReference'), declareExportOpaqueType(newFragmentTypeName, oldFragmentTypeName)];
}

function getFragmentTypes(name, refetchableQueryPath) {
  var oldFragmentTypeName = getOldFragmentTypeName(name);
  var newFragmentTypeName = getNewFragmentTypeName(name);

  if (refetchableQueryPath) {
    return [importTypes([oldFragmentTypeName, newFragmentTypeName], refetchableQueryPath), exportTypes([oldFragmentTypeName, newFragmentTypeName])];
  }

  return [declareExportOpaqueType(oldFragmentTypeName, 'FragmentReference'), declareExportOpaqueType(newFragmentTypeName, oldFragmentTypeName)];
}

function getOldFragmentTypeName(name) {
  return "".concat(name, "$ref");
}

function getNewFragmentTypeName(name) {
  return "".concat(name, "$fragmentType");
}

function getRefTypeName(name) {
  return "".concat(name, "$key");
}

function getDataTypeName(name) {
  return "".concat(name, "$data");
}

var FLOW_TRANSFORMS = [RelayDirectiveTransform.transform, MaskTransform.transform, MatchTransform.transform, RequiredFieldTransform.transform, FlattenTransform.transformWithOptions({}), RefetchableFragmentTransform.transform];
var DIRECTIVE_NAME = 'raw_response_type';
module.exports = {
  generate: Profiler.instrument(generate, 'RelayFlowGenerator.generate'),
  transforms: FLOW_TRANSFORMS,
  SCHEMA_EXTENSION: "directive @".concat(DIRECTIVE_NAME, " on QUERY | MUTATION | SUBSCRIPTION")
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var IRTransformer = __webpack_require__(3);

var partitionArray = __webpack_require__(16);

var _require = __webpack_require__(1),
    createUserError = _require.createUserError,
    createCompilerError = _require.createCompilerError;

var _require2 = __webpack_require__(11),
    RelayFeatureFlags = _require2.RelayFeatureFlags;

var SCHEMA_EXTENSION = "\n  enum RequiredFieldAction {\n    NONE\n    LOG\n    THROW\n  }\n  directive @required(\n    action: RequiredFieldAction!\n  ) on FIELD\n";
/**
 * This transform rewrites ScalarField and LinkedField nodes with a @required
 * directive into fields with the directives stripped and sets the `required`
 * and `path` metadata values.
 */

function requiredFieldTransform(context) {
  var schema = context.getSchema();
  return IRTransformer.transform(context, {
    LinkedField: visitLinkedField,
    ScalarField: vistitScalarField,
    InlineFragment: visitInlineFragment,
    Fragment: visitFragment,
    Root: visitRoot
  }, function (node) {
    return {
      schema: schema,
      documentName: node.name,
      path: [],
      pathRequiredMap: new Map(),
      currentNodeRequiredChildren: new Map(),
      requiredChildrenMap: new Map(),
      parentAbstractInlineFragment: null
    };
  });
}

function visitFragment(fragment, state) {
  // $FlowFixMe[incompatible-use]
  return addChildrenCanBubbleMetadata(this.traverse(fragment, state), state);
}

function visitRoot(root, state) {
  // $FlowFixMe[incompatible-use]
  return addChildrenCanBubbleMetadata(this.traverse(root, state), state);
}

function visitInlineFragment(fragment, state) {
  var _state$parentAbstract;

  // Ideally we could allow @required when the direct parent inline fragment was
  // on a concrete type, but we would need to solve this bug in our Flow type
  // generation first: T65695438
  var parentAbstractInlineFragment = (_state$parentAbstract = state.parentAbstractInlineFragment) !== null && _state$parentAbstract !== void 0 ? _state$parentAbstract : getAbstractInlineFragment(fragment, state.schema); // $FlowFixMe[incompatible-use]

  return this.traverse(fragment, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
    parentAbstractInlineFragment: parentAbstractInlineFragment
  }));
}

function getAbstractInlineFragment(fragment, schema) {
  var typeCondition = fragment.typeCondition;

  if (schema.isAbstractType(typeCondition)) {
    return fragment;
  }

  return null;
} // Convert action to a number so that we can numerically compare their severity.


function getActionSeverity(action) {
  switch (action) {
    case 'NONE':
      return 0;

    case 'LOG':
      return 1;

    case 'THROW':
      return 2;

    default:
      action;
      throw createCompilerError("Unhandled action type ".concat(action));
  }
}

function visitLinkedField(field, state) {
  var path = [].concat((0, _toConsumableArray2["default"])(state.path), [field.alias]);
  var newState = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
    currentNodeRequiredChildren: new Map(),
    path: path,
    parentAbstractInlineFragment: null
  }); // $FlowFixMe[incompatible-use]

  var newField = this.traverse(field, newState);
  var pathName = path.join('.');
  assertCompatibleRequiredChildren(field, pathName, newState);
  newField = applyDirectives(newField, pathName, state.documentName);
  assertCompatibleNullability(newField, pathName, newState.pathRequiredMap);
  var directiveMetadata = getRequiredDirectiveMetadata(newField);

  if (directiveMetadata != null) {
    assertParentIsNotInvalidInlineFragmet(state.schema, directiveMetadata, state.parentAbstractInlineFragment);
    state.currentNodeRequiredChildren.set(field.alias, newField);
    var severity = getActionSeverity(directiveMetadata.action); // Assert that all @required children have at least this severity.

    newState.currentNodeRequiredChildren.forEach(function (childField) {
      var childMetadata = getRequiredDirectiveMetadata(childField);

      if (childMetadata == null) {
        return;
      }

      if (getActionSeverity(childMetadata.action) < severity) {
        throw createUserError("The @required field [1] may not have an `action` less severe than that of its @required parent [2]. [1] should probably be `action: ".concat(directiveMetadata.action, "`."), [childMetadata.actionLoc, directiveMetadata.actionLoc]);
      }
    });
  }

  state.requiredChildrenMap.set(pathName, newState.currentNodeRequiredChildren);
  return addChildrenCanBubbleMetadata(newField, newState);
}

function vistitScalarField(field, state) {
  var pathName = [].concat((0, _toConsumableArray2["default"])(state.path), [field.alias]).join('.');
  var newField = applyDirectives(field, pathName, state.documentName);
  var directiveMetadata = getRequiredDirectiveMetadata(newField);

  if (directiveMetadata != null) {
    assertParentIsNotInvalidInlineFragmet(state.schema, directiveMetadata, state.parentAbstractInlineFragment);
    state.currentNodeRequiredChildren.set(field.alias, newField);
  }

  assertCompatibleNullability(newField, pathName, state.pathRequiredMap);
  return newField;
}

function addChildrenCanBubbleMetadata(node, state) {
  var _iterator = (0, _createForOfIteratorHelper2["default"])(state.currentNodeRequiredChildren.values()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;
      var requiredMetadata = getRequiredDirectiveMetadata(child);

      if (requiredMetadata != null && requiredMetadata.action !== 'THROW') {
        var metadata = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node.metadata), {}, {
          childrenCanBubbleNull: true
        });
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, node), {}, {
          metadata: metadata
        });
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return node;
}

function assertParentIsNotInvalidInlineFragmet(schema, directiveMetadata, parentAbstractInlineFragment) {
  if (parentAbstractInlineFragment == null) {
    return;
  }

  var typeCondition = parentAbstractInlineFragment.typeCondition;

  if (schema.isUnion(typeCondition)) {
    throw createUserError('The @required directive [1] may not be used anywhere within an inline fragment on a union type [2].', [directiveMetadata.directiveLoc, parentAbstractInlineFragment.loc]);
  } else if (schema.isInterface(typeCondition)) {
    throw createUserError('The @required directive [1] may not be used anywhere within an inline fragment on an interface type [2].', [directiveMetadata.directiveLoc, parentAbstractInlineFragment.loc]);
  } else {
    throw createCompilerError('Unexpected abstract inline fragment type.', [parentAbstractInlineFragment.loc]);
  }
} // Check that this field's nullability matches all other instances.


function assertCompatibleNullability(field, pathName, pathRequiredMap) {
  var existingField = pathRequiredMap.get(pathName);

  if (existingField == null) {
    pathRequiredMap.set(pathName, field);
    return;
  }

  var requiredMetadata = getRequiredDirectiveMetadata(field);
  var existingRequiredMetadata = getRequiredDirectiveMetadata(existingField);

  if ((requiredMetadata === null || requiredMetadata === void 0 ? void 0 : requiredMetadata.action) === (existingRequiredMetadata === null || existingRequiredMetadata === void 0 ? void 0 : existingRequiredMetadata.action)) {
    return;
  }

  if (requiredMetadata == null) {
    throw createUserError("The field \"".concat(field.alias, "\" is @required in [1] but not in [2]."), [existingField.loc, field.loc]);
  }

  if (existingRequiredMetadata == null) {
    throw createUserError("The field \"".concat(field.alias, "\" is @required in [1] but not in [2]."), [field.loc, existingField.loc]);
  }

  throw createUserError("The field \"".concat(field.alias, "\" has a different @required action in [1] than in [2]."), [requiredMetadata.actionLoc, existingRequiredMetadata.actionLoc]);
} // Metadata is untyped, so we use this utility function to do the type coersion.


function getRequiredDirectiveMetadata(field) {
  var _field$metadata;

  return (_field$metadata = field.metadata) === null || _field$metadata === void 0 ? void 0 : _field$metadata.required;
} // Check that this field has the same required children as all other instances.


function assertCompatibleRequiredChildren(field, fieldPath, _ref) {
  var currentNodeRequiredChildren = _ref.currentNodeRequiredChildren,
      pathRequiredMap = _ref.pathRequiredMap,
      requiredChildrenMap = _ref.requiredChildrenMap;
  var previouslyRequiredChildren = requiredChildrenMap.get(fieldPath);

  if (previouslyRequiredChildren == null) {
    return;
  } // Check if this field has a required child field which was previously omitted.


  var _iterator2 = (0, _createForOfIteratorHelper2["default"])(currentNodeRequiredChildren),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _step2.value,
          path = _step2$value[0],
          childField = _step2$value[1];

      if (!previouslyRequiredChildren.has(path)) {
        var otherParent = pathRequiredMap.get(fieldPath);

        if (otherParent == null) {
          throw createCompilerError("Could not find other parent node at path \"".concat(fieldPath, "\"."), [childField.loc]);
        }

        throw createMissingRequiredFieldError(childField, otherParent);
      }
    } // Check if a previous reference to this field had a required child field which we are missing.

  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var _iterator3 = (0, _createForOfIteratorHelper2["default"])(previouslyRequiredChildren),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          _path = _step3$value[0],
          _childField = _step3$value[1];

      if (!currentNodeRequiredChildren.has(_path)) {
        throw createMissingRequiredFieldError(_childField, field);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

function createMissingRequiredFieldError(requiredChild, missingParent) {
  var alias = requiredChild.alias;
  return createUserError("The field \"".concat(alias, "\" is marked as @required in [1] but is missing in [2]."), [requiredChild.loc, missingParent.loc]);
} // TODO T74397896: Remove prefix gating once @required is rolled out more broadly.


function featureIsEnabled(documentName) {
  var featureFlag = RelayFeatureFlags.ENABLE_REQUIRED_DIRECTIVES;

  if (typeof featureFlag === 'boolean') {
    return featureFlag;
  } else if (featureFlag === 'LIMITED') {
    return documentName.startsWith('RelayRequiredTest');
  } else if (typeof featureFlag === 'string') {
    return featureFlag.split('|').some(function (prefix) {
      return documentName.startsWith(prefix);
    });
  }

  return false;
} // Strip and validate @required directives, and convert them to metadata.


function applyDirectives(field, pathName, documentName) {
  var _partitionArray = partitionArray(field.directives, function (directive) {
    return directive.name === 'required';
  }),
      requiredDirectives = _partitionArray[0],
      otherDirectives = _partitionArray[1];

  if (requiredDirectives.length === 0) {
    return field;
  }

  if (!featureIsEnabled(documentName)) {
    throw new createUserError( // Purposefully don't include details in this error message, since we
    // don't want folks adopting this feature until it's been tested more.
    'The @required directive is experimental and not yet supported for use in product code', requiredDirectives.map(function (x) {
      return x.loc;
    }));
  }

  if (requiredDirectives.length > 1) {
    throw new createUserError('Did not expect multiple @required directives.', requiredDirectives.map(function (x) {
      return x.loc;
    }));
  }

  var requiredDirective = requiredDirectives[0];
  var arg = requiredDirective.args[0]; // I would expect this check to be handled by the schema validation, but...

  if (arg == null) {
    throw createUserError('The @required directive requires an `action` argument.', [requiredDirective.loc]);
  }

  if (arg.value.kind !== 'Literal') {
    throw createUserError('Expected @required `action` argument to be a literal.', [arg.value.loc]);
  }

  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, field), {}, {
    directives: otherDirectives,
    metadata: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, field.metadata), {}, {
      required: {
        action: arg.value.value,
        actionLoc: arg.loc,
        directiveLoc: requiredDirective.loc,
        path: pathName
      }
    })
  });
} // Transform @required directive to metadata


module.exports = {
  SCHEMA_EXTENSION: SCHEMA_EXTENSION,
  transform: requiredFieldTransform
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var invariant = __webpack_require__(6);

var t = __webpack_require__(26);

/**
 * type NAME = any;
 */
function anyTypeAlias(name) {
  return t.typeAlias(t.identifier(name), undefined, t.anyTypeAnnotation());
}
/**
 * {|
 *   PROPS
 * |}
 */


function exactObjectTypeAnnotation(props) {
  var typeAnnotation = t.objectTypeAnnotation(props);
  typeAnnotation.exact = true;
  return typeAnnotation;
}
/**
 * {
 *   PROPS
 *   ...
 * }
 */


function inexactObjectTypeAnnotation(props) {
  var typeAnnotation = t.objectTypeAnnotation(props);
  typeAnnotation.inexact = true;
  return typeAnnotation;
}
/**
 * export type NAME = TYPE
 */


function exportType(name, type) {
  return t.exportNamedDeclaration(t.typeAlias(t.identifier(name), undefined, type), [], undefined);
}
/**
 * export type {A, B, C}
 */


function exportTypes(names) {
  var res = t.exportNamedDeclaration(undefined, names.map(function (name) {
    return t.exportSpecifier(t.identifier(name), t.identifier(name));
  }), undefined);
  res.exportKind = 'type';
  return res;
}
/**
 * declare export type NAME = VALUE
 */


function declareExportOpaqueType(name, value) {
  return t.declareExportDeclaration(t.declareOpaqueType(t.identifier(name), undefined, t.genericTypeAnnotation(t.identifier(value))));
}
/**
 * import type {NAMES[0], NAMES[1], ...} from 'MODULE';
 */


function importTypes(names, module) {
  var importDeclaration = t.importDeclaration(names.map(function (name) {
    return t.importSpecifier(t.identifier(name), t.identifier(name));
  }), t.stringLiteral(module));
  importDeclaration.importKind = 'type';
  return importDeclaration;
}
/**
 * Create an intersection type if needed.
 *
 * TYPES[0] & TYPES[1] & ...
 */


function intersectionTypeAnnotation(types) {
  !(types.length > 0) ?  true ? invariant(false, 'RelayFlowBabelFactories: cannot create an intersection of 0 types') : undefined : void 0;
  return types.length === 1 ? types[0] : t.intersectionTypeAnnotation(types);
}

function lineComments() {
  for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
    lines[_key] = arguments[_key];
  }

  return lines.map(function (line) {
    return {
      type: 'CommentLine',
      value: ' ' + line
    };
  });
}
/**
 * $ReadOnlyArray<TYPE>
 */


function readOnlyArrayOfType(thing) {
  return t.genericTypeAnnotation(t.identifier('$ReadOnlyArray'), t.typeParameterInstantiation([thing]));
}
/**
 * +KEY: VALUE
 */


function readOnlyObjectTypeProperty(key, value) {
  var prop = t.objectTypeProperty(t.identifier(key), value);
  prop.variance = t.variance('plus');
  return prop;
}

function stringLiteralTypeAnnotation(value) {
  return t.stringLiteralTypeAnnotation(value);
}
/**
 * Create a union type if needed.
 *
 * TYPES[0] | TYPES[1] | ...
 */


function unionTypeAnnotation(types) {
  !(types.length > 0) ?  true ? invariant(false, 'RelayFlowBabelFactories: cannot create a union of 0 types') : undefined : void 0;
  return types.length === 1 ? types[0] : t.unionTypeAnnotation(types);
}

module.exports = {
  anyTypeAlias: anyTypeAlias,
  declareExportOpaqueType: declareExportOpaqueType,
  exactObjectTypeAnnotation: exactObjectTypeAnnotation,
  inexactObjectTypeAnnotation: inexactObjectTypeAnnotation,
  exportType: exportType,
  exportTypes: exportTypes,
  importTypes: importTypes,
  intersectionTypeAnnotation: intersectionTypeAnnotation,
  lineComments: lineComments,
  readOnlyArrayOfType: readOnlyArrayOfType,
  readOnlyObjectTypeProperty: readOnlyObjectTypeProperty,
  stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
  unionTypeAnnotation: unionTypeAnnotation
};

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _yargs = __webpack_require__(53);

var _require = __webpack_require__(54),
    main = _require.main;

var RelayConfig;

try {
  // eslint-disable-next-line no-eval
  RelayConfig = eval('require')('relay-config'); // eslint-disable-next-line lint/no-unused-catch-bindings
} catch (_) {}

var options = {
  schema: {
    describe: 'Path to schema.graphql or schema.json',
    demandOption: true,
    type: 'string',
    array: false
  },
  src: {
    describe: 'Root directory of application code',
    demandOption: true,
    type: 'string',
    array: false
  },
  include: {
    describe: 'Directories to include under src',
    type: 'string',
    array: true,
    "default": ['**']
  },
  exclude: {
    describe: 'Directories to ignore under src',
    type: 'string',
    array: true,
    "default": ['**/node_modules/**', '**/__mocks__/**', '**/__generated__/**']
  },
  extensions: {
    array: true,
    describe: 'File extensions to compile (defaults to extensions provided by the ' + 'language plugin)',
    type: 'string'
  },
  verbose: {
    describe: 'More verbose logging',
    type: 'boolean',
    "default": false
  },
  quiet: {
    describe: 'No output to stdout',
    type: 'boolean',
    "default": false
  },
  watchman: {
    describe: 'Use watchman when not in watch mode',
    type: 'boolean',
    "default": true
  },
  watch: {
    describe: 'If specified, watches files and regenerates on changes',
    type: 'boolean',
    "default": false
  },
  validate: {
    describe: 'Looks for pending changes and exits with non-zero code instead of ' + 'writing to disk',
    type: 'boolean',
    "default": false
  },
  persistFunction: {
    describe: 'An async function (or path to a module exporting this function) which will persist the query text and return the id.',
    demandOption: false,
    type: 'string',
    array: false
  },
  persistOutput: {
    describe: 'A path to a .json file where persisted query metadata should be saved. Will use the default implementation (md5 hash) if `persistFunction` is not passed.',
    demandOption: false,
    type: 'string',
    array: false
  },
  repersist: {
    describe: 'Run the persist function even if the query has not changed.',
    type: 'boolean',
    "default": false
  },
  noFutureProofEnums: {
    describe: 'This option controls whether or not a catch-all entry is added to enum type definitions ' + 'for values that may be added in the future. Enabling this means you will have to update ' + 'your application whenever the GraphQL server schema adds new enum values to prevent it ' + 'from breaking.',
    type: 'boolean',
    "default": false
  },
  language: {
    describe: 'The name of the language plugin used for input files and artifacts',
    demandOption: false,
    type: 'string',
    array: false,
    "default": 'javascript'
  },
  artifactDirectory: {
    describe: 'A specific directory to output all artifacts to. When enabling this ' + 'the babel plugin needs `artifactDirectory` set as well.',
    demandOption: false,
    type: 'string',
    array: false
  },
  customScalars: {
    describe: 'Mappings from custom scalars in your schema to built-in GraphQL ' + 'types, for type emission purposes. (Uses yargs dot-notation, e.g. ' + '--customScalars.URL=String)',
    type: 'object'
  },
  eagerESModules: {
    describe: 'This option enables emitting es modules artifacts.',
    type: 'boolean',
    "default": false
  }
}; // Parse CLI args

var yargs = _yargs.usage('Create Relay generated files\n\n' + '$0 --schema <path> --src <path> [--watch]').options(options).strict(); // Load external config


var config = RelayConfig && RelayConfig.loadConfig();

if (config) {
  // Apply externally loaded config through the yargs API so that we can leverage yargs' defaults and have them show up
  // in the help banner. We add it conditionally otherwise yargs would add new option `--config` which is confusing for
  // Relay users (it's not Relay Config file).
  yargs = yargs.config(config);
}

var argv = yargs.help().argv; // Start the application

main(argv)["catch"](function (error) {
  console.error(String(error.stack || error));
  process.exit(1);
});

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = require("yargs");

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _asyncToGenerator = __webpack_require__(12);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(27));

var _objectSpread2 = _interopRequireDefault(__webpack_require__(2));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var CodegenRunner = __webpack_require__(55);

var ConsoleReporter = __webpack_require__(61);

var DotGraphQLParser = __webpack_require__(63);

var RelayFileWriter = __webpack_require__(64);

var RelayIRTransforms = __webpack_require__(77);

var RelayLanguagePluginJavaScript = __webpack_require__(114);

var RelaySourceModuleParser = __webpack_require__(118);

var WatchmanClient = __webpack_require__(23);

var crypto = __webpack_require__(14);

var fs = __webpack_require__(13);

var glob = __webpack_require__(123);

var invariant = __webpack_require__(6);

var path = __webpack_require__(9);

var _require = __webpack_require__(8),
    buildClientSchema = _require.buildClientSchema,
    Source = _require.Source,
    printSchema = _require.printSchema;

var commonTransforms = RelayIRTransforms.commonTransforms,
    codegenTransforms = RelayIRTransforms.codegenTransforms,
    fragmentTransforms = RelayIRTransforms.fragmentTransforms,
    printTransforms = RelayIRTransforms.printTransforms,
    queryTransforms = RelayIRTransforms.queryTransforms,
    relaySchemaExtensions = RelayIRTransforms.schemaExtensions;

function buildWatchExpression(config) {
  return ['allof', ['type', 'f'], ['anyof'].concat((0, _toConsumableArray2["default"])(config.extensions.map(function (ext) {
    return ['suffix', ext];
  }))), ['anyof'].concat((0, _toConsumableArray2["default"])(config.include.map(function (include) {
    return ['match', include, 'wholename'];
  })))].concat((0, _toConsumableArray2["default"])(config.exclude.map(function (exclude) {
    return ['not', ['match', exclude, 'wholename']];
  })));
}

function getFilepathsFromGlob(baseDir, config) {
  var extensions = config.extensions,
      include = config.include,
      exclude = config.exclude;
  var files = new Set();
  include.forEach(function (inc) {
    return glob.sync("".concat(inc, "/*.+(").concat(extensions.join('|'), ")"), {
      cwd: baseDir,
      ignore: exclude
    }).forEach(function (file) {
      return files.add(file);
    });
  });
  return Array.from(files);
}

/**
 * Unless the requested plugin is the builtin `javascript` one, import a
 * language plugin as either a CommonJS or ES2015 module.
 *
 * When importing, first check if its a path to an existing file, otherwise
 * assume its a package and prepend the plugin namespace prefix.
 *
 * Make sure to always use Node's `require` function, which otherwise would get
 * replaced with `__webpack_require__` when bundled using webpack, by using
 * `eval` to get it at runtime.
 */
function getLanguagePlugin(language, options) {
  if (language === 'javascript') {
    return RelayLanguagePluginJavaScript({
      eagerESModules: Boolean(options && options.eagerESModules)
    });
  } else {
    var languagePlugin;

    if (typeof language === 'string') {
      var pluginPath = path.resolve(process.cwd(), language);
      var requirePath = fs.existsSync(pluginPath) ? pluginPath : "relay-compiler-language-".concat(language);

      try {
        // eslint-disable-next-line no-eval
        languagePlugin = eval('require')(requirePath);

        if (languagePlugin["default"]) {
          languagePlugin = languagePlugin["default"];
        }
      } catch (err) {
        var e = new Error("Unable to load language plugin ".concat(requirePath, ": ").concat(err.message));
        e.stack = err.stack;
        throw e;
      }
    } else {
      languagePlugin = language;
    }

    if (languagePlugin["default"] != null) {
      /* $FlowFixMe[incompatible-type] - Flow no longer considers statics of
       * functions as any */
      languagePlugin = languagePlugin["default"];
    }

    if (typeof languagePlugin === 'function') {
      // $FlowFixMe[incompatible-use]
      return languagePlugin();
    } else {
      throw new Error('Expected plugin to be a initializer function.');
    }
  }
}

function getPersistQueryFunction(config) {
  var configValue = config.persistFunction;

  if (configValue == null) {
    return null;
  } else if (typeof configValue === 'string') {
    try {
      // eslint-disable-next-line no-eval
      var persistFunction = eval('require')(path.resolve(process.cwd(), configValue));

      if (persistFunction["default"]) {
        return persistFunction["default"];
      }

      return persistFunction;
    } catch (err) {
      var e = new Error("Unable to load persistFunction ".concat(configValue, ": ").concat(err.message));
      e.stack = err.stack;
      throw e;
    }
  } else if (typeof configValue === 'function') {
    return configValue;
  } else {
    throw new Error('Expected persistFunction to be a path string or a function.');
  }
}

function main(_x) {
  return _main.apply(this, arguments);
}

function _main() {
  _main = _asyncToGenerator(function* (defaultConfig) {
    if (defaultConfig.verbose && defaultConfig.quiet) {
      throw new Error("I can't be quiet and verbose at the same time");
    }

    var config = getPathBasedConfig(defaultConfig);
    config = yield getWatchConfig(config); // Use function from module.exports to be able to mock it for tests

    var codegenRunner = module.exports.getCodegenRunner(config);
    var result = config.watch ? yield codegenRunner.watchAll() : yield codegenRunner.compileAll();

    if (result === 'ERROR') {
      process.exit(100);
    }

    if (config.validate && result !== 'NO_CHANGES') {
      process.exit(101);
    }
  });
  return _main.apply(this, arguments);
}

function getPathBasedConfig(config) {
  var schema = path.resolve(process.cwd(), config.schema);

  if (!fs.existsSync(schema)) {
    throw new Error("--schema path does not exist: ".concat(schema));
  }

  var src = path.resolve(process.cwd(), config.src);

  if (!fs.existsSync(src)) {
    throw new Error("--src path does not exist: ".concat(src));
  }

  var persistOutput = config.persistOutput;

  if (typeof persistOutput === 'string') {
    persistOutput = path.resolve(process.cwd(), persistOutput);
    var persistOutputDir = path.dirname(persistOutput);

    if (!fs.existsSync(persistOutputDir)) {
      throw new Error("--persistOutput path does not exist: ".concat(persistOutput));
    }
  }

  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, config), {}, {
    schema: schema,
    src: src,
    persistOutput: persistOutput
  });
}

function getWatchConfig(_x2) {
  return _getWatchConfig.apply(this, arguments);
}

function _getWatchConfig() {
  _getWatchConfig = _asyncToGenerator(function* (config) {
    var watchman = config.watchman && (yield WatchmanClient.isAvailable());

    if (config.watch) {
      if (!watchman) {
        console.error('Watchman is required to watch for changes. Running with watch mode disabled.');
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, config), {}, {
          watch: false,
          watchman: false
        });
      }

      if (!module.exports.hasWatchmanRootFile(config.src)) {
        throw new Error("\n--watch requires that the src directory have a valid watchman \"root\" file.\n\nRoot files can include:\n- A .git/ Git folder\n- A .hg/ Mercurial folder\n- A .watchmanconfig file\n\nEnsure that one such file exists in ".concat(config.src, " or its parents.\n      ").trim());
      }
    } else if (watchman && !config.validate) {
      // eslint-disable-next-line no-console
      console.log('HINT: pass --watch to keep watching for changes.');
    }

    return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, config), {}, {
      watchman: watchman
    });
  });
  return _getWatchConfig.apply(this, arguments);
}

function getCodegenRunner(config) {
  var _parserConfigs;

  var reporter = new ConsoleReporter({
    verbose: config.verbose,
    quiet: config.quiet
  });
  var schema = getSchemaSource(config.schema);
  var languagePlugin = getLanguagePlugin(config.language, {
    eagerESModules: config.eagerESModules === true
  });
  var persistQueryFunction = getPersistQueryFunction(config);
  var inputExtensions = config.extensions || languagePlugin.inputExtensions;
  var outputExtension = languagePlugin.outputExtension;
  var sourceParserName = inputExtensions.join('/');
  var sourceWriterName = outputExtension;
  var sourceModuleParser = RelaySourceModuleParser(languagePlugin.findGraphQLTags, languagePlugin.getFileFilter);
  var providedArtifactDirectory = config.artifactDirectory;
  var artifactDirectory = providedArtifactDirectory != null ? path.resolve(process.cwd(), providedArtifactDirectory) : null;
  var generatedDirectoryName = artifactDirectory !== null && artifactDirectory !== void 0 ? artifactDirectory : '__generated__';
  var sourceSearchOptions = {
    extensions: inputExtensions,
    include: config.include,
    exclude: ['**/*.graphql.*'].concat((0, _toConsumableArray2["default"])(config.exclude))
  };
  var graphqlSearchOptions = {
    extensions: ['graphql'],
    include: config.include,
    exclude: [path.relative(config.src, config.schema)].concat(config.exclude)
  };

  var defaultIsGeneratedFile = function defaultIsGeneratedFile(filePath) {
    return filePath.endsWith('.graphql.' + outputExtension) && filePath.includes(generatedDirectoryName);
  };

  var schemaExtensions = languagePlugin.schemaExtensions ? [].concat((0, _toConsumableArray2["default"])(languagePlugin.schemaExtensions), (0, _toConsumableArray2["default"])(relaySchemaExtensions)) : relaySchemaExtensions;
  var parserConfigs = (_parserConfigs = {}, (0, _defineProperty2["default"])(_parserConfigs, sourceParserName, {
    baseDir: config.src,
    getFileFilter: sourceModuleParser.getFileFilter,
    getParser: sourceModuleParser.getParser,
    getSchemaSource: function getSchemaSource() {
      return schema;
    },
    schemaExtensions: schemaExtensions,
    watchmanExpression: config.watchman ? buildWatchExpression(sourceSearchOptions) : null,
    filepaths: config.watchman ? null : getFilepathsFromGlob(config.src, sourceSearchOptions)
  }), (0, _defineProperty2["default"])(_parserConfigs, "graphql", {
    baseDir: config.src,
    getParser: DotGraphQLParser.getParser,
    getSchemaSource: function getSchemaSource() {
      return schema;
    },
    schemaExtensions: schemaExtensions,
    watchmanExpression: config.watchman ? buildWatchExpression(graphqlSearchOptions) : null,
    filepaths: config.watchman ? null : getFilepathsFromGlob(config.src, graphqlSearchOptions)
  }), _parserConfigs);
  var writerConfigs = (0, _defineProperty2["default"])({}, sourceWriterName, {
    writeFiles: getRelayFileWriter(config.src, languagePlugin, config.noFutureProofEnums, artifactDirectory, config.persistOutput, config.customScalars, persistQueryFunction, config.repersist),
    isGeneratedFile: languagePlugin.isGeneratedFile ? languagePlugin.isGeneratedFile : defaultIsGeneratedFile,
    parser: sourceParserName,
    baseParsers: ['graphql']
  });
  var codegenRunner = new CodegenRunner({
    reporter: reporter,
    parserConfigs: parserConfigs,
    writerConfigs: writerConfigs,
    onlyValidate: config.validate,
    // TODO: allow passing in a flag or detect?
    sourceControl: null
  });
  return codegenRunner;
}

function defaultPersistFunction(text) {
  var hasher = crypto.createHash('md5');
  hasher.update(text);
  var id = hasher.digest('hex');
  return Promise.resolve(id);
}

function getRelayFileWriter(baseDir, languagePlugin, noFutureProofEnums, outputDir, persistedQueryPath, customScalars, persistFunction, repersist) {
  return /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (_ref) {
      var onlyValidate = _ref.onlyValidate,
          schema = _ref.schema,
          documents = _ref.documents,
          baseDocuments = _ref.baseDocuments,
          sourceControl = _ref.sourceControl,
          reporter = _ref.reporter;
      var persistQuery;
      var queryMap;

      if (persistFunction != null || persistedQueryPath != null) {
        queryMap = new Map();
        var persistImplmentation = persistFunction || defaultPersistFunction;

        persistQuery = /*#__PURE__*/function () {
          var _persistQuery = _asyncToGenerator(function* (text) {
            var id = yield persistImplmentation(text);
            !(typeof id === 'string') ?  true ? invariant(false, 'Expected persist function to return a string, got `%s`.', id) : undefined : void 0;
            queryMap.set(id, text);
            return id;
          });

          function persistQuery(_x4) {
            return _persistQuery.apply(this, arguments);
          }

          return persistQuery;
        }();
      }

      var schemaExtensions = languagePlugin.schemaExtensions ? [].concat((0, _toConsumableArray2["default"])(languagePlugin.schemaExtensions), (0, _toConsumableArray2["default"])(relaySchemaExtensions)) : relaySchemaExtensions;
      var results = yield RelayFileWriter.writeAll({
        config: {
          baseDir: baseDir,
          compilerTransforms: {
            commonTransforms: commonTransforms,
            codegenTransforms: codegenTransforms,
            fragmentTransforms: fragmentTransforms,
            printTransforms: printTransforms,
            queryTransforms: queryTransforms
          },
          customScalars: customScalars || {},
          formatModule: languagePlugin.formatModule,
          optionalInputFieldsForFlow: [],
          schemaExtensions: schemaExtensions,
          useHaste: false,
          noFutureProofEnums: noFutureProofEnums,
          extension: languagePlugin.outputExtension,
          typeGenerator: languagePlugin.typeGenerator,
          outputDir: outputDir,
          persistQuery: persistQuery,
          repersist: repersist
        },
        onlyValidate: onlyValidate,
        schema: schema,
        baseDocuments: baseDocuments,
        documents: documents,
        reporter: reporter,
        sourceControl: sourceControl,
        languagePlugin: languagePlugin
      });

      if (queryMap != null && persistedQueryPath != null) {
        var object = {};

        if (fs.existsSync(persistedQueryPath)) {
          try {
            var prevText = fs.readFileSync(persistedQueryPath, 'utf8');
            var prevData = JSON.parse(prevText);

            if (prevData != null && typeof prevData === 'object') {
              object = prevData;
            } else {
              console.error("Invalid data in persisted query file '".concat(persistedQueryPath, "', expected an object."));
            }
          } catch (error) {
            console.error(error);
          }
        }

        var _iterator = (0, _createForOfIteratorHelper2["default"])(queryMap.entries()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _step.value,
                id = _step$value[0],
                _text = _step$value[1];
            object[id] = _text;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var data = JSON.stringify(object, null, 2);
        fs.writeFileSync(persistedQueryPath, data, 'utf8');
      }

      return results;
    });

    return function (_x3) {
      return _ref2.apply(this, arguments);
    };
  }();
}

function getSchemaSource(schemaPath) {
  var source = fs.readFileSync(schemaPath, 'utf8');

  if (path.extname(schemaPath) === '.json') {
    source = printSchema(buildClientSchema(JSON.parse(source).data));
  }

  source = "\n  directive @include(if: Boolean) on FRAGMENT_SPREAD | FIELD | INLINE_FRAGMENT\n  directive @skip(if: Boolean) on FRAGMENT_SPREAD | FIELD | INLINE_FRAGMENT\n\n  ".concat(source, "\n  ");
  return new Source(source, schemaPath);
} // Ensure that a watchman "root" file exists in the given directory
// or a parent so that it can be watched


var WATCHMAN_ROOT_FILES = ['.git', '.hg', '.watchmanconfig'];

function hasWatchmanRootFile(testPath) {
  while (path.dirname(testPath) !== testPath) {
    if (WATCHMAN_ROOT_FILES.some(function (file) {
      return fs.existsSync(path.join(testPath, file));
    })) {
      return true;
    }

    testPath = path.dirname(testPath);
  }

  return false;
}

module.exports = {
  getCodegenRunner: getCodegenRunner,
  getLanguagePlugin: getLanguagePlugin,
  getWatchConfig: getWatchConfig,
  hasWatchmanRootFile: hasWatchmanRootFile,
  main: main
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _asyncToGenerator = __webpack_require__(12);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var CodegenDirectory = __webpack_require__(28);

var CodegenWatcher = __webpack_require__(56);

var GraphQLWatchmanClient = __webpack_require__(23);

var Profiler = __webpack_require__(7);

var invariant = __webpack_require__(6);

var path = __webpack_require__(9);

var _require = __webpack_require__(59),
    createSchema = _require.create;
/* $FlowFixMe[untyped-import] - importing immutable, which is untyped (and flow
 * is sad about it) */


var _require2 = __webpack_require__(15),
    ImmutableMap = _require2.Map;

var CodegenRunner = /*#__PURE__*/function () {
  // parser => writers that are affected by it
  function CodegenRunner(options) {
    var _this = this;

    this.parsers = {};
    this.parserConfigs = options.parserConfigs;
    this.writerConfigs = options.writerConfigs;
    this.onlyValidate = options.onlyValidate;
    this.onComplete = options.onComplete;
    this._reporter = options.reporter;
    this._sourceControl = options.sourceControl;
    this.parserWriters = {};

    for (var _parser in options.parserConfigs) {
      this.parserWriters[_parser] = new Set();
    }

    var _loop = function _loop(_writer) {
      var config = options.writerConfigs[_writer];
      config.baseParsers && config.baseParsers.forEach(function (parser) {
        return _this.parserWriters[parser].add(_writer);
      });

      _this.parserWriters[config.parser].add(_writer);
    };

    for (var _writer in options.writerConfigs) {
      _loop(_writer);
    }
  }

  var _proto = CodegenRunner.prototype;

  _proto.compileAll = /*#__PURE__*/function () {
    var _compileAll = _asyncToGenerator(function* () {
      // reset the parsers
      this.parsers = {};

      for (var parserName in this.parserConfigs) {
        try {
          yield this.parseEverything(parserName);
        } catch (e) {
          this._reporter.reportError('CodegenRunner.compileAll', e);

          return 'ERROR';
        }
      }

      var hasChanges = false;

      for (var writerName in this.writerConfigs) {
        var result = yield this.write(writerName);

        if (result === 'ERROR') {
          return 'ERROR';
        }

        if (result === 'HAS_CHANGES') {
          hasChanges = true;
        }
      }

      return hasChanges ? 'HAS_CHANGES' : 'NO_CHANGES';
    });

    function compileAll() {
      return _compileAll.apply(this, arguments);
    }

    return compileAll;
  }();

  _proto.compile = /*#__PURE__*/function () {
    var _compile = _asyncToGenerator(function* (writerName) {
      var _this2 = this;

      var writerConfig = this.writerConfigs[writerName];
      var parsers = [writerConfig.parser];

      if (writerConfig.baseParsers) {
        writerConfig.baseParsers.forEach(function (parser) {
          return parsers.push(parser);
        });
      } // Don't bother resetting the parsers


      yield Profiler.asyncContext('CodegenRunner:parseEverything', function () {
        return Promise.all(parsers.map(function (parser) {
          return _this2.parseEverything(parser);
        }));
      });
      return yield this.write(writerName);
    });

    function compile(_x) {
      return _compile.apply(this, arguments);
    }

    return compile;
  }();

  _proto.getDirtyWriters = function getDirtyWriters(filePaths) {
    var _this3 = this;

    return Profiler.asyncContext('CodegenRunner:getDirtyWriters', /*#__PURE__*/_asyncToGenerator(function* () {
      var dirtyWriters = new Set(); // Check if any files are in the output

      for (var configName in _this3.writerConfigs) {
        var config = _this3.writerConfigs[configName];

        var _iterator = (0, _createForOfIteratorHelper2["default"])(filePaths),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _filePath = _step.value;

            if (config.isGeneratedFile(_filePath)) {
              dirtyWriters.add(configName);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } // Check for files in the input


      yield Promise.all(Object.keys(_this3.parserConfigs).map(function (parserConfigName) {
        return Profiler.waitFor('Watchman:query', /*#__PURE__*/_asyncToGenerator(function* () {
          var client = new GraphQLWatchmanClient();
          var config = _this3.parserConfigs[parserConfigName];
          var dirs = yield client.watchProject(config.baseDir);
          var relativeFilePaths = filePaths.map(function (filePath) {
            return path.relative(config.baseDir, filePath);
          });
          var query = {
            expression: ['allof', config.watchmanExpression, ['name', relativeFilePaths, 'wholename']],
            fields: ['exists'],
            relative_root: dirs.relativePath
          };
          var result = yield client.command('query', dirs.root, query);
          client.end();

          if (result.files.length > 0) {
            _this3.parserWriters[parserConfigName].forEach(function (writerName) {
              return dirtyWriters.add(writerName);
            });
          }
        }));
      }));
      return dirtyWriters;
    }));
  };

  _proto.parseEverything = /*#__PURE__*/function () {
    var _parseEverything = _asyncToGenerator(function* (parserName) {
      if (this.parsers[parserName]) {
        // no need to parse
        return;
      }

      var parserConfig = this.parserConfigs[parserName];
      this.parsers[parserName] = parserConfig.getParser(parserConfig.baseDir);
      var filter = parserConfig.getFileFilter ? parserConfig.getFileFilter(parserConfig.baseDir) : anyFileFilter;

      if (parserConfig.filepaths && parserConfig.watchmanExpression) {
        throw new Error('Provide either `watchmanExpression` or `filepaths` but not both.');
      }

      var files;

      if (parserConfig.watchmanExpression) {
        files = yield CodegenWatcher.queryFiles(parserConfig.baseDir, parserConfig.watchmanExpression, filter);
      } else if (parserConfig.filepaths) {
        files = yield CodegenWatcher.queryFilepaths(parserConfig.baseDir, parserConfig.filepaths, filter);
      } else {
        throw new Error('Either `watchmanExpression` or `filepaths` is required to query files');
      }

      this.parseFileChanges(parserName, files);
    });

    function parseEverything(_x2) {
      return _parseEverything.apply(this, arguments);
    }

    return parseEverything;
  }();

  _proto.parseFileChanges = function parseFileChanges(parserName, files) {
    var _this4 = this;

    return Profiler.run('CodegenRunner.parseFileChanges', function () {
      var parser = _this4.parsers[parserName]; // this maybe should be await parser.parseFiles(files);

      parser.parseFiles(files);
    });
  } // We cannot do incremental writes right now.
  // When we can, this could be writeChanges(writerName, parserName, parsedDefinitions)
  ;

  _proto.write = function write(writerName) {
    var _this5 = this;

    return Profiler.asyncContext('CodegenRunner.write', /*#__PURE__*/_asyncToGenerator(function* () {
      try {
        _this5._reporter.reportMessage("\nWriting ".concat(writerName));

        var _this5$writerConfigs$ = _this5.writerConfigs[writerName],
            writeFiles = _this5$writerConfigs$.writeFiles,
            _parser2 = _this5$writerConfigs$.parser,
            baseParsers = _this5$writerConfigs$.baseParsers,
            isGeneratedFile = _this5$writerConfigs$.isGeneratedFile;
        var baseDocuments = ImmutableMap();

        if (baseParsers) {
          baseParsers.forEach(function (baseParserName) {
            !(_this5.parsers[baseParserName] != null) ?  true ? invariant(false, 'Trying to access an uncompiled base parser config: %s', baseParserName) : undefined : void 0;
            baseDocuments = baseDocuments.merge(_this5.parsers[baseParserName].documents());
          });
        }

        var _this5$parserConfigs$ = _this5.parserConfigs[_parser2],
            _baseDir = _this5$parserConfigs$.baseDir,
            generatedDirectoriesWatchmanExpression = _this5$parserConfigs$.generatedDirectoriesWatchmanExpression;
        var generatedDirectories = [];

        if (generatedDirectoriesWatchmanExpression) {
          var relativePaths = yield CodegenWatcher.queryDirectories(_baseDir, generatedDirectoriesWatchmanExpression);
          generatedDirectories = relativePaths.map(function (x) {
            return path.join(_baseDir, x);
          });
        } // always create a new writer: we have to write everything anyways


        var documents = _this5.parsers[_parser2].documents();

        var schema = Profiler.run('getSchema', function () {
          return createSchema(_this5.parserConfigs[_parser2].getSchemaSource(), baseDocuments.toArray(), _this5.parserConfigs[_parser2].schemaExtensions);
        });
        var outputDirectories = yield writeFiles({
          onlyValidate: _this5.onlyValidate,
          schema: schema,
          documents: documents,
          baseDocuments: baseDocuments,
          generatedDirectories: generatedDirectories,
          sourceControl: _this5._sourceControl,
          reporter: _this5._reporter
        });

        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(outputDirectories.values()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var dir = _step2.value;
            var all = [].concat((0, _toConsumableArray2["default"])(dir.changes.created), (0, _toConsumableArray2["default"])(dir.changes.updated), (0, _toConsumableArray2["default"])(dir.changes.deleted), (0, _toConsumableArray2["default"])(dir.changes.unchanged));

            var _iterator3 = (0, _createForOfIteratorHelper2["default"])(all),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var filename = _step3.value;

                var _filePath2 = dir.getPath(filename);

                !isGeneratedFile(_filePath2) ?  true ? invariant(false, 'CodegenRunner: %s returned false for isGeneratedFile, ' + 'but was in generated directory', _filePath2) : undefined : void 0;
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var onCompleteCallback = _this5.onComplete;

        if (onCompleteCallback != null) {
          onCompleteCallback(Array.from(outputDirectories.values()));
        }

        var combinedChanges = CodegenDirectory.combineChanges(Array.from(outputDirectories.values()));

        _this5._reporter.reportMessage(CodegenDirectory.formatChanges(combinedChanges, {
          onlyValidate: _this5.onlyValidate
        }));

        return CodegenDirectory.hasChanges(combinedChanges) ? 'HAS_CHANGES' : 'NO_CHANGES';
      } catch (e) {
        _this5._reporter.reportError('CodegenRunner.write', e);

        return 'ERROR';
      }
    }));
  };

  _proto.watchAll = /*#__PURE__*/function () {
    var _watchAll = _asyncToGenerator(function* () {
      // get everything set up for watching
      yield this.compileAll();

      for (var parserName in this.parserConfigs) {
        yield this.watch(parserName);
      }
    });

    function watchAll() {
      return _watchAll.apply(this, arguments);
    }

    return watchAll;
  }();

  _proto.watch = /*#__PURE__*/function () {
    var _watch = _asyncToGenerator(function* (parserName) {
      var _this6 = this;

      var parserConfig = this.parserConfigs[parserName];

      if (!parserConfig.watchmanExpression) {
        throw new Error('`watchmanExpression` is required to watch files');
      } // watchCompile starts with a full set of files as the changes
      // But as we need to set everything up due to potential parser dependencies,
      // we should prevent the first watch callback from doing anything.


      var firstChange = true;
      yield CodegenWatcher.watchCompile(parserConfig.baseDir, parserConfig.watchmanExpression, parserConfig.getFileFilter ? parserConfig.getFileFilter(parserConfig.baseDir) : anyFileFilter, /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator(function* (files) {
          !(_this6.parsers[parserName] != null) ?  true ? invariant(false, 'Trying to watch an uncompiled parser config: %s', parserName) : undefined : void 0;

          if (firstChange) {
            firstChange = false;
            return;
          }

          var dependentWriters = [];

          _this6.parserWriters[parserName].forEach(function (writer) {
            return dependentWriters.push(writer);
          });

          try {
            if (!_this6.parsers[parserName]) {
              // have to load the parser and make sure all of its dependents are set
              yield _this6.parseEverything(parserName);
            } else {
              _this6.parseFileChanges(parserName, files);
            }

            yield Promise.all(dependentWriters.map(function (writer) {
              return _this6.write(writer);
            }));
          } catch (error) {
            _this6._reporter.reportError('CodegenRunner.watch', error);
          }

          _this6._reporter.reportMessage("Watching for changes to ".concat(parserName, "..."));
        });

        return function (_x4) {
          return _ref4.apply(this, arguments);
        };
      }());

      this._reporter.reportMessage("Watching for changes to ".concat(parserName, "..."));
    });

    function watch(_x3) {
      return _watch.apply(this, arguments);
    }

    return watch;
  }();

  return CodegenRunner;
}();

function anyFileFilter(file) {
  return true;
}

module.exports = CodegenRunner;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _asyncToGenerator = __webpack_require__(12);

var GraphQLWatchmanClient = __webpack_require__(23);

var Profiler = __webpack_require__(7);

var crypto = __webpack_require__(14);

var fs = __webpack_require__(13);

var path = __webpack_require__(9);

var SUBSCRIPTION_NAME = 'graphql-codegen';
var QUERY_RETRIES = 3;

function queryFiles(_x, _x2, _x3) {
  return _queryFiles.apply(this, arguments);
}

function _queryFiles() {
  _queryFiles = _asyncToGenerator(function* (baseDir, expression, filter) {
    return yield Profiler.waitFor('Watchman:query', /*#__PURE__*/_asyncToGenerator(function* () {
      var client = new GraphQLWatchmanClient(QUERY_RETRIES);

      var _await$Promise$all = yield Promise.all([client.watchProject(baseDir), getFields(client)]),
          watchResp = _await$Promise$all[0],
          fields = _await$Promise$all[1];

      var resp = yield client.command('query', watchResp.root, {
        expression: expression,
        fields: fields,
        relative_root: watchResp.relativePath
      });
      client.end();
      return updateFiles(new Set(), baseDir, filter, resp.files);
    }));
  });
  return _queryFiles.apply(this, arguments);
}

function queryDirectories(_x4, _x5) {
  return _queryDirectories.apply(this, arguments);
}

function _queryDirectories() {
  _queryDirectories = _asyncToGenerator(function* (baseDir, expression) {
    return yield Profiler.waitFor('Watchman:query', /*#__PURE__*/_asyncToGenerator(function* () {
      var client = new GraphQLWatchmanClient();
      var watchResp = yield client.watchProject(baseDir);
      var resp = yield client.command('query', watchResp.root, {
        expression: expression,
        fields: ['name'],
        relative_root: watchResp.relativePath
      });
      client.end();
      return resp.files;
    }));
  });
  return _queryDirectories.apply(this, arguments);
}

function getFields(_x6) {
  return _getFields.apply(this, arguments);
} // For use when not using Watchman.


function _getFields() {
  _getFields = _asyncToGenerator(function* (client) {
    var fields = ['name', 'exists'];

    if (yield client.hasCapability('field-content.sha1hex')) {
      fields.push('content.sha1hex');
    }

    return fields;
  });
  return _getFields.apply(this, arguments);
}

function queryFilepaths(_x7, _x8, _x9) {
  return _queryFilepaths.apply(this, arguments);
}
/**
 * Provides a simplified API to the watchman API.
 * Given some base directory and a list of subdirectories it calls the callback
 * with watchman change events on file changes.
 */


function _queryFilepaths() {
  _queryFilepaths = _asyncToGenerator(function* (baseDir, filepaths, filter) {
    // Construct WatchmanChange objects as an intermediate step before
    // calling updateFiles to produce file content.
    var files = filepaths.map(function (filepath) {
      return {
        name: filepath,
        exists: true,
        'content.sha1hex': null
      };
    });
    return updateFiles(new Set(), baseDir, filter, files);
  });
  return _queryFilepaths.apply(this, arguments);
}

function watch(_x10, _x11, _x12) {
  return _watch.apply(this, arguments);
}

function _watch() {
  _watch = _asyncToGenerator(function* (baseDir, expression, callback) {
    return yield Profiler.waitFor('Watchman:subscribe', /*#__PURE__*/_asyncToGenerator(function* () {
      var client = new GraphQLWatchmanClient();
      var watchResp = yield client.watchProject(baseDir);
      yield makeSubscription(client, watchResp.root, watchResp.relativePath, expression, callback);
    }));
  });
  return _watch.apply(this, arguments);
}

function makeSubscription(_x13, _x14, _x15, _x16, _x17) {
  return _makeSubscription.apply(this, arguments);
}
/**
 * Further simplifies `watch` and calls the callback on every change with a
 * full list of files that match the conditions.
 */


function _makeSubscription() {
  _makeSubscription = _asyncToGenerator(function* (client, root, relativePath, expression, callback) {
    client.on('subscription', function (resp) {
      if (resp.subscription === SUBSCRIPTION_NAME) {
        callback(resp);
      }
    });
    var fields = yield getFields(client);
    yield client.command('subscribe', root, SUBSCRIPTION_NAME, {
      expression: expression,
      fields: fields,
      relative_root: relativePath
    });
  });
  return _makeSubscription.apply(this, arguments);
}

function watchFiles(_x18, _x19, _x20, _x21) {
  return _watchFiles.apply(this, arguments);
}
/**
 * Similar to watchFiles, but takes an async function. The `compile` function
 * is awaited and not called in parallel. If multiple changes are triggered
 * before a compile finishes, the latest version is called after the compile
 * finished.
 *
 * TODO: Consider changing from a Promise to abortable, so we can abort mid
 *       compilation.
 */


function _watchFiles() {
  _watchFiles = _asyncToGenerator(function* (baseDir, expression, filter, callback) {
    var files = new Set();
    yield watch(baseDir, expression, function (changes) {
      if (!changes.files) {
        // Watchmen fires a change without files when a watchman state changes,
        // for example during an hg update.
        return;
      }

      files = updateFiles(files, baseDir, filter, changes.files);
      callback(files);
    });
  });
  return _watchFiles.apply(this, arguments);
}

function watchCompile(_x22, _x23, _x24, _x25) {
  return _watchCompile.apply(this, arguments);
}

function _watchCompile() {
  _watchCompile = _asyncToGenerator(function* (baseDir, expression, filter, compile) {
    var compiling = false;
    var needsCompiling = false;
    var latestFiles = null;
    watchFiles(baseDir, expression, filter, /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* (files) {
        needsCompiling = true;
        latestFiles = files;

        if (compiling) {
          return;
        }

        compiling = true;

        while (needsCompiling) {
          needsCompiling = false;
          yield compile(latestFiles);
        }

        compiling = false;
      });

      return function (_x26) {
        return _ref5.apply(this, arguments);
      };
    }());
  });
  return _watchCompile.apply(this, arguments);
}

function updateFiles(files, baseDir, filter, fileChanges) {
  var fileMap = new Map();
  files.forEach(function (file) {
    file.exists && fileMap.set(file.relPath, file);
  });
  fileChanges.forEach(function (_ref) {
    var name = _ref.name,
        exists = _ref.exists,
        hash = _ref['content.sha1hex'];
    var shouldRemove = !exists;

    if (!shouldRemove) {
      var _file = {
        exists: true,
        relPath: name,
        hash: hash || hashFile(path.join(baseDir, name))
      };

      if (filter(_file)) {
        fileMap.set(name, _file);
      } else {
        shouldRemove = true;
      }
    }

    shouldRemove && fileMap.set(name, {
      exists: false,
      relPath: name
    });
  });
  return new Set(fileMap.values());
}

function hashFile(filename) {
  var content = fs.readFileSync(filename);
  return crypto.createHash('sha1').update(content).digest('hex');
}

module.exports = {
  queryDirectories: queryDirectories,
  queryFiles: queryFiles,
  queryFilepaths: queryFilepaths,
  watch: watch,
  watchFiles: watchFiles,
  watchCompile: watchCompile
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = require("child_process");

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = require("fb-watchman");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @emails oncall+relay
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _inheritsLoose2 = _interopRequireDefault(__webpack_require__(60));

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

var _require2 = __webpack_require__(10),
    isSchemaDefinitionAST = _require2.isSchemaDefinitionAST;

var _require3 = __webpack_require__(8),
    GraphQLFloat = _require3.GraphQLFloat,
    GraphQLInt = _require3.GraphQLInt,
    GraphQLBoolean = _require3.GraphQLBoolean,
    GraphQLString = _require3.GraphQLString,
    GraphQLID = _require3.GraphQLID,
    parse = _require3.parse,
    parseType = _require3.parseType,
    print = _require3.print,
    valueFromASTUntyped = _require3.valueFromASTUntyped;

/**
 * @private
 */
var Type = /*#__PURE__*/function () {
  function Type(name, isClient) {
    this.name = name;
    this.isClient = isClient;
  }

  var _proto = Type.prototype;

  _proto.toString = function toString() {
    return this.name;
  };

  _proto.toJSON = function toJSON() {
    return String(this);
  };

  return Type;
}();
/**
 * @private
 */


var ScalarType = /*#__PURE__*/function (_Type) {
  (0, _inheritsLoose2["default"])(ScalarType, _Type);

  function ScalarType() {
    return _Type.apply(this, arguments) || this;
  }

  return ScalarType;
}(Type);
/**
 * @private
 */


var EnumType = /*#__PURE__*/function (_Type2) {
  (0, _inheritsLoose2["default"])(EnumType, _Type2);

  function EnumType(name, values, isClient) {
    var _this;

    _this = _Type2.call(this, name, isClient) || this;
    _this.values = values;
    return _this;
  }

  return EnumType;
}(Type);
/**
 * @private
 */


var UnionType = /*#__PURE__*/function (_Type3) {
  (0, _inheritsLoose2["default"])(UnionType, _Type3);

  function UnionType() {
    return _Type3.apply(this, arguments) || this;
  }

  return UnionType;
}(Type);
/**
 * @private
 */


var ObjectType = /*#__PURE__*/function (_Type4) {
  (0, _inheritsLoose2["default"])(ObjectType, _Type4);

  function ObjectType() {
    return _Type4.apply(this, arguments) || this;
  }

  return ObjectType;
}(Type);
/**
 * @private
 */


var InputObjectType = /*#__PURE__*/function (_Type5) {
  (0, _inheritsLoose2["default"])(InputObjectType, _Type5);

  function InputObjectType() {
    return _Type5.apply(this, arguments) || this;
  }

  return InputObjectType;
}(Type);
/**
 * @private
 */


var InterfaceType = /*#__PURE__*/function (_Type6) {
  (0, _inheritsLoose2["default"])(InterfaceType, _Type6);

  function InterfaceType() {
    return _Type6.apply(this, arguments) || this;
  }

  return InterfaceType;
}(Type);
/**
 * @private
 */


var List = /*#__PURE__*/function () {
  function List(type) {
    this.ofType = type;
    this._typeString = "[".concat(String(this.ofType), "]");
  }

  var _proto2 = List.prototype;

  _proto2.toString = function toString() {
    return this._typeString;
  };

  _proto2.toJSON = function toJSON() {
    return this.toString();
  };

  return List;
}();
/**
 * @private
 */


var NonNull = /*#__PURE__*/function () {
  function NonNull(type) {
    this.ofType = type;
    this._typeString = "".concat(String(this.ofType), "!");
  }

  var _proto3 = NonNull.prototype;

  _proto3.toString = function toString() {
    return this._typeString;
  };

  _proto3.toJSON = function toJSON() {
    return this.toString();
  };

  return NonNull;
}();
/**
 * @private
 */


var Field = function Field(schema, name, type, belongsTo, args, directives, isClient) {
  this.name = name;
  this.type = type;
  this.belongsTo = belongsTo;
  this.isClient = isClient;
  this.args = parseInputArgumentDefinitionsMap(schema, args);
  this.directives = directives;
};
/**
 * @private
 */


function unwrap(type) {
  if (type instanceof NonNull || type instanceof List) {
    return unwrap(type.ofType);
  }

  return type;
}
/**
 * @private
 */


function hasConcreteTypeThatImplements(schema, type, interfaceType) {
  return _isAbstractType(type) && getConcreteTypes(schema, type).some(function (concreteType) {
    return schema.implementsInterface(schema.assertCompositeType(concreteType), interfaceType);
  });
}
/**
 * @private
 */


function getConcreteTypes(schema, type) {
  var concreteTypes = new Set();
  schema.getPossibleTypes(type).forEach(function (possibleType) {
    if (_isObject(possibleType)) {
      concreteTypes.add(possibleType);
    }
  });
  return Array.from(concreteTypes);
}

var TYPENAME_FIELD = '__typename';
var CLIENT_ID_FIELD = '__id';
var QUERY_TYPE_KEY = Symbol('Query');
var MUTATION_TYPE_KEY = Symbol('Mutation');
var SUBSCRIPTION_TYPE_KEY = Symbol('Subscription');

function _isScalar(type) {
  return type instanceof ScalarType;
}

function _isObject(type) {
  return type instanceof ObjectType;
}

function _isEnum(type) {
  return type instanceof EnumType;
}

function _isUnion(type) {
  return type instanceof UnionType;
}

function _isInputObject(type) {
  return type instanceof InputObjectType;
}

function _isInterface(type) {
  return type instanceof InterfaceType;
}

function _isWrapper(type) {
  return type instanceof List || type instanceof NonNull;
}

function isBaseType(type) {
  return type instanceof ScalarType || type instanceof ObjectType || type instanceof EnumType || type instanceof UnionType || type instanceof InputObjectType || type instanceof InterfaceType;
}

function _isAbstractType(type) {
  return type instanceof UnionType || type instanceof InterfaceType;
}

function _isCompositeType(type) {
  return type instanceof ObjectType || type instanceof UnionType || type instanceof InterfaceType;
}

function _isInputType(type) {
  return type instanceof InputObjectType || type instanceof ScalarType || type instanceof EnumType;
}

var Schema = /*#__PURE__*/function () {
  /**
   * @private
   */
  function Schema(typeMap) {
    var _this2 = this;

    this._typeMap = typeMap;
    this._typeWrappersMap = new Map();
    this._fieldsMap = new Map();
    this._typeNameMap = new Map();
    this._clientIdMap = new Map();
    this._directiveMap = new Map(typeMap.getDirectives().map(function (directive) {
      return [directive.name, {
        locations: directive.locations,
        args: parseInputArgumentDefinitions(_this2, directive.args),
        name: directive.name,
        isClient: directive.isClient
      }];
    }));
  }

  var _proto4 = Schema.prototype;

  _proto4.getTypes = function getTypes() {
    return this._typeMap.getTypes();
  };

  _proto4.getTypeFromAST = function getTypeFromAST(typeNode) {
    if (typeNode.kind === 'NonNullType') {
      var innerType = this.getTypeFromAST(typeNode.type);

      if (!innerType) {
        return;
      }

      if (innerType instanceof NonNull) {
        throw createCompilerError('Unable to wrap non-nullable type with non-null wrapper.');
      }

      var cacheKey = "".concat(this.getTypeString(innerType), "!");

      var type = this._typeWrappersMap.get(cacheKey);

      if (type) {
        return type;
      }

      type = new NonNull(innerType);

      this._typeWrappersMap.set(cacheKey, type);

      return type;
    } else if (typeNode.kind === 'ListType') {
      var _innerType = this.getTypeFromAST(typeNode.type);

      if (!_innerType) {
        return;
      }

      var _cacheKey = "[".concat(this.getTypeString(_innerType), "]");

      var _type = this._typeWrappersMap.get(_cacheKey);

      if (_type) {
        return _type;
      }

      _type = new List(_innerType);

      this._typeWrappersMap.set(_cacheKey, _type);

      return _type;
    }

    return this._typeMap.getTypeByName(typeNode.name.value);
  };

  _proto4._getRawType = function _getRawType(typeName) {
    var type = this._typeWrappersMap.get(typeName);

    if (type) {
      return type;
    }

    if (typeof typeName === 'string') {
      return this.getTypeFromAST(parseType(typeName));
    } else {
      var operationType;

      if (typeName === QUERY_TYPE_KEY) {
        operationType = this._typeMap.getQueryType();
      } else if (typeName === MUTATION_TYPE_KEY) {
        operationType = this._typeMap.getMutationType();
      } else if (typeName === SUBSCRIPTION_TYPE_KEY) {
        operationType = this._typeMap.getSubscriptionType();
      }

      if (operationType instanceof ObjectType) {
        return operationType;
      }
    }
  };

  _proto4.getTypeFromString = function getTypeFromString(typeName) {
    return this._getRawType(typeName);
  };

  _proto4.expectTypeFromString = function expectTypeFromString(typeName) {
    var type = this.getTypeFromString(typeName);

    if (type == null) {
      throw createCompilerError("Unknown type: '".concat(typeName, "'."));
    }

    return type;
  };

  _proto4.expectTypeFromAST = function expectTypeFromAST(ast) {
    var type = this.getTypeFromAST(ast);

    if (type == null) {
      throw createCompilerError("Unknown type: '".concat(print(ast), "'."), null, [ast]);
    }

    return type;
  };

  _proto4.getNonNullType = function getNonNullType(type) {
    if (type instanceof NonNull) {
      return type;
    }

    var cacheKey = "".concat(String(type), "!");

    var nonNullType = this._typeWrappersMap.get(cacheKey);

    if (nonNullType) {
      return nonNullType;
    }

    nonNullType = new NonNull(type);

    this._typeWrappersMap.set(cacheKey, nonNullType);

    return nonNullType;
  };

  _proto4.getRawType = function getRawType(type) {
    return unwrap(type);
  };

  _proto4.getNullableType = function getNullableType(type) {
    if (type instanceof NonNull) {
      return type.ofType;
    }

    return type;
  };

  _proto4.getListItemType = function getListItemType(type) {
    if (type instanceof List) {
      return type.ofType;
    }

    return type;
  };

  _proto4.mapListItemType = function mapListItemType(type, mapper) {
    if (!(type instanceof List)) {
      throw createCompilerError('Expected List type');
    }

    var innerType = mapper(type.ofType);
    var cacheKey = "[".concat(this.getTypeString(innerType), "]");

    var newType = this._typeWrappersMap.get(cacheKey);

    if (newType) {
      return newType;
    }

    newType = new List(innerType);

    this._typeWrappersMap.set(cacheKey, newType);

    return newType;
  };

  _proto4.areEqualTypes = function areEqualTypes(typeA, typeB) {
    if (typeA === typeB) {
      return true;
    }

    if (typeA instanceof NonNull && typeB instanceof NonNull) {
      return this.areEqualTypes(typeA.ofType, typeB.ofType);
    }

    if (typeA instanceof List && typeB instanceof List) {
      return this.areEqualTypes(typeA.ofType, typeB.ofType);
    }

    if (isBaseType(typeA) && isBaseType(typeB)) {
      return typeA.name === typeB.name;
    }

    return false;
  }
  /**
   * Determine if the given type may implement the named type:
   * - it is the named type
   * - it implements the named interface
   * - it is an abstract type and *some* of its concrete types may
   *   implement the named type
   */
  ;

  _proto4.mayImplement = function mayImplement(type, interfaceType) {
    return this.areEqualTypes(type, interfaceType) || this.implementsInterface(type, interfaceType) || this.isAbstractType(type) && hasConcreteTypeThatImplements(this, type, interfaceType);
  };

  _proto4.implementsInterface = function implementsInterface(type, interfaceType) {
    var _this3 = this;

    return this.getInterfaces(type).some(function (typeInterface) {
      return _this3.areEqualTypes(typeInterface, interfaceType);
    });
  };

  _proto4.canHaveSelections = function canHaveSelections(type) {
    return this.isObject(type) || this.isInterface(type);
  };

  _proto4.getTypeString = function getTypeString(type) {
    return type.toString();
  };

  _proto4.isTypeSubTypeOf = function isTypeSubTypeOf(maybeSubType, superType) {
    // Equivalent type is a valid subtype
    if (maybeSubType === superType) {
      return true;
    } // If superType is non-null, maybeSubType must also be non-null.


    if (superType instanceof NonNull) {
      if (maybeSubType instanceof NonNull) {
        return this.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);
      }

      return false;
    }

    if (maybeSubType instanceof NonNull) {
      // If superType is nullable, maybeSubType may be non-null or nullable.
      return this.isTypeSubTypeOf(maybeSubType.ofType, superType);
    } // If superType type is a list, maybeSubType type must also be a list.


    if (superType instanceof List) {
      if (maybeSubType instanceof List) {
        return this.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);
      }

      return false;
    }

    if (maybeSubType instanceof List) {
      // If superType is not a list, maybeSubType must also be not a list.
      return false;
    } // If superType type is an abstract type, maybeSubType type may be a currently
    // possible object type.


    if (this.isAbstractType(superType) && this.isObject(maybeSubType) && this.isPossibleType(this.assertAbstractType(superType), this.assertObjectType(maybeSubType))) {
      return true;
    } // Otherwise, maybeSubType is not a valid subtype of the superType.


    return false;
  }
  /**
   * Provided two composite types, determine if they "overlap". Two composite
   * types overlap when the Sets of possible concrete types for each intersect.
   *
   * This is often used to determine if a fragment of a given type could possibly
   * be visited in a context of another type.
   *
   * This function is commutative.
   */
  ;

  _proto4.doTypesOverlap = function doTypesOverlap(typeA, typeB) {
    var _this4 = this;

    // Equivalent types overlap
    if (typeA === typeB) {
      return true;
    }

    if (_isAbstractType(typeA)) {
      if (_isAbstractType(typeB)) {
        // If both types are abstract, then determine if there is any intersection
        // between possible concrete types of each.
        return Array.from(this.getPossibleTypes(typeA)).some(function (type) {
          if (_isObject(type)) {
            return _this4.isPossibleType(typeB, type);
          }
        });
      } // Determine if the latter type is a possible concrete type of the former.


      return this.isPossibleType(typeA, typeB);
    }

    if (_isAbstractType(typeB)) {
      // Determine if the former type is a possible concrete type of the latter.
      return this.isPossibleType(typeB, typeA);
    } // Otherwise the types do not overlap.


    return false;
  };

  _proto4.isPossibleType = function isPossibleType(superType, maybeSubType) {
    return this._typeMap.getPossibleTypeSet(superType).has(maybeSubType);
  };

  _proto4.assertScalarFieldType = function assertScalarFieldType(type) {
    // Scalar type fields can be wrappers / or can be scalars/enums
    if (_isWrapper(type) && !_isScalar(unwrap(type)) && !_isEnum(unwrap(type)) || !_isWrapper(type) && !_isScalar(type) && !_isEnum(type)) {
      throw createCompilerError("Expected ".concat(String(type), " to be a Scalar or Enum type."));
    }

    return type;
  };

  _proto4.assertLinkedFieldType = function assertLinkedFieldType(type) {
    // Linked Field types can be wrappers / or can be composite types
    if (_isWrapper(type) && !_isCompositeType(unwrap(type)) || !_isWrapper(type) && !_isCompositeType(type)) {
      throw createCompilerError("Expected ".concat(String(type), " to be a Object, Interface or a Union Type."));
    }

    return type;
  };

  _proto4.assertInputType = function assertInputType(type) {
    // Input type fields can be wrappers / or can be scalars/enums
    if (_isWrapper(type) && !_isInputType(unwrap(type)) || !_isWrapper(type) && !_isInputType(type)) {
      throw createCompilerError("Expected ".concat(String(type), " to be a Input, Scalar or Enum type."));
    }

    return type;
  };

  _proto4.asCompositeType = function asCompositeType(type) {
    if (_isCompositeType(type)) {
      return type;
    }
  };

  _proto4.asInputType = function asInputType(type) {
    if (_isWrapper(type) && _isInputType(unwrap(type)) || !_isWrapper(type) && _isInputType(type)) {
      return type;
    }
  };

  _proto4.asScalarFieldType = function asScalarFieldType(type) {
    if (_isScalar(type) || _isEnum(type)) {
      return type;
    }
  };

  _proto4.assertScalarType = function assertScalarType(type) {
    if (!_isScalar(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a scalar type, got ").concat(this.getTypeString(type), "."));
    }

    return type;
  };

  _proto4.assertObjectType = function assertObjectType(type) {
    if (!_isObject(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be an object type."));
    }

    return type;
  };

  _proto4.assertInputObjectType = function assertInputObjectType(type) {
    if (!_isInputObject(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be an input type."));
    }

    return type;
  };

  _proto4.asInputObjectType = function asInputObjectType(type) {
    if (!_isInputObject(type)) {
      return null;
    }

    return type;
  };

  _proto4.assertInterfaceType = function assertInterfaceType(type) {
    if (!_isInterface(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be an interface type."));
    }

    return type;
  };

  _proto4.assertCompositeType = function assertCompositeType(type) {
    if (!_isCompositeType(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a composite type."));
    }

    return type;
  };

  _proto4.assertAbstractType = function assertAbstractType(type) {
    if (!_isAbstractType(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be an abstract type."));
    }

    return type;
  };

  _proto4.assertLeafType = function assertLeafType(type) {
    if (!this.isLeafType(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a leaf type."));
    }

    return type;
  };

  _proto4.assertUnionType = function assertUnionType(type) {
    if (!_isUnion(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a union type."));
    }

    return type;
  };

  _proto4.assertEnumType = function assertEnumType(type) {
    if (!_isEnum(type)) {
      throw createCompilerError("Expected ".concat(String(type), " to be an enum type."));
    }

    return type;
  };

  _proto4.assertIntType = function assertIntType(type) {
    if (!_isScalar(type) || !this.isInt(type)) {
      throw createCompilerError("Expected ".concat(String(type), " to be an 'Int' type."));
    }

    return type;
  };

  _proto4.assertFloatType = function assertFloatType(type) {
    if (!_isScalar(type) || !this.isFloat(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a 'Float' type."));
    }

    return type;
  };

  _proto4.assertBooleanType = function assertBooleanType(type) {
    if (!_isScalar(type) || !this.isBoolean(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a 'Boolean' type."));
    }

    return type;
  };

  _proto4.assertStringType = function assertStringType(type) {
    if (!_isScalar(type) || !this.isString(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be a 'String' type."));
    }

    return type;
  };

  _proto4.assertIdType = function assertIdType(type) {
    if (!_isScalar(type) || !this.isId(type)) {
      throw createCompilerError("Expected ".concat(this.getTypeString(type), " to be an ID type."));
    }

    return type;
  };

  _proto4.expectBooleanType = function expectBooleanType() {
    return this.assertScalarType(this.expectTypeFromString('Boolean'));
  };

  _proto4.expectIntType = function expectIntType() {
    return this.assertScalarType(this.expectTypeFromString('Int'));
  };

  _proto4.expectFloatType = function expectFloatType() {
    return this.assertScalarType(this.expectTypeFromString('Float'));
  };

  _proto4.expectStringType = function expectStringType() {
    return this.assertScalarType(this.expectTypeFromString('String'));
  };

  _proto4.expectIdType = function expectIdType() {
    return this.assertScalarType(this.expectTypeFromString('ID'));
  };

  _proto4.getQueryType = function getQueryType() {
    var queryType = this._getRawType(QUERY_TYPE_KEY);

    if (queryType && _isObject(queryType)) {
      return queryType;
    }
  };

  _proto4.getMutationType = function getMutationType() {
    var mutationType = this._getRawType(MUTATION_TYPE_KEY);

    if (mutationType && _isObject(mutationType)) {
      return mutationType;
    }
  };

  _proto4.getSubscriptionType = function getSubscriptionType() {
    var subscriptionType = this._getRawType(SUBSCRIPTION_TYPE_KEY);

    if (subscriptionType && _isObject(subscriptionType)) {
      return subscriptionType;
    }
  };

  _proto4.expectQueryType = function expectQueryType() {
    var queryType = this.getQueryType();

    if (queryType == null) {
      throw createCompilerError('Query type is not defined on the Schema');
    }

    return queryType;
  };

  _proto4.expectMutationType = function expectMutationType() {
    var mutationType = this.getMutationType();

    if (mutationType == null) {
      throw createCompilerError('Mutation type is not defined the Schema');
    }

    return mutationType;
  };

  _proto4.expectSubscriptionType = function expectSubscriptionType() {
    var subscriptionType = this.getSubscriptionType();

    if (subscriptionType == null) {
      throw createCompilerError('Subscription type is not defined the Schema');
    }

    return subscriptionType;
  };

  _proto4.isNonNull = function isNonNull(type) {
    return type instanceof NonNull;
  };

  _proto4.isList = function isList(type) {
    return type instanceof List;
  };

  _proto4.isWrapper = function isWrapper(type) {
    return _isWrapper(type);
  };

  _proto4.isScalar = function isScalar(type) {
    return _isScalar(type);
  };

  _proto4.isObject = function isObject(type) {
    return _isObject(type);
  };

  _proto4.isEnum = function isEnum(type) {
    return _isEnum(type);
  };

  _proto4.isUnion = function isUnion(type) {
    return _isUnion(type);
  };

  _proto4.isInputObject = function isInputObject(type) {
    return _isInputObject(type);
  };

  _proto4.isInterface = function isInterface(type) {
    return _isInterface(type);
  };

  _proto4.isInputType = function isInputType(type) {
    // Wrappers can be input types (so it's save to check unwrapped type here)
    return _isInputType(type) || _isWrapper(type) && _isInputType(unwrap(type));
  };

  _proto4.isCompositeType = function isCompositeType(type) {
    return _isCompositeType(type);
  };

  _proto4.isAbstractType = function isAbstractType(type) {
    return _isAbstractType(type);
  };

  _proto4.isLeafType = function isLeafType(type) {
    return this.isScalar(type) || this.isEnum(type);
  };

  _proto4.isId = function isId(type) {
    if (type instanceof ScalarType) {
      return type.name === 'ID';
    }

    return false;
  };

  _proto4.isInt = function isInt(type) {
    if (type instanceof ScalarType) {
      return type.name === 'Int';
    }

    return false;
  };

  _proto4.isFloat = function isFloat(type) {
    if (type instanceof ScalarType) {
      return type.name === 'Float';
    }

    return false;
  };

  _proto4.isBoolean = function isBoolean(type) {
    if (type instanceof ScalarType) {
      return type.name === 'Boolean';
    }

    return false;
  };

  _proto4.isString = function isString(type) {
    if (type instanceof ScalarType) {
      return type.name === 'String';
    }

    return false;
  };

  _proto4.hasField = function hasField(type, fieldName) {
    var canHaveTypename = this.isObject(type) || this.isAbstractType(type); // Special case for __typename field

    if (canHaveTypename && (fieldName === TYPENAME_FIELD || fieldName === CLIENT_ID_FIELD)) {
      return true;
    }

    if (type instanceof ObjectType || type instanceof InterfaceType) {
      return this._typeMap.getField(type, fieldName) != null;
    } else if (type instanceof InputObjectType) {
      return this._typeMap.getInputField(type, fieldName) != null;
    }

    return false;
  };

  _proto4.hasId = function hasId(type) {
    if (!this.hasField(type, 'id')) {
      return false;
    }

    var idField = this.expectField(type, 'id');
    return this.areEqualTypes(this.getNullableType(this.getFieldType(idField)), this.expectIdType());
  };

  _proto4.getFields = function getFields(type) {
    var fieldsMap = this._getFieldsMap(type);

    return Array.from(fieldsMap.values());
  };

  _proto4._getFieldsMap = function _getFieldsMap(type) {
    var cachedMap = this._fieldsMap.get(type);

    if (cachedMap != null) {
      return cachedMap;
    }

    var fieldsMap = new Map();

    if (type instanceof ObjectType || type instanceof InterfaceType) {
      var fields = this._typeMap.getFieldMap(type);

      if (fields) {
        var _iterator = (0, _createForOfIteratorHelper2["default"])(fields),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _step.value,
                fieldName = _step$value[0],
                fieldDefinition = _step$value[1];
            var fieldType = this.expectTypeFromAST(fieldDefinition.type);
            fieldsMap.set(fieldName, new Field(this, fieldName, fieldType, this.assertCompositeType(type), fieldDefinition.arguments, fieldDefinition.directives, fieldDefinition.isClient));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    } else if (type instanceof InputObjectType) {
      var _fields = this._typeMap.getInputFieldMap(type);

      if (_fields) {
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(_fields),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _step2.value,
                _fieldName = _step2$value[0],
                typeNode = _step2$value[1];

            var _fieldType = this.expectTypeFromAST(typeNode);

            fieldsMap.set(_fieldName, new Field(this, _fieldName, _fieldType, type, [], null, false));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }

    if (fieldsMap.size === 0) {
      throw createCompilerError("_getFieldsMap: Type '".concat(type.name, "' should have fields."));
    }

    this._fieldsMap.set(type, fieldsMap);

    return fieldsMap;
  };

  _proto4.getFieldByName = function getFieldByName(type, fieldName) {
    if (!this.hasField(type, fieldName)) {
      return;
    } // A "special" case for __typename and __id fields - which should
    // not be in the list of type fields, but should be fine to select


    if (fieldName === TYPENAME_FIELD) {
      var typename = this._typeNameMap.get(type);

      if (!typename) {
        typename = new Field(this, TYPENAME_FIELD, this.getNonNullType(this.expectStringType()), type, [], null, false);

        this._typeNameMap.set(type, typename);
      }

      return typename;
    }

    if (fieldName === CLIENT_ID_FIELD) {
      var clientId = this._clientIdMap.get(type);

      if (!clientId) {
        clientId = new Field(this, CLIENT_ID_FIELD, this.getNonNullType(this.expectIdType()), type, [], null, true);

        this._clientIdMap.set(type, clientId);
      }

      return clientId;
    }

    if (_isUnion(type)) {
      throw createCompilerError("Unexpected union type '".concat(this.getTypeString(type), "' in the 'getFieldByName(...)'. Expected type with fields"));
    }

    var fieldsMap = this._getFieldsMap(type);

    return fieldsMap.get(fieldName);
  };

  _proto4.expectField = function expectField(type, fieldName) {
    var field = this.getFieldByName(type, fieldName);

    if (!field) {
      throw createCompilerError("Unknown field '".concat(fieldName, "' on type '").concat(this.getTypeString(type), "'."));
    }

    return field;
  };

  _proto4.getFieldConfig = function getFieldConfig(field) {
    return {
      type: field.type,
      args: Array.from(field.args.values())
    };
  };

  _proto4.getFieldName = function getFieldName(field) {
    return field.name;
  };

  _proto4.getFieldType = function getFieldType(field) {
    return field.type;
  };

  _proto4.getFieldParentType = function getFieldParentType(field) {
    return field.belongsTo;
  };

  _proto4.getFieldArgs = function getFieldArgs(field) {
    return Array.from(field.args.values());
  };

  _proto4.getFieldArgByName = function getFieldArgByName(field, argName) {
    return field.args.get(argName);
  };

  _proto4.getEnumValues = function getEnumValues(type) {
    return type.values;
  };

  _proto4.getUnionTypes = function getUnionTypes(type) {
    return Array.from(this._typeMap.getPossibleTypeSet(type));
  };

  _proto4.getInterfaces = function getInterfaces(type) {
    if (type instanceof ObjectType) {
      return this._typeMap.getInterfaces(type);
    }

    return [];
  };

  _proto4.getPossibleTypes = function getPossibleTypes(type) {
    return this._typeMap.getPossibleTypeSet(type);
  };

  _proto4.getFetchableFieldName = function getFetchableFieldName(type) {
    return this._typeMap.getFetchableFieldName(type);
  };

  _proto4.parseLiteral = function parseLiteral(type, valueNode) {
    if (type instanceof EnumType && valueNode.kind === 'EnumValue') {
      return this.parseValue(type, valueNode.value);
    } else if (type instanceof ScalarType) {
      if (valueNode.kind === 'BooleanValue' && type.name === 'Boolean') {
        return GraphQLBoolean.parseLiteral(valueNode);
      } else if (valueNode.kind === 'FloatValue' && type.name === 'Float') {
        return GraphQLFloat.parseLiteral(valueNode);
      } else if (valueNode.kind === 'IntValue' && (type.name === 'Int' || type.name === 'ID' || type.name === 'Float')) {
        return GraphQLInt.parseLiteral(valueNode);
      } else if (valueNode.kind === 'StringValue' && (type.name === 'String' || type.name === 'ID')) {
        return GraphQLString.parseLiteral(valueNode);
      } else if (!isDefaultScalar(type.name)) {
        return valueFromASTUntyped(valueNode);
      }
    }
  };

  _proto4.parseValue = function parseValue(type, value) {
    if (type instanceof EnumType) {
      return type.values.includes(value) ? value : undefined;
    } else if (type instanceof ScalarType) {
      switch (type.name) {
        case 'Boolean':
          return GraphQLBoolean.parseValue(value);

        case 'Float':
          return GraphQLFloat.parseValue(value);

        case 'Int':
          return GraphQLInt.parseValue(value);

        case 'String':
          return GraphQLString.parseValue(value);

        case 'ID':
          return GraphQLID.parseValue(value);

        default:
          return value;
      }
    }
  };

  _proto4.serialize = function serialize(type, value) {
    if (type instanceof EnumType) {
      return type.values.includes(value) ? value : undefined;
    } else if (type instanceof ScalarType) {
      switch (type.name) {
        case 'Boolean':
          return GraphQLBoolean.serialize(value);

        case 'Float':
          return GraphQLFloat.serialize(value);

        case 'Int':
          return GraphQLInt.serialize(value);

        case 'String':
          return GraphQLString.serialize(value);

        case 'ID':
          return GraphQLID.serialize(value);

        default:
          return value;
      }
    }
  };

  _proto4.getDirectives = function getDirectives() {
    return Array.from(this._directiveMap.values());
  };

  _proto4.getDirective = function getDirective(directiveName) {
    return this._directiveMap.get(directiveName);
  };

  _proto4.isServerType = function isServerType(type) {
    var unwrapped = unwrap(type);
    return unwrapped.isClient === false;
  };

  _proto4.isServerField = function isServerField(field) {
    return field.isClient === false;
  };

  _proto4.isServerDirective = function isServerDirective(directiveName) {
    var directive = this._directiveMap.get(directiveName);

    return (directive === null || directive === void 0 ? void 0 : directive.isClient) === false;
  };

  _proto4.isServerDefinedField = function isServerDefinedField(type, field) {
    return this.isAbstractType(type) && field.directives.some(function (_ref) {
      var name = _ref.name;
      return name === 'fixme_fat_interface';
    }) || this.hasField(type, field.name) && this.isServerField(this.expectField(type, field.name));
  };

  _proto4.isClientDefinedField = function isClientDefinedField(type, field) {
    return !this.isServerDefinedField(type, field);
  };

  _proto4.extend = function extend(extensions) {
    var doc = Array.isArray(extensions) ? parse(extensions.join('\n')) : extensions;
    var schemaExtensions = [];
    doc.definitions.forEach(function (definition) {
      if (isSchemaDefinitionAST(definition)) {
        schemaExtensions.push(definition);
      }
    });

    if (schemaExtensions.length > 0) {
      return new Schema(this._typeMap.extend(schemaExtensions));
    }

    return this;
  };

  return Schema;
}();

var TypeMap = /*#__PURE__*/function () {
  function TypeMap(source, extensions) {
    this._types = new Map([['ID', new ScalarType('ID', false)], ['String', new ScalarType('String', false)], ['Boolean', new ScalarType('Boolean', false)], ['Float', new ScalarType('Float', false)], ['Int', new ScalarType('Int', false)]]);
    this._typeInterfaces = new Map();
    this._unionTypes = new Map();
    this._interfaceImplementations = new Map();
    this._fields = new Map();
    this._inputFields = new Map();
    this._directives = new Map([['include', {
      name: 'include',
      isClient: false,
      locations: ['FIELD', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT'],
      args: [{
        name: 'if',
        typeNode: parseType('Boolean!'),
        defaultValue: undefined
      }]
    }], ['skip', {
      name: 'skip',
      isClient: false,
      locations: ['FIELD', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT'],
      args: [{
        name: 'if',
        typeNode: parseType('Boolean!'),
        defaultValue: undefined
      }]
    }], ['deprecated', {
      name: 'deprecated',
      isClient: false,
      locations: ['FIELD_DEFINITION', 'ENUM_VALUE'],
      args: [{
        name: 'reason',
        typeNode: parseType('String'),
        defaultValue: {
          kind: 'StringValue',
          value: 'No longer supported'
        }
      }]
    }]]);
    this._queryTypeName = 'Query';
    this._mutationTypeName = 'Mutation';
    this._subscriptionTypeName = 'Subscription';
    this._source = source;
    this._extensions = extensions;
    this._fetchable = new Map();

    this._parse(source);

    this._extend(extensions);
  }

  var _proto5 = TypeMap.prototype;

  _proto5._parse = function _parse(source) {
    var _this5 = this;

    var document = parse(source, {
      noLocation: true
    });
    document.definitions.forEach(function (definition) {
      switch (definition.kind) {
        case 'SchemaDefinition':
          {
            _this5._parseSchemaDefinition(definition);

            break;
          }

        case 'ScalarTypeDefinition':
          {
            _this5._parseScalarNode(definition, false);

            break;
          }

        case 'EnumTypeDefinition':
          {
            _this5._parseEnumNode(definition, false);

            break;
          }

        case 'ObjectTypeDefinition':
          {
            _this5._parseObjectTypeNode(definition, false);

            break;
          }

        case 'InputObjectTypeDefinition':
          {
            _this5._parseInputObjectTypeNode(definition, false);

            break;
          }

        case 'UnionTypeDefinition':
          {
            _this5._parseUnionNode(definition, false);

            break;
          }

        case 'InterfaceTypeDefinition':
          {
            _this5._parseInterfaceNode(definition, false);

            break;
          }

        case 'DirectiveDefinition':
          {
            _this5._parseDirective(definition, false);

            break;
          }
      }
    });
  };

  _proto5._parseSchemaDefinition = function _parseSchemaDefinition(node) {
    var _this6 = this;

    node.operationTypes.forEach(function (operationType) {
      switch (operationType.operation) {
        case 'query':
          _this6._queryTypeName = operationType.type.name.value;
          break;

        case 'mutation':
          _this6._mutationTypeName = operationType.type.name.value;
          break;

        case 'subscription':
          _this6._subscriptionTypeName = operationType.type.name.value;
          break;
      }
    });
  };

  _proto5._parseScalarNode = function _parseScalarNode(node, isClient) {
    var name = node.name.value;

    if (!isDefaultScalar(name) && this._types.has(name)) {
      throw createCompilerError("_parseScalarNode: Duplicate definition for type ".concat(name, "."), null, [node]);
    }

    this._types.set(name, new ScalarType(name, isClient));
  };

  _proto5._parseEnumNode = function _parseEnumNode(node, isClient) {
    var name = node.name.value;

    if (this._types.has(name)) {
      throw createCompilerError("_parseEnumNode: Duplicate definition for type ".concat(name, "."), null, [node]);
    } // SDL doesn't have information about the actual ENUM values


    var values = node.values ? node.values.map(function (value) {
      return value.name.value;
    }) : [];

    this._types.set(name, new EnumType(name, values, isClient));
  };

  _proto5._parseObjectTypeNode = function _parseObjectTypeNode(node, isClient) {
    var _this7 = this;

    var _this$_types$get;

    var name = node.name.value; // Objects may be created by _parseUnionNode

    var type = (_this$_types$get = this._types.get(name)) !== null && _this$_types$get !== void 0 ? _this$_types$get : new ObjectType(name, isClient);

    if (!(type instanceof ObjectType)) {
      throw createCompilerError("_parseObjectTypeNode: Expected object type, got ".concat(String(type)), null, [node]);
    }

    if (type.isClient !== isClient) {
      throw createCompilerError("_parseObjectTypeNode: Cannot create object type '".concat(name, "' defined as a client type."), null, [node]);
    }

    var typeInterfaces = [];
    node.interfaces && node.interfaces.forEach(function (interfaceTypeNode) {
      var _this$_interfaceImple;

      var interfaceName = interfaceTypeNode.name.value;

      var interfaceType = _this7._types.get(interfaceName);

      if (!interfaceType) {
        interfaceType = new InterfaceType(interfaceName, isClient);

        _this7._types.set(interfaceName, interfaceType);
      }

      if (!(interfaceType instanceof InterfaceType)) {
        throw createCompilerError('_parseObjectTypeNode: Expected interface type', null, [interfaceTypeNode]);
      }

      var implementations = (_this$_interfaceImple = _this7._interfaceImplementations.get(interfaceType)) !== null && _this$_interfaceImple !== void 0 ? _this$_interfaceImple : new Set();
      implementations.add(type);

      _this7._interfaceImplementations.set(interfaceType, implementations);

      typeInterfaces.push(interfaceType);
    });
    var fetchable = null;
    node.directives && node.directives.forEach(function (directiveNode) {
      if (directiveNode.name.value === 'fetchable') {
        var field_name_arg = directiveNode.arguments && directiveNode.arguments.find(function (arg) {
          return arg.name.value === 'field_name';
        });

        if (field_name_arg != null && field_name_arg.value.kind === 'StringValue') {
          fetchable = {
            field_name: field_name_arg.value.value
          };
        }
      }
    });

    this._typeInterfaces.set(type, typeInterfaces);

    this._types.set(name, type);

    if (fetchable != null) {
      this._fetchable.set(type, fetchable);
    }

    node.fields && this._handleTypeFieldsStrict(type, node.fields, isClient);
  };

  _proto5._parseInputObjectTypeNode = function _parseInputObjectTypeNode(node, isClient) {
    var name = node.name.value;

    if (this._types.has(name)) {
      throw createCompilerError('_parseInputObjectTypeNode: Unable to parse schema file. Duplicate definition for object type', null, [node]);
    }

    var type = new InputObjectType(name, isClient);

    this._types.set(name, type);

    this._parseInputObjectFields(type, node);
  };

  _proto5._parseUnionNode = function _parseUnionNode(node, isClient) {
    var _this8 = this;

    var name = node.name.value;

    if (this._types.has(name)) {
      throw createCompilerError('_parseUnionNode: Unable to parse schema file. Duplicate definition for object type', null, [node]);
    }

    var union = new UnionType(name, isClient);

    this._types.set(name, union);

    this._unionTypes.set(union, new Set(node.types ? node.types.map(function (typeInUnion) {
      var _this$_types$get2;

      var typeInUnionName = typeInUnion.name.value;
      var object = (_this$_types$get2 = _this8._types.get(typeInUnionName)) !== null && _this$_types$get2 !== void 0 ? _this$_types$get2 : new ObjectType(typeInUnionName, false);

      if (!(object instanceof ObjectType)) {
        throw createCompilerError('_parseUnionNode: Expected object type', null, [typeInUnion]);
      }

      _this8._types.set(typeInUnionName, object);

      return object;
    }) : []));
  };

  _proto5._parseInterfaceNode = function _parseInterfaceNode(node, isClient) {
    var name = node.name.value;

    var type = this._types.get(name);

    if (!type) {
      type = new InterfaceType(name, isClient);

      this._types.set(name, type);
    }

    if (!(type instanceof InterfaceType)) {
      throw createCompilerError("_parseInterfaceNode: Expected interface type. Got ".concat(String(type)), null, [node]);
    }

    if (type.isClient !== isClient) {
      throw createCompilerError("_parseInterfaceNode: Cannot create interface '".concat(name, "' defined as a client interface"), null, [node]);
    }

    node.fields && this._handleTypeFieldsStrict(type, node.fields, isClient);
  };

  _proto5._handleTypeFieldsStrict = function _handleTypeFieldsStrict(type, fields, isClient) {
    if (this._fields.has(type)) {
      throw createCompilerError('_handleTypeFieldsStrict: Unable to parse schema file. Duplicate definition for object type');
    }

    this._handleTypeFields(type, fields, isClient);
  };

  _proto5._handleTypeFields = function _handleTypeFields(type, fields, isClient) {
    var _this$_fields$get;

    var fieldsMap = (_this$_fields$get = this._fields.get(type)) !== null && _this$_fields$get !== void 0 ? _this$_fields$get : new Map();
    fields.forEach(function (fieldNode) {
      var fieldName = fieldNode.name.value;

      if (fieldsMap.has(fieldName)) {
        throw createCompilerError("_handleTypeFields: Duplicate definition for field '".concat(fieldName, "'."));
      }

      fieldsMap.set(fieldName, {
        arguments: fieldNode.arguments ? fieldNode.arguments.map(function (arg) {
          return {
            name: arg.name.value,
            typeNode: arg.type,
            defaultValue: arg.defaultValue
          };
        }) : [],
        directives: fieldNode.directives ? fieldNode.directives.map(function (directive) {
          return {
            name: directive.name.value,
            args: directive.arguments ? directive.arguments.map(function (arg) {
              return {
                name: arg.name.value,
                value: arg.value
              };
            }) : []
          };
        }) : null,
        type: fieldNode.type,
        isClient: isClient
      });
    });

    this._fields.set(type, fieldsMap);
  };

  _proto5._parseInputObjectFields = function _parseInputObjectFields(type, node) {
    if (this._inputFields.has(type)) {
      throw createCompilerError('_parseInputObjectFields: Unable to parse schema file. Duplicate definition for type', null, [node]);
    }

    var fields = new Map();

    if (node.fields) {
      node.fields.forEach(function (fieldNode) {
        fields.set(fieldNode.name.value, fieldNode.type);
      });
    }

    this._inputFields.set(type, fields);
  };

  _proto5._parseDirective = function _parseDirective(node, isClient) {
    var name = node.name.value;

    this._directives.set(name, {
      name: name,
      args: node.arguments ? node.arguments.map(function (arg) {
        return {
          name: arg.name.value,
          typeNode: arg.type,
          defaultValue: arg.defaultValue
        };
      }) : [],
      locations: node.locations.map(function (location) {
        switch (location.value) {
          case 'QUERY':
          case 'MUTATION':
          case 'SUBSCRIPTION':
          case 'FIELD':
          case 'FRAGMENT_DEFINITION':
          case 'FRAGMENT_SPREAD':
          case 'INLINE_FRAGMENT':
          case 'VARIABLE_DEFINITION':
          case 'SCHEMA':
          case 'SCALAR':
          case 'OBJECT':
          case 'FIELD_DEFINITION':
          case 'ARGUMENT_DEFINITION':
          case 'INTERFACE':
          case 'UNION':
          case 'ENUM':
          case 'ENUM_VALUE':
          case 'INPUT_OBJECT':
          case 'INPUT_FIELD_DEFINITION':
            return location.value;

          default:
            throw createCompilerError('Invalid directive location');
        }
      }),
      isClient: isClient
    });
  };

  _proto5._parseObjectTypeExtension = function _parseObjectTypeExtension(node) {
    var type = this._types.get(node.name.value);

    if (!(type instanceof ObjectType)) {
      throw createCompilerError("_parseObjectTypeExtension: Expected to find type with the name '".concat(node.name.value, "'"), null, [node]);
    }

    node.fields && this._handleTypeFields(type, node.fields, true
    /** client fields */
    );
  };

  _proto5._parseInterfaceTypeExtension = function _parseInterfaceTypeExtension(node) {
    var type = this._types.get(node.name.value);

    if (!(type instanceof InterfaceType)) {
      throw createCompilerError('_parseInterfaceTypeExtension: Expected to have an interface type');
    }

    node.fields && this._handleTypeFields(type, node.fields, true);
  };

  _proto5._extend = function _extend(extensions) {
    var _this9 = this;

    extensions.forEach(function (definition) {
      if (definition.kind === 'ObjectTypeDefinition') {
        _this9._parseObjectTypeNode(definition, true);
      } else if (definition.kind === 'InterfaceTypeDefinition') {
        _this9._parseInterfaceNode(definition, true);
      } else if (definition.kind === 'ScalarTypeDefinition') {
        _this9._parseScalarNode(definition, true);
      } else if (definition.kind === 'EnumTypeDefinition') {
        _this9._parseEnumNode(definition, true);
      } else if (definition.kind === 'InterfaceTypeExtension') {
        _this9._parseInterfaceTypeExtension(definition);
      } else if (definition.kind === 'ObjectTypeExtension') {
        _this9._parseObjectTypeExtension(definition);
      } else if (definition.kind === 'DirectiveDefinition') {
        _this9._parseDirective(definition, true
        /* client directive */
        );
      } else {
        throw createCompilerError("Unexpected extension kind: '".concat(definition.kind, "'"), null, [definition]);
      }
    });
  };

  _proto5.getTypes = function getTypes() {
    return Array.from(this._types.values());
  };

  _proto5.getTypeByName = function getTypeByName(typename) {
    return this._types.get(typename);
  };

  _proto5.getInterfaces = function getInterfaces(type) {
    var _this$_typeInterfaces;

    return (_this$_typeInterfaces = this._typeInterfaces.get(type)) !== null && _this$_typeInterfaces !== void 0 ? _this$_typeInterfaces : [];
  };

  _proto5.getPossibleTypeSet = function getPossibleTypeSet(type) {
    var set;

    if (type instanceof InterfaceType) {
      var _this$_interfaceImple2;

      set = (_this$_interfaceImple2 = this._interfaceImplementations.get(type)) !== null && _this$_interfaceImple2 !== void 0 ? _this$_interfaceImple2 : new Set();
    } else if (type instanceof UnionType) {
      var _this$_unionTypes$get;

      set = (_this$_unionTypes$get = this._unionTypes.get(type)) !== null && _this$_unionTypes$get !== void 0 ? _this$_unionTypes$get : new Set();
    } else {
      throw createCompilerError('Invalid type supplied to "getPossibleTypeSet"');
    }

    if (!set) {
      throw createCompilerError("Unable to find possible types for ".concat(type.name));
    }

    return set;
  };

  _proto5.getFetchableFieldName = function getFetchableFieldName(type) {
    var _this$_fetchable$get$, _this$_fetchable$get;

    return (_this$_fetchable$get$ = (_this$_fetchable$get = this._fetchable.get(type)) === null || _this$_fetchable$get === void 0 ? void 0 : _this$_fetchable$get.field_name) !== null && _this$_fetchable$get$ !== void 0 ? _this$_fetchable$get$ : null;
  };

  _proto5.getQueryType = function getQueryType() {
    return this._types.get(this._queryTypeName);
  };

  _proto5.getMutationType = function getMutationType() {
    return this._types.get(this._mutationTypeName);
  };

  _proto5.getSubscriptionType = function getSubscriptionType() {
    return this._types.get(this._subscriptionTypeName);
  };

  _proto5.getField = function getField(type, fieldName) {
    var fields = this._fields.get(type);

    if (fields) {
      return fields.get(fieldName);
    }
  };

  _proto5.getFieldMap = function getFieldMap(type) {
    return this._fields.get(type);
  };

  _proto5.getInputField = function getInputField(type, fieldName) {
    var inputFields = this._inputFields.get(type);

    if (inputFields) {
      return inputFields.get(fieldName);
    }
  };

  _proto5.getInputFieldMap = function getInputFieldMap(type) {
    return this._inputFields.get(type);
  };

  _proto5.getDirectives = function getDirectives() {
    return Array.from(this._directives.values());
  };

  _proto5.extend = function extend(extensions) {
    return new TypeMap(this._source, this._extensions.concat(extensions));
  };

  return TypeMap;
}();

function create(baseSchema, schemaExtensionDocuments, schemaExtensions) {
  var extensions = [];
  schemaExtensions && schemaExtensions.forEach(function (source) {
    var doc = parse(source, {
      noLocation: true
    });
    doc.definitions.forEach(function (definition) {
      if (isSchemaDefinitionAST(definition)) {
        extensions.push(definition);
      }
    });
  });
  schemaExtensionDocuments && schemaExtensionDocuments.forEach(function (doc) {
    doc.definitions.forEach(function (definition) {
      if (isSchemaDefinitionAST(definition)) {
        extensions.push(definition);
      }
    });
  });
  return new Schema(new TypeMap(baseSchema, extensions));
}

function parseInputArgumentDefinitions(schema, args) {
  return args.map(function (arg) {
    var argType = schema.assertInputType(schema.expectTypeFromAST(arg.typeNode));
    var defaultValue;
    var defaultValueNode = arg.defaultValue;

    if (defaultValueNode != null) {
      var nullableType = schema.getNullableType(argType);
      var isNullable = schema.isNonNull(argType) === false;

      if (isNullable && defaultValueNode.kind === 'NullValue') {
        defaultValue = null;
      } else {
        if (nullableType instanceof ScalarType || nullableType instanceof EnumType) {
          defaultValue = schema.parseLiteral(nullableType, defaultValueNode);
        } else if (nullableType instanceof List && defaultValueNode.kind === 'ListValue' || nullableType instanceof InputObjectType && defaultValueNode.kind === 'ObjectValue') {
          defaultValue = valueFromASTUntyped(defaultValueNode);
        }
      }

      if (defaultValue === undefined) {
        throw createCompilerError("parseInputArgumentDefinitions: Unexpected default value: ".concat(String(defaultValueNode), ". Expected to have a value of type ").concat(String(nullableType), "."));
      }
    }

    return {
      name: arg.name,
      type: argType,
      defaultValue: defaultValue
    };
  });
}

function parseInputArgumentDefinitionsMap(schema, args) {
  return new Map(parseInputArgumentDefinitions(schema, args).map(function (arg) {
    return [arg.name, arg];
  }));
}

function isDefaultScalar(name) {
  return new Set(['ID', 'String', 'Boolean', 'Int', 'Float']).has(name);
}

module.exports = {
  create: create
};

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/inheritsLoose");

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var chalk = __webpack_require__(62);

function getMemoryUsageString() {
  return chalk.blue(Math.round(process.memoryUsage().heapUsed / 1024 / 1024) + 'Mb');
}

var ConsoleReporter = /*#__PURE__*/function () {
  function ConsoleReporter(options) {
    this._verbose = options.verbose;
    this._quiet = options.quiet;
  }

  var _proto = ConsoleReporter.prototype;

  _proto.reportMessage = function reportMessage(message) {
    if (!this._quiet) {
      process.stdout.write(message + '\n');
    }
  };

  _proto.reportTime = function reportTime(name, ms) {
    if (this._verbose && !this._quiet) {
      var time = ms === 0 ? chalk.gray(' <1ms') : ms < 1000 ? chalk.blue(leftPad(5, ms + 'ms')) : chalk.red(Math.floor(ms / 10) / 100 + 's');
      process.stdout.write('  ' + time + ' ' + chalk.gray(name) + ' [' + getMemoryUsageString() + ']\n');
    }
  };

  _proto.reportError = function reportError(caughtLocation, error) {
    if (!this._quiet) {
      process.stdout.write(chalk.red('ERROR:\n' + error.message + '\n'));

      if (this._verbose) {
        var frames = error.stack.match(/^ {4}at .*$/gm);

        if (frames) {
          process.stdout.write(chalk.gray('From: ' + caughtLocation + '\n' + frames.join('\n') + '\n'));
        }
      }
    }
  };

  return ConsoleReporter;
}();

function leftPad(len, str) {
  return new Array(len - str.length + 1).join(' ') + str;
}

module.exports = ConsoleReporter;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

module.exports = require("chalk");

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var ASTCache = __webpack_require__(29);

var fs = __webpack_require__(13);

var path = __webpack_require__(9);

var _require = __webpack_require__(8),
    parse = _require.parse,
    Source = _require.Source;

function parseFile(baseDir, file) {
  var text = fs.readFileSync(path.join(baseDir, file.relPath), 'utf8');
  return parse(new Source(text, file.relPath), {
    experimentalFragmentVariables: true
  });
}

function getParser(baseDir) {
  return new ASTCache({
    baseDir: baseDir,
    parse: parseFile
  });
}

module.exports = {
  parseFile: parseFile,
  getParser: getParser
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _asyncToGenerator = __webpack_require__(12);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var ASTConvert = __webpack_require__(65);

var CodegenDirectory = __webpack_require__(28);

var CompilerContext = __webpack_require__(24);

var Profiler = __webpack_require__(7);

var RelayParser = __webpack_require__(30);

var compileRelayArtifacts = __webpack_require__(67);

var graphql = __webpack_require__(8);

var invariant = __webpack_require__(6);

var md5 = __webpack_require__(25);

var nullthrows = __webpack_require__(17);

var path = __webpack_require__(9);

var writeRelayGeneratedFile = __webpack_require__(72);

var _require = __webpack_require__(76),
    getReaderSourceDefinitionName = _require.getReaderSourceDefinitionName;

var _require2 = __webpack_require__(10),
    isExecutableDefinitionAST = _require2.isExecutableDefinitionAST;

var _require3 = __webpack_require__(15),
    ImmutableMap = _require3.Map;

function compileAll(_ref) {
  var baseDir = _ref.baseDir,
      baseDocuments = _ref.baseDocuments,
      schema = _ref.schema,
      compilerTransforms = _ref.compilerTransforms,
      documents = _ref.documents,
      reporter = _ref.reporter,
      typeGenerator = _ref.typeGenerator;
  var definitions = ASTConvert.convertASTDocumentsWithBase(schema, baseDocuments, documents, RelayParser.transform);
  var compilerContext = new CompilerContext(schema).addAll(definitions);
  var transformedTypeContext = compilerContext.applyTransforms(typeGenerator.transforms, reporter);
  var transformedQueryContext = compilerContext.applyTransforms([].concat((0, _toConsumableArray2["default"])(compilerTransforms.commonTransforms), (0, _toConsumableArray2["default"])(compilerTransforms.queryTransforms)), reporter);
  var artifacts = compileRelayArtifacts(compilerContext, compilerTransforms, reporter);
  return {
    artifacts: artifacts,
    definitions: definitions,
    transformedQueryContext: transformedQueryContext,
    transformedTypeContext: transformedTypeContext
  };
}

function writeAll(_ref2) {
  var writerConfig = _ref2.config,
      onlyValidate = _ref2.onlyValidate,
      baseDocuments = _ref2.baseDocuments,
      documents = _ref2.documents,
      schema = _ref2.schema,
      reporter = _ref2.reporter,
      sourceControl = _ref2.sourceControl,
      languagePlugin = _ref2.languagePlugin;
  return Profiler.asyncContext('RelayFileWriter.writeAll', /*#__PURE__*/_asyncToGenerator(function* () {
    var _compileAll = compileAll({
      schema: schema,
      baseDir: writerConfig.baseDir,
      baseDocuments: baseDocuments.valueSeq().toArray(),
      compilerTransforms: writerConfig.compilerTransforms,
      documents: documents.valueSeq().toArray(),
      reporter: reporter,
      typeGenerator: writerConfig.typeGenerator
    }),
        artifactsWithBase = _compileAll.artifacts,
        transformedTypeContext = _compileAll.transformedTypeContext,
        transformedQueryContext = _compileAll.transformedQueryContext; // Build a context from all the documents


    var baseDefinitionNames = new Set();
    baseDocuments.forEach(function (doc) {
      doc.definitions.forEach(function (def) {
        if (isExecutableDefinitionAST(def) && def.name) {
          baseDefinitionNames.add(def.name.value);
        }
      });
    }); // remove nodes that are present in the base or that derive from nodes
    // in the base

    var artifacts = artifactsWithBase.filter(function (_ref3) {
      var _definition = _ref3[0],
          node = _ref3[1];
      var sourceName = getReaderSourceDefinitionName(node);
      return !baseDefinitionNames.has(sourceName);
    });
    var artifactMap = new Map(artifacts.map(function (_ref4) {
      var _definition = _ref4[0],
          node = _ref4[1];
      return [node.kind === 'Request' ? node.params.name : node.name, node];
    }));
    var definitionsMeta = new Map();

    var getDefinitionMeta = function getDefinitionMeta(definitionName) {
      var artifact = nullthrows(artifactMap.get(definitionName));
      var sourceName = getReaderSourceDefinitionName(artifact);
      var definitionMeta = definitionsMeta.get(sourceName);
      !definitionMeta ?  true ? invariant(false, 'RelayFileWriter: Could not determine source for definition: `%s`.', definitionName) : undefined : void 0;
      return definitionMeta;
    };

    documents.forEach(function (doc, filePath) {
      doc.definitions.forEach(function (def) {
        if (def.name) {
          definitionsMeta.set(def.name.value, {
            dir: path.join(writerConfig.baseDir, path.dirname(filePath)),
            ast: def
          });
        }
      });
    });
    var allOutputDirectories = new Map();

    var addCodegenDir = function addCodegenDir(dirPath) {
      var codegenDir = new CodegenDirectory(dirPath, {
        onlyValidate: onlyValidate,
        filesystem: writerConfig.filesystem
      });
      allOutputDirectories.set(dirPath, codegenDir);
      return codegenDir;
    };

    var _iterator = (0, _createForOfIteratorHelper2["default"])(writerConfig.generatedDirectories || []),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var existingDirectory = _step.value;
        addCodegenDir(existingDirectory);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var configOutputDirectory;

    if (writerConfig.outputDir) {
      configOutputDirectory = addCodegenDir(writerConfig.outputDir);
    }

    var getGeneratedDirectory = function getGeneratedDirectory(definitionName) {
      if (configOutputDirectory) {
        return configOutputDirectory;
      }

      var generatedPath = path.join(getDefinitionMeta(definitionName).dir, '__generated__');
      var cachedDir = allOutputDirectories.get(generatedPath);

      if (!cachedDir) {
        cachedDir = addCodegenDir(generatedPath);
      }

      return cachedDir;
    };

    var formatModule = Profiler.instrument(writerConfig.formatModule, 'RelayFileWriter:formatModule');
    var persistQuery = writerConfig.persistQuery ? Profiler.instrumentWait(writerConfig.persistQuery, 'RelayFileWriter:persistQuery') : null;

    try {
      yield Promise.all(artifacts.map( /*#__PURE__*/function () {
        var _ref7 = _asyncToGenerator(function* (_ref5) {
          var _writerConfig$repersi, _writerConfig$writeQu;

          var definition = _ref5[0],
              node = _ref5[1];
          var nodeName = node.kind === 'Request' ? node.params.name : node.name;

          if (baseDefinitionNames.has(nodeName)) {
            // don't add definitions that were part of base context
            return;
          }

          var typeNode = transformedTypeContext.get(nodeName);
          var typeText = typeNode ? writerConfig.typeGenerator.generate(schema, typeNode, {
            customScalars: writerConfig.customScalars,
            enumsHasteModule: writerConfig.enumsHasteModule,
            optionalInputFields: writerConfig.optionalInputFieldsForFlow,
            useHaste: writerConfig.useHaste,
            useSingleArtifactDirectory: !!writerConfig.outputDir,
            noFutureProofEnums: writerConfig.noFutureProofEnums,
            normalizationIR: definition.kind === 'Request' ? definition.root : undefined
          }) : '';
          var sourceHash = Profiler.run('hashGraphQL', function () {
            return md5(graphql.print(getDefinitionMeta(nodeName).ast));
          });
          yield writeRelayGeneratedFile(schema, getGeneratedDirectory(nodeName), definition, node, formatModule, typeText, persistQuery, sourceHash, writerConfig.extension, writerConfig.printModuleDependency, (_writerConfig$repersi = writerConfig.repersist) !== null && _writerConfig$repersi !== void 0 ? _writerConfig$repersi : false, (_writerConfig$writeQu = writerConfig.writeQueryParameters) !== null && _writerConfig$writeQu !== void 0 ? _writerConfig$writeQu : function noop() {}, languagePlugin);
        });

        return function (_x) {
          return _ref7.apply(this, arguments);
        };
      }()));
      var generateExtraFiles = writerConfig.generateExtraFiles;

      if (generateExtraFiles) {
        Profiler.run('RelayFileWriter:generateExtraFiles', function () {
          var configDirectory = writerConfig.outputDir;
          generateExtraFiles(function (dir) {
            var outputDirectory = dir || configDirectory;
            !outputDirectory ?  true ? invariant(false, 'RelayFileWriter: cannot generate extra files without specifying ' + 'an outputDir in the config or passing it in.') : undefined : void 0;
            var outputDir = allOutputDirectories.get(outputDirectory);

            if (!outputDir) {
              outputDir = addCodegenDir(outputDirectory);
            }

            return outputDir;
          }, transformedQueryContext, getGeneratedDirectory);
        });
      }

      allOutputDirectories.forEach(function (dir) {
        dir.deleteExtraFiles(languagePlugin === null || languagePlugin === void 0 ? void 0 : languagePlugin.keepExtraFile);
      });

      if (sourceControl && !onlyValidate) {
        yield CodegenDirectory.sourceControlAddRemove(sourceControl, Array.from(allOutputDirectories.values()));
      }
    } catch (error) {
      var details;

      try {
        details = JSON.parse(error.message);
      } catch (_) {} // eslint-disable-line lint/no-unused-catch-bindings


      if (details && details.name === 'GraphQL2Exception' && details.message) {
        throw new Error('GraphQL error writing modules:\n' + details.message);
      }

      throw new Error('Error writing modules:\n' + String(error.stack || error));
    }

    return allOutputDirectories;
  }));
}

module.exports = {
  writeAll: writeAll
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var Profiler = __webpack_require__(7);

var _require = __webpack_require__(10),
    isExecutableDefinitionAST = _require.isExecutableDefinitionAST,
    isSchemaDefinitionAST = _require.isSchemaDefinitionAST;

var _require2 = __webpack_require__(8),
    extendSchema = _require2.extendSchema,
    parse = _require2.parse,
    print = _require2.print,
    visit = _require2.visit;

function convertASTDocuments(schema, documents, transform) {
  return Profiler.run('ASTConvert.convertASTDocuments', function () {
    var definitions = definitionsFromDocuments(documents);
    var astDefinitions = [];
    documents.forEach(function (doc) {
      doc.definitions.forEach(function (definition) {
        if (isExecutableDefinitionAST(definition)) {
          astDefinitions.push(definition);
        }
      });
    });
    return convertASTDefinitions(schema, definitions, transform);
  });
}

function convertASTDocumentsWithBase(schema, baseDocuments, documents, transform) {
  return Profiler.run('ASTConvert.convertASTDocumentsWithBase', function () {
    var baseDefinitions = definitionsFromDocuments(baseDocuments);
    var definitions = definitionsFromDocuments(documents);
    var requiredDefinitions = new Map();
    var baseMap = new Map();
    baseDefinitions.forEach(function (definition) {
      if (isExecutableDefinitionAST(definition)) {
        var definitionName = definition.name && definition.name.value; // If there's no name, no reason to put in the map

        if (definitionName != null) {
          if (baseMap.has(definitionName)) {
            throw new Error("Duplicate definition of '".concat(definitionName, "'."));
          }

          baseMap.set(definitionName, definition);
        }
      }
    });
    var definitionsToVisit = [];
    definitions.forEach(function (definition) {
      if (isExecutableDefinitionAST(definition)) {
        definitionsToVisit.push(definition);
      }
    });

    while (definitionsToVisit.length > 0) {
      var definition = definitionsToVisit.pop();
      var name = definition.name && definition.name.value;

      if (name == null) {
        continue;
      }

      if (requiredDefinitions.has(name)) {
        if (requiredDefinitions.get(name) !== definition) {
          throw new Error("Duplicate definition of '".concat(name, "'."));
        }

        continue;
      }

      requiredDefinitions.set(name, definition);
      visit(definition, {
        FragmentSpread: function FragmentSpread(spread) {
          var baseDefinition = baseMap.get(spread.name.value);

          if (baseDefinition) {
            // We only need to add those definitions not already included
            // in definitions
            definitionsToVisit.push(baseDefinition);
          }
        }
      });
    }

    var definitionsToConvert = [];
    requiredDefinitions.forEach(function (definition) {
      return definitionsToConvert.push(definition);
    });
    return convertASTDefinitions(schema, definitionsToConvert, transform);
  });
}

function convertASTDefinitions(schema, definitions, transform) {
  var operationDefinitions = [];
  definitions.forEach(function (definition) {
    if (isExecutableDefinitionAST(definition)) {
      operationDefinitions.push(definition);
    }
  });
  return transform(schema, operationDefinitions);
}

function definitionsFromDocuments(documents) {
  var definitions = [];
  documents.forEach(function (doc) {
    doc.definitions.forEach(function (definition) {
      return definitions.push(definition);
    });
  });
  return definitions;
}
/**
 * Extends a GraphQLSchema with a list of schema extensions in string form.
 */


function transformASTSchema(schema, schemaExtensions) {
  return Profiler.run('ASTConvert.transformASTSchema', function () {
    if (schemaExtensions.length === 0) {
      return schema;
    }

    var extension = schemaExtensions.join('\n');
    return cachedExtend(schema, extension, function () {
      return extendSchema(schema, parse(extension));
    });
  });
}
/**
 * Extends a GraphQLSchema with a list of schema extensions in AST form.
 */


function extendASTSchema(baseSchema, documents) {
  return Profiler.run('ASTConvert.extendASTSchema', function () {
    var schemaExtensions = [];
    documents.forEach(function (doc) {
      doc.definitions.forEach(function (definition) {
        if (isSchemaDefinitionAST(definition)) {
          schemaExtensions.push(definition);
        }
      });
    });

    if (schemaExtensions.length === 0) {
      return baseSchema;
    }

    var key = schemaExtensions.map(print).join('\n');
    return cachedExtend(baseSchema, key, function () {
      return extendSchema(baseSchema, {
        kind: 'Document',
        definitions: schemaExtensions
      }, // TODO T24511737 figure out if this is dangerous
      {
        assumeValid: true
      });
    });
  });
}

var extendedSchemas = new Map();

function cachedExtend(schema, key, compute) {
  var cache = extendedSchemas.get(schema);

  if (!cache) {
    cache = {};
    extendedSchemas.set(schema, cache);
  }

  var extendedSchema = cache[key];

  if (!extendedSchema) {
    extendedSchema = compute();
    cache[key] = extendedSchema;
  }

  return extendedSchema;
}

module.exports = {
  convertASTDocuments: convertASTDocuments,
  convertASTDocumentsWithBase: convertASTDocumentsWithBase,
  extendASTSchema: extendASTSchema,
  transformASTSchema: transformASTSchema
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var OR_LIST_MAX_LENGTH = 5;

var _require = __webpack_require__(1),
    createCompilerError = _require.createCompilerError;

function orList(items) {
  if (items.length === 0) {
    throw createCompilerError('Expected an array of strings. Got empty array');
  }

  if (items.length === 1) {
    return items[0];
  }

  if (items.length > OR_LIST_MAX_LENGTH) {
    return items.slice(0, OR_LIST_MAX_LENGTH).join(', ') + ', ...';
  }

  var selected = items.slice();
  var lastItem = selected.pop();
  return selected.join(', ') + ' or ' + lastItem;
}

module.exports = orList;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 */
// flowlint ambiguous-object-type:error


var _interopRequireDefault = __webpack_require__(0);

var _createForOfIteratorHelper2 = _interopRequireDefault(__webpack_require__(4));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(5));

var Printer = __webpack_require__(33);

var Profiler = __webpack_require__(7);

var RelayCodeGenerator = __webpack_require__(68);

var filterContextForNode = __webpack_require__(71);

function createFragmentContext(context, transforms, reporter) {
  // The fragment is used for reading data from the normalized store.
  return context.applyTransforms([].concat((0, _toConsumableArray2["default"])(transforms.commonTransforms), (0, _toConsumableArray2["default"])(transforms.fragmentTransforms)), reporter);
}

function createPrintContext(context, transforms, reporter) {
  // The unflattened query is used for printing, since flattening creates an
  // invalid query.
  return context.applyTransforms([].concat((0, _toConsumab